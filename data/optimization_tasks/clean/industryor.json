[
{
  "task_id": "B000",
  "description": "A factory produces two types of food, I and II, and currently has 50 skilled workers. It is known that one skilled worker can produce $10 \\ \\mathrm{kg} / \\ \\mathrm{h}$ of food I or $6 \\ \\mathrm{kg} / \\ \\mathrm{h}$ of food II. According to contract bookings, the weekly demand for these two foods will rise sharply, as shown in Table 1-11. Therefore, the factory has decided to train 50 new workers by the end of the 8th week. It is known that a worker works $40 \\ \\mathrm{h}$ per week, and a skilled worker can train up to three new workers in two weeks (during the training period, both the skilled worker and the trainees do not participate in production). The weekly wage of a skilled worker is 360 yuan, the weekly wage of a trainee during the training period is 120 yuan, and after training, the wage is 240 yuan per week, with the same production efficiency as skilled workers. During the transition period of training, many skilled workers are willing to work overtime, and the factory has decided to arrange some workers to work $60 \\ \\mathrm{h}$ per week, with a weekly wage of 540 yuan. If the booked food cannot be delivered on time, the compensation fee for each week of delay per $ \\ \\mathrm{kg}$ is 0.5 yuan for food I and 0.6 yuan for food II. Under these conditions, how should the factory make comprehensive arrangements to minimize the total cost?\n\nTable 1-11\n\n| Week | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |\n|------|---|---|---|---|---|---|---|---|\n| I    | 10000 | 10000  | 12000  | 12000  | 16000  | 16000  | 20000  | 20000  |\n| II   | 6000 | 7200 | 8400 | 10800 | 10800 | 12000  | 12000  | 12000  |",
  "ground_truth": 219600.0,
  "formulation": null,
  "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_factory_problem():\n    model = gp.Model(\"FactoryProductionTraining\")\n\n    # --- Parameters ---\n    weeks = range(1, 9)  # 1 to 8\n    products = [1, 2]  # Food I and II\n\n    initial_skilled_workers = 50\n    new_workers_to_train_total = 50\n\n    # Demand (kg)\n    demand_data = {\n        1: {\n            1: 10000,\n            2: 10000,\n            3: 12000,\n            4: 12000,\n            5: 16000,\n            6: 16000,\n            7: 20000,\n            8: 20000\n        },\n        2: {\n            1: 6000,\n            2: 7200,\n            3: 8400,\n            4: 10800,\n            5: 10800,\n            6: 12000,\n            7: 12000,\n            8: 12000\n        }\n    }\n\n    # Production rates (kg/h per worker)\n    prod_rate = {1: 10, 2: 6}\n\n    # Work hours per week\n    hours_normal = 40\n    hours_overtime = 60\n\n    # Wages (yuan per week)\n    wage_skilled_normal = 360\n    wage_skilled_overtime = 540\n    wage_trainee = 120\n    wage_newly_skilled = 240  # After training\n\n    # Training: 1 skilled trains up to 3 new workers in 2 weeks\n    training_ratio = 3  # new workers per skilled trainer\n    training_duration = 2  # weeks\n\n    # Compensation fee for delay (yuan per kg per week of delay)\n    delay_penalty = {1: 0.5, 2: 0.6}\n\n    initial_inventory = {\n        1: 0,\n        2: 0\n    }  # Assuming no initial inventory or backlog\n\n    # --- Decision Variables ---\n\n    # Original skilled workers allocation\n    sw_normal = model.addVars(weeks, name=\"SW_Normal\", vtype=GRB.INTEGER, lb=0)\n    sw_overtime = model.addVars(weeks,\n                                name=\"SW_Overtime\",\n                                vtype=GRB.INTEGER,\n                                lb=0)\n    sw_train = model.addVars(weeks, name=\"SW_Train\", vtype=GRB.INTEGER, lb=0)\n    sw_train_start = model.addVars(weeks,\n                                   name=\"SW_Train_Start\",\n                                   vtype=GRB.INTEGER,\n                                   lb=0)\n    # New workers\n    nw_start_training = model.addVars(weeks,\n                                      name=\"NW_Start_Training\",\n                                      vtype=GRB.INTEGER,\n                                      lb=0)\n    nw_training = model.addVars(weeks,\n                                name=\"NW_Training\",\n                                vtype=GRB.INTEGER,\n                                lb=0)  # Workers currently in training\n    nw_newly_skilled_prod = model.addVars(weeks,\n                                          name=\"NW_Newly_Skilled_Prod\",\n                                          vtype=GRB.INTEGER,\n                                          lb=0)\n\n    # Hours allocation by worker type and product\n    h_sw_normal = model.addVars(weeks,\n                                products,\n                                name=\"H_SW_Normal\",\n                                vtype=GRB.CONTINUOUS,\n                                lb=0)\n    h_sw_overtime = model.addVars(weeks,\n                                  products,\n                                  name=\"H_SW_Overtime\",\n                                  vtype=GRB.CONTINUOUS,\n                                  lb=0)\n    h_nw_newly_skilled = model.addVars(weeks,\n                                       products,\n                                       name=\"H_NW_Newly_Skilled\",\n                                       vtype=GRB.CONTINUOUS,\n                                       lb=0)\n\n    # Production quantities\n    P = model.addVars(weeks,\n                      products,\n                      name=\"Production\",\n                      vtype=GRB.CONTINUOUS,\n                      lb=0)\n\n    # Inventory and Backlog\n    Inv = model.addVars(weeks,\n                        products,\n                        name=\"Inventory\",\n                        vtype=GRB.CONTINUOUS,\n                        lb=-GRB.INFINITY)\n    Backlog_Surrogate = model.addVars(weeks,\n                                      products,\n                                      name=\"Backlog_Surrogate\",\n                                      vtype=GRB.CONTINUOUS,\n                                      lb=0)\n\n    # --- Objective Function: Minimize Total Cost ---\n    total_cost = gp.LinExpr()\n\n    for w in weeks:\n        # Wages for original skilled workers\n        total_cost += sw_normal[w] * wage_skilled_normal\n        total_cost += sw_overtime[w] * wage_skilled_overtime\n        total_cost += sw_train[w] * wage_skilled_normal\n\n        # Wages for trainees\n        total_cost += nw_training[w] * wage_trainee\n\n        # Wages for newly skilled workers (once they complete training and start producing)\n        total_cost += nw_newly_skilled_prod[w] * wage_newly_skilled\n\n        # Penalties for backlog\n        for p in products:\n            total_cost += Backlog_Surrogate[w, p] * delay_penalty[p]\n\n    model.setObjective(total_cost, GRB.MINIMIZE)\n\n    # --- Constraints ---\n\n    # C1: Original Skilled Worker Pool Allocation\n    for w in weeks:\n        model.addConstr(sw_normal[w] + sw_overtime[w] +\n                        sw_train[w] == initial_skilled_workers,\n                        name=f\"OriginalSW_Allocation_w{w}\")\n        if w < training_duration:\n            model.addConstr(sw_train[w] == sum(sw_train_start[w_inner]\n                                               for w_inner in range(1, w + 1)),\n                            name=f\"SW_TrainStart_Accumulation_w{w}\")\n        else:\n            model.addConstr(sw_train[w] == sum(sw_train_start[w_inner]\n                                               for w_inner in range(w - training_duration + 1, w + 1)),\n                            name=f\"SW_TrainStart_Accumulation_w{w}\")\n\n    # C2: New Worker Training Target\n    model.addConstr(\n        gp.quicksum(nw_start_training[w] for w in range(1, 8)) ==\n        new_workers_to_train_total,  # Weeks 1 to 7 for starting\n        name=\"TotalNewWorkersTrained\")\n    model.addConstr(nw_start_training[8] == 0, name=\"NoTrainingStartInWeek8\")\n    for w in weeks:\n        if w == 1:\n            model.addConstr(nw_training[w] == nw_start_training[w],\n                            name=f\"NewWorkersTrainingStart_w{w}\")\n        else:\n            model.addConstr(nw_training[w] == sum(nw_start_training[w_inner]\n                                                   for w_inner in range(w - training_duration + 1, w + 1)),\n                            name=f\"NewWorkersTraining_w{w}\")\n\n    # C3: Newly Skilled Worker Availability for Production\n    for w in weeks:\n        if w <= training_duration:\n            model.addConstr(nw_newly_skilled_prod[w] == 0,\n                            name=f\"NoNewlySkilled_w{w}\")\n        else:\n            model.addConstr(nw_newly_skilled_prod[w] == nw_newly_skilled_prod[w-1] +\n                            nw_start_training[w - training_duration],\n                            name=f\"NewlySkilledAvailability_w{w}\")\n\n    # C4: Training Capacity\n    for w in weeks:\n        model.addConstr(nw_start_training[w] <= training_ratio * sw_train_start[w],\n                        name=f\"TrainingCapacity_w{w}\")\n\n    # C5: Production Hours Allocation by Worker Type\n    for w in weeks:\n        # for p_idx, p_val in enumerate(\n        #         products\n        # ):  # Use p_val for keys, p_idx for list access if needed\n        # Original skilled workers - normal time\n        model.addConstr(gp.quicksum(h_sw_normal[w, p_inner]\n                                    for p_inner in products)\n                        == sw_normal[w] * hours_normal,\n                        name=f\"Hours_SW_Normal_Total_w{w}\"\n                        )  # Sum hours over products for this worker group\n        # Original skilled workers - overtime\n        model.addConstr(gp.quicksum(h_sw_overtime[w, p_inner]\n                                    for p_inner in products)\n                        == sw_overtime[w] * hours_overtime,\n                        name=f\"Hours_SW_Overtime_Total_w{w}\")\n        # Newly skilled workers - normal time\n        model.addConstr(gp.quicksum(h_nw_newly_skilled[w, p_inner]\n                                    for p_inner in products)\n                        == nw_newly_skilled_prod[w] * hours_normal,\n                        name=f\"Hours_NW_NewlySkilled_Total_w{w}\")\n    # Correction for C5: The constraints should be for the sum of hours for *that worker group* not per product.\n    # The above was trying to do it per product, fixed it to be per worker group total hours.\n\n    # C6: Production Calculation\n    for w in weeks:\n        for p in products:\n            total_hours_on_p = h_sw_normal[w, p] + h_sw_overtime[\n                w, p] + h_nw_newly_skilled[w, p]\n            model.addConstr(P[w, p] == total_hours_on_p * prod_rate[p],\n                            name=f\"ProductionCalc_w{w}_p{p}\")\n\n    # C7: Inventory Balance and Backlog Surrogate\n    for p in products:\n        for w in weeks:\n            prev_inv = Inv[w - 1, p] if w > 1 else initial_inventory[p]\n            model.addConstr(Inv[w, p] == prev_inv + P[w, p] - demand_data[p][w],\n                            name=f\"InventoryBalance_w{w}_p{p}\")\n            model.addConstr(Backlog_Surrogate[w, p] >= -Inv[w, p],\n                            name=f\"BacklogDef_w{w}_p{p}\")\n            # Backlog_Surrogate[w,p] >= 0 is already defined by lb=0 on the variable.\n    model.addConstrs((Backlog_Surrogate[8, p] == 0 for p in products),\n                     name=\"NoBacklogInWeek8\")  # No backlog in week 8\n\n    # --- Solve ---\n    model.optimize()\n\n    # --- Output Results ---\n    if model.status == GRB.OPTIMAL:\n        print(f\"\\nOptimal total cost: {model.ObjVal:.2f} yuan\\n\")\n\n        # Summary of workers allocation\n        print(\"--- Workers Allocation Summary ---\")\n        print(\n            \"Week | SW_Normal | SW_Overtime | SW_Train| NW_Training_Start | NW_Training | NW_Prod\"\n        )\n        for w in weeks:\n            print(\n                f\"{w:4} | {sw_normal[w].X:9.0f} | {sw_overtime[w].X:11.0f} | {sw_train[w].X:8.0f}| {nw_start_training[w].X:16.0f}  | {nw_training[w].X:11.0f} | {nw_newly_skilled_prod[w].X:7.0f}\"\n            )\n\n        # Production and backlog summary for each product\n        for p in products:\n            print(f\"\\n--- Production & Backlog Summary (Food {p}) ---\")\n            print(\"Week | Demand | Produced | Inventory_End | Backlog | Backlog_Penalty\")\n            for w in weeks:\n                backlog_penalty = Backlog_Surrogate[w, p].X * delay_penalty[p]\n                print(f\"{w:4} | {demand_data[p][w]:6} | {P[w, p].X:8.2f} | {Inv[w, p].X:14.2f} | {Backlog_Surrogate[w, p].X:7.2f} | {backlog_penalty:15.2f}\")\n\n    elif model.status == GRB.INFEASIBLE:\n        print(\"Model is infeasible. Computing IIS to find conflicting constraints...\")\n        model.computeIIS()\n        model.write(\"factory_model.ilp\")  # Write the IIS to a file\n        print(\"IIS written to factory_model.ilp. Please check this file to identify the cause of infeasibility.\")\n    else:\n        print(f\"Optimization ended with status: {model.status}\")\n\n    return model\n\n\nif __name__ == '__main__':\n    # Correcting the C5 constraint definition logic which was duplicated per product inside the loop.\n    # It should be one constraint per worker group per week.\n\n    # Create a temporary model instance to correct C5 structure before calling solve_factory_problem\n    temp_model = gp.Model()\n    weeks_param = range(1, 9)\n    products_param = [1, 2]\n    sw_normal_param = temp_model.addVars(\n        weeks_param, name=\"SW_Normal_param\")  # dummy for structure\n    h_sw_normal_param = temp_model.addVars(weeks_param,\n                                           products_param,\n                                           name=\"H_SW_Normal_param\")\n\n    # Corrected C5 logic demonstration (this is conceptual, actual fix is in the main function)\n    # for w_param in weeks_param:\n    #     temp_model.addConstr(gp.quicksum(h_sw_normal_param[w_param, p_param] for p_param in products_param) <= sw_normal_param[w_param] * hours_normal,\n    #                     name=f\"Hours_SW_Normal_Total_w{w_param}\")\n    # This logic IS correctly implemented in the solve_factory_problem function. The loop for 'p_idx, p_val' in C5 was misleading in my thought process but the gurobipy quicksum over products for each worker group is the correct implementation.\n\n    solved_model = solve_factory_problem()",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B002",
  "description": "For the manufacturing industry, formulating an appropriate product production plan and human resource management scheme is very important for reducing operating costs, inventory costs, stockout costs, and labor costs. Specifically, for products with large demand fluctuations, companies need to accurately predict demand and formulate corresponding production plans. A certain company produces a type of foldable table, the raw material cost for each product is 90 Yuan, and the labor hours are 5 hours. The unit price of the product is 300 Yuan. The company has 1,000 workers at the beginning of January and holds an inventory of 15,000 units. The regular hourly wage for workers is 30 Yuan, with a normal daily working time of 8 hours. Any extra working time is considered overtime, with an overtime hourly wage of 40 Yuan. The number of working days per month is calculated as 20 days. Suppose the company's available production machines are sufficient, and the capacity is not limited by machine hours. Each worker's overtime hours do not exceed 20 hours per month. Holding inventory will generate corresponding inventory costs. If a stockout occurs due to insufficient capacity, there will be certain stockout costs. Additionally, the company can also make up for the stockout part through outsourcing. The outsourcing cost per product, monthly inventory cost, and monthly stockout cost are 200 Yuan, 15 Yuan, and 35 Yuan, respectively. The company's employees are temporary workers, and the company can flexibly decide the number of people to hire and fire each month. The cost of hiring and firing a single employee is 5,000 Yuan and 8,000 Yuan, respectively. Suppose the company has used the existing forecasting model to predict the demand from January to June, as shown in Table 4.1.\n\nTable 4.1: Demand Forecast\n\n| Month | 1   | 2   | 3   | 4   | 5   | 6   |\n|:-----:|:---:|:---:|:---:|:---:|:---:|:---:|\n| Demand Forecast | 20000 | 40000 | 42000 | 35000 | 19000 | 18500 |\n\nPlease formulate a production plan, worker work schedule, and hire/fire plan for the company to maximize the total net profit over 6 months while ensuring that the company holds at least 10,000 units of products by the end of June.",
  "ground_truth": 10349920.0,
  "formulation": null,
  "correct_program": "from gurobipy import Model, GRB, quicksum\n# import gurobipy # This line is redundant and has been removed\n\n\ndef solve_production_planning_revised():\n    # --- Model Initialization ---\n    # --- 模型初始化 ---\n    m = Model(\"FoldableTableProductionRevised\")\n\n    # --- Time Horizon ---\n    # --- 时间范围 ---\n    months = list(range(6))\n    month_names = [\"January\", \"February\", \"March\", \"April\", \"May\",\n                   \"June\"]  # 月份名称\n\n    # --- Parameters ---\n    # --- 参数 ---\n    raw_material_cost_per_unit = 90  # 原材料成本/单位 (元)\n    regular_hourly_wage = 30  # 正常时薪 (元)\n    overtime_hourly_wage = 40  # 加班时薪 (元)\n    inventory_cost_per_unit_per_month = 15  # 库存成本/单位/月 (元)\n    stockout_penalty_per_unmet_unit = 35  # 最终未满足需求的缺货成本/单位 (元)\n    outsourcing_cost_per_unit = 200  # 外包成本/单位 (元)\n    hiring_cost_per_worker = 5000  # 雇佣成本/人 (元)\n    firing_cost_per_worker = 8000  # 解雇成本/人 (元)\n\n    labor_hours_per_unit = 5  # 单位产品所需工时 (小时)\n    selling_price_per_unit = 300  # 单位产品售价 (元)\n\n    initial_workers = 1000  # 初始工人数\n    normal_daily_working_hours = 8  # 每日正常工作时长 (小时)\n    working_days_per_month = 20  # 每月工作天数\n    normal_hours_per_worker_per_month = normal_daily_working_hours * working_days_per_month  # 每人每月正常工作时长 (小时)\n    max_overtime_hours_per_worker_per_month = 20  # 每人每月最大加班时长 (小时)\n\n    initial_inventory = 15000  # 初始库存 (单位)\n    min_ending_inventory_june = 10000  # 六月底最低期末库存 (单位)\n\n    # Demand Forecast (units per month)\n    # 需求预测 (单位/月)\n    demand_forecast = {\n        0: 20000,  # January  (一月)\n        1: 40000,  # February (二月)\n        2: 42000,  # March    (三月)\n        3: 35000,  # April    (四月)\n        4: 19000,  # May      (五月)\n        5: 18500  # June     (六月)\n    }\n\n    # --- Decision Variables ---\n    # --- 决策变量 ---\n    # P[t]: Production quantity in month t\n    # P[t]: 月份 t 的生产数量\n    P = m.addVars(months, name=\"Production\", vtype=GRB.INTEGER, lb=0)\n    # W[t]: Number of workers during month t (after hiring/firing)\n    # W[t]: 月份 t 的工人数 (雇佣/解雇后)\n    W = m.addVars(months, name=\"Workers\", vtype=GRB.INTEGER, lb=0)\n    # H[t]: Number of workers hired at the start of month t\n    # H[t]: 月份 t 初雇佣的工人数\n    H = m.addVars(months, name=\"Hired\", vtype=GRB.INTEGER, lb=0)\n    # F[t]: Number of workers fired at the start of month t\n    # F[t]: 月份 t 初解雇的工人数\n    F = m.addVars(months, name=\"Fired\", vtype=GRB.INTEGER, lb=0)\n    # OT_total[t]: Total overtime hours in month t\n    # OT_total[t]: 月份 t 的总加班工时\n    OT_total = m.addVars(months,\n                         name=\"OvertimeHours\",\n                         vtype=GRB.CONTINUOUS,\n                         lb=0)\n    OT_total = m.addVars(months, name=\"OvertimeHours\", vtype=GRB.INTEGER, lb=0)\n    # Inv[t]: Inventory at the end of month t\n    # Inv[t]: 月份 t 的期末库存\n    Inv = m.addVars(months, name=\"Inventory\", vtype=GRB.INTEGER, lb=0)\n    # Outsource[t]: Units outsourced in month t\n    # Outsource[t]: 月份 t 的外包数量\n    Outsource = m.addVars(months, name=\"Outsourced\", vtype=GRB.INTEGER, lb=0)\n    # S[t]: Final unmet demand (stockout) in month t\n    # S[t]: 月份 t 的最终未满足需求 (缺货) 数量\n    S = m.addVars(months, name=\"StockoutUnmet\", vtype=GRB.INTEGER, lb=0)\n\n    # --- Objective Function: Maximize Total Net Profit ---\n    # --- 目标函数: 最大化总净利润 ---\n    # Revenue is based on units sold (Demand - Unmet Stockout)\n    # 收入基于销售数量 (需求 - 未满足的缺货)\n    total_revenue = quicksum(\n        (demand_forecast[t] - S[t]) * selling_price_per_unit for t in months)\n\n    total_raw_material_cost = quicksum(P[t] * raw_material_cost_per_unit\n                                       for t in months)\n    total_regular_labor_cost = quicksum(\n        W[t] * normal_hours_per_worker_per_month * regular_hourly_wage\n        for t in months)\n    total_overtime_labor_cost = quicksum(OT_total[t] * overtime_hourly_wage\n                                         for t in months)\n    total_inventory_cost = quicksum(Inv[t] * inventory_cost_per_unit_per_month\n                                    for t in months)\n    # Outsourcing cost is now separate\n    # 外包成本现在是分开的\n    total_outsourcing_cost = quicksum(Outsource[t] * outsourcing_cost_per_unit\n                                      for t in months)\n    # Stockout cost for final unmet demand\n    # 最终未满足需求的缺货成本\n    total_stockout_unmet_cost = quicksum(S[t] * stockout_penalty_per_unmet_unit\n                                         for t in months)\n    total_hiring_cost = quicksum(H[t] * hiring_cost_per_worker for t in months)\n    total_firing_cost = quicksum(F[t] * firing_cost_per_worker for t in months)\n\n    total_costs = (\n        total_raw_material_cost + total_regular_labor_cost +\n        total_overtime_labor_cost + total_inventory_cost +\n        total_outsourcing_cost + total_stockout_unmet_cost\n        +  # Added stockout cost for S[t] # 为S[t]添加了缺货成本\n        total_hiring_cost + total_firing_cost)\n\n    m.setObjective(total_revenue - total_costs, GRB.MAXIMIZE)\n\n    # --- Constraints ---\n    # --- 约束条件 ---\n    for t in months:\n        # 1. Worker Balance Constraint\n        # 1. 工人数量平衡约束\n        if t == 0:\n            m.addConstr(W[t] == initial_workers + H[t] - F[t],\n                        name=f\"WorkerBalance_Month{t}\")\n        else:\n            m.addConstr(W[t] == W[t - 1] + H[t] - F[t],\n                        name=f\"WorkerBalance_Month{t}\")\n\n        # 2. Production Labor Hours Constraint\n        # 2. 生产工时约束\n        m.addConstr(P[t] * labor_hours_per_unit\n                    <= (W[t] * normal_hours_per_worker_per_month) +\n                    OT_total[t],\n                    name=f\"ProductionCapacity_Month{t}\")\n\n        # 3. Overtime Limit Constraint\n        # 3. 加班上限约束\n        m.addConstr(OT_total[t]\n                    <= W[t] * max_overtime_hours_per_worker_per_month,\n                    name=f\"OvertimeLimit_Month{t}\")\n\n        # 4. Inventory Balance Constraint (Revised)\n        # 4. 库存平衡约束 (修订版)\n        # Inv[t] = Previous_Inv + P[t] + Outsource[t] - (Demand[t] - S[t])\n        # This means: Ending_Inv + Sold_Units = Starting_Inv + Produced_Units + Outsourced_Units\n        # 这意味着: 期末库存 + 销售数量 = 期初库存 + 生产数量 + 外包数量\n        sold_units_t = demand_forecast[t] - S[t]\n        if t == 0:\n            m.addConstr(Inv[t] == initial_inventory + P[t] + Outsource[t] -\n                        sold_units_t,\n                        name=f\"InventoryBalance_Month{t}\")\n        else:\n            m.addConstr(Inv[t] == Inv[t - 1] + P[t] + Outsource[t] -\n                        sold_units_t,\n                        name=f\"InventoryBalance_Month{t}\")\n\n        # 5. Stockout (Unmet Demand) Definition Constraints (Linearized max function)\n        # 5. 缺货 (未满足需求) 定义约束 (线性化的max函数)\n        # S[t] >= Demand[t] - Previous_Inv - P[t] - Outsource[t]\n        # S[t] >= 0 (handled by lb=0 on variable S) (通过变量S的lb=0处理)\n        if t == 0:\n            m.addConstr(S[t] >= demand_forecast[t] - initial_inventory - P[t] -\n                        Outsource[t],\n                        name=f\"StockoutDef_Month{t}\")\n        else:\n            m.addConstr(S[t] >= demand_forecast[t] - Inv[t - 1] - P[t] -\n                        Outsource[t],\n                        name=f\"StockoutDef_Month{t}\")\n\n    # 6. Minimum Ending Inventory Constraint (for June - month 5)\n    # 6. 最低期末库存约束 (六月份 - 月份5)\n    m.addConstr(Inv[months[-1]] >= min_ending_inventory_june,\n                name=\"MinEndingInventory\")\n\n    # --- Solve Model ---\n    # --- 求解模型 ---\n    m.optimize()\n\n    # --- Print Results ---\n    # --- 打印结果 ---\n    if m.status == GRB.OPTIMAL:\n        print(\n            f\"\\nOptimal Solution Found. Total Net Profit: {m.objVal:,.2f} Yuan\"\n        )\n        print(\"-\" * 60)\n        print(\"Monthly Plan:\")\n        print(\"-\" * 60)\n        header = (\n            f\"{'Month':<10} | {'Demand':>8} | {'Sold':>8} | {'Unmet (S)':>9} | {'Workers':>7} | {'Hired':>6} | {'Fired':>6} | \"\n            f\"{'Production':>10} | {'Outsourced':>10} | {'OvertimeH':>10} | {'Avg OT/W':>8} | {'End Inv':>10}\"\n        )\n        print(header)\n        print(\"=\" * len(header))\n\n        total_prod = 0\n        total_outs = 0\n        total_hired = 0\n        total_fired = 0\n        total_ot = 0\n        total_unmet_s = 0\n        total_sold = 0\n\n        for t in months:\n            workers_t = W[t].X\n            avg_ot_per_worker = (OT_total[t].X /\n                                 workers_t) if workers_t > 0 else 0\n            sold_t = demand_forecast[t] - S[t].X\n            total_sold += sold_t\n            total_unmet_s += S[t].X\n            print(\n                f\"{month_names[t]:<10} | {demand_forecast[t]:>8,.0f} | {sold_t:>8,.0f} | {S[t].X:>9,.2f} | \"\n                f\"{workers_t:>7,.0f} | {H[t].X:>6,.0f} | {F[t].X:>6,.0f} | \"\n                f\"{P[t].X:>10,.2f} | {Outsource[t].X:>10,.2f} | {OT_total[t].X:>10,.2f} | \"\n                f\"{avg_ot_per_worker:>8,.2f} | {Inv[t].X:>10,.2f}\")\n            total_prod += P[t].X\n            total_outs += Outsource[t].X\n            total_hired += H[t].X\n            total_fired += F[t].X\n            total_ot += OT_total[t].X\n\n        print(\"=\" * len(header))\n        print(\"Summary over 6 months:\")\n        print(f\"Total Demand: {sum(demand_forecast.values()):,.0f} units\")\n        print(f\"Total Sold: {total_sold:,.0f} units\")\n        print(f\"Total Unmet Demand (S): {total_unmet_s:,.2f} units\")\n        print(f\"Total Production: {total_prod:,.2f} units\")\n        print(f\"Total Outsourced: {total_outs:,.2f} units\")\n        print(f\"Total Hired: {total_hired:,.0f} workers\")\n        print(f\"Total Fired: {total_fired:,.0f} workers\")\n        print(f\"Total Overtime Hours: {total_ot:,.2f} hours\")\n        print(\n            f\"Ending Inventory (June): {Inv[months[-1]].X:,.2f} units (Min required: {min_ending_inventory_june:,})\"\n        )\n        print(\"-\" * 60)\n\n        # Recalculate costs and revenue for verification\n        # 重新计算成本和收入以进行验证\n        calc_revenue = sum(\n            (demand_forecast[t] - S[t].X) * selling_price_per_unit\n            for t in months)\n        calc_rm_cost = sum(P[t].X * raw_material_cost_per_unit for t in months)\n        calc_reg_labor_cost = sum(W[t].X * normal_hours_per_worker_per_month *\n                                  regular_hourly_wage for t in months)\n        calc_ot_labor_cost = sum(OT_total[t].X * overtime_hourly_wage\n                                 for t in months)\n        calc_inv_cost = sum(Inv[t].X * inventory_cost_per_unit_per_month\n                            for t in months)\n        calc_outs_cost = sum(Outsource[t].X * outsourcing_cost_per_unit\n                             for t in months)\n        calc_stockout_unmet_cost = sum(S[t].X * stockout_penalty_per_unmet_unit\n                                       for t in months)\n        calc_hir_cost = sum(H[t].X * hiring_cost_per_worker for t in months)\n        calc_fir_cost = sum(F[t].X * firing_cost_per_worker for t in months)\n        calc_total_costs = calc_rm_cost + calc_reg_labor_cost + calc_ot_labor_cost + calc_inv_cost + calc_outs_cost + calc_stockout_unmet_cost + calc_hir_cost + calc_fir_cost\n\n        print(\n            \"\\nBreakdown of Total Revenue and Costs (Calculated from solution):\"\n        )\n        print(f\"  Total Revenue (from sold units): {calc_revenue:,.2f} Yuan\")\n        print(f\"  Total Raw Material Cost: {calc_rm_cost:,.2f} Yuan\")\n        print(f\"  Total Regular Labor Cost: {calc_reg_labor_cost:,.2f} Yuan\")\n        print(f\"  Total Overtime Labor Cost: {calc_ot_labor_cost:,.2f} Yuan\")\n        print(f\"  Total Inventory Cost: {calc_inv_cost:,.2f} Yuan\")\n        print(f\"  Total Outsourcing Cost (base): {calc_outs_cost:,.2f} Yuan\")\n        print(\n            f\"  Total Stockout Unmet Cost (for S>0): {calc_stockout_unmet_cost:,.2f} Yuan\"\n        )\n        print(f\"  Total Hiring Cost: {calc_hir_cost:,.2f} Yuan\")\n        print(f\"  Total Firing Cost: {calc_fir_cost:,.2f} Yuan\")\n        print(f\"  Calculated Total Costs: {calc_total_costs:,.2f} Yuan\")\n        print(\n            f\"  Calculated Net Profit (Revenue - Costs): {calc_revenue - calc_total_costs:,.2f} Yuan (Should match Gurobi's m.objVal)\"\n        )\n\n    elif m.status == GRB.INFEASIBLE:\n        print(\"Model is infeasible. Check constraints.\")  # 模型不可行，请检查约束\n        m.computeIIS()\n        m.write(\"model_revised_iis.ilp\")\n        print(\"IIS written to model_revised_iis.ilp\"\n              )  # IIS已写入model_revised_iis.ilp\n    elif m.status == GRB.UNBOUNDED:\n        print(\"Model is unbounded.\")  # 模型无界\n    else:\n        print(\n            f\"Optimization was stopped with status {m.status}\")  # 优化已停止，状态为...\n\n\nif __name__ == '__main__':\n    solve_production_planning_revised()",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B003",
  "description": "A farmer needs to decide how many cows, sheep, and chickens to raise in order to achieve maximum profit. The farmer can sell cows, sheep, and chickens for $500, $200, and $8 each, respectively. The feed costs for each cow, sheep, and chicken are $100, $80, and $5, respectively. The profit is the difference between the selling price and the feed cost. Each cow, sheep, and chicken produces 10, 5, and 3 units of manure per day, respectively. Due to the limited time the farm staff has for cleaning the farm each day, they can handle up to 800 units of manure. Additionally, because of the limited farm size, the farmer can raise at most 50 chickens. Furthermore, the farmer must have at least 10 cows to meet customer demand. The farmer must also raise at least 20 sheep. Finally, the total number of animals cannot exceed 100.",
  "ground_truth": 30400.0,
  "formulation": null,
  "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef farmer_optimization(cow_price=500,\n                        sheep_price=200,\n                        chicken_price=8,\n                        cow_feed_cost=100,\n                        sheep_feed_cost=80,\n                        chicken_feed_cost=5,\n                        max_manure=800,\n                        max_chickens=50,\n                        min_cows=10,\n                        min_sheep=20,\n                        max_total_animals=100):\n    \"\"\"\n    Solves the farmer's optimization problem to maximize profit given constraints on\n    manure production, animal limits, and minimum required animals.\n\n    Parameters:\n        cow_price (float): Selling price for each cow. Default is 500.\n        sheep_price (float): Selling price for each sheep. Default is 200.\n        chicken_price (float): Selling price for each chicken. Default is 8.\n        cow_feed_cost (float): Feed cost for each cow. Default is 100.\n        sheep_feed_cost (float): Feed cost for each sheep. Default is 80.\n        chicken_feed_cost (float): Feed cost for each chicken. Default is 5.\n        max_manure (int): Maximum daily manure units allowed. Default is 800.\n        max_chickens (int): Maximum number of chickens allowed. Default is 50.\n        min_cows (int): Minimum number of cows required. Default is 10.\n        min_sheep (int): Minimum number of sheep required. Default is 20.\n        max_total_animals (int): Maximum total number of animals allowed. Default is 100.\n\n    Returns:\n        float or str: The optimal objective value if an optimal solution is found;\n                      otherwise, returns the model status as a string.\n    \"\"\"\n    model = gp.Model(\"Farmer_Optimization\")\n    model.setParam('OutputFlag', 0)  # Suppress output\n\n    # Decision variables\n    cows = model.addVar(vtype=GRB.INTEGER, name=\"cows\")\n    sheep = model.addVar(vtype=GRB.INTEGER, name=\"sheep\")\n    chickens = model.addVar(vtype=GRB.INTEGER, name=\"chickens\")\n\n    # Objective function\n    profit_cow = cow_price - cow_feed_cost\n    profit_sheep = sheep_price - sheep_feed_cost\n    profit_chicken = chicken_price - chicken_feed_cost\n\n    model.setObjective(profit_cow * cows + profit_sheep * sheep +\n                       profit_chicken * chickens,\n                       sense=GRB.MAXIMIZE)\n\n    # Constraints\n    model.addConstr(10 * cows + 5 * sheep + 3 * chickens <= max_manure,\n                    \"Manure_Capacity\")\n    model.addConstr(chickens <= max_chickens, \"Max_Chickens\")\n    model.addConstr(cows >= min_cows, \"Min_Cows\")\n    model.addConstr(sheep >= min_sheep, \"Min_Sheep\")\n    model.addConstr(cows + sheep + chickens <= max_total_animals,\n                    \"Total_Animals\")\n\n    # Optimize\n    model.optimize()\n\n    if model.status == GRB.OPTIMAL:\n        return model.ObjVal\n    else:\n        status_map = {\n            GRB.INFEASIBLE: \"Model is infeasible.\",\n            GRB.UNBOUNDED: \"Model is unbounded.\",\n            GRB.SUBOPTIMAL: \"Suboptimal solution found.\",\n            GRB.TIME_LIMIT: \"Optimization stopped due to time limit.\",\n            GRB.INTERRUPTED: \"Optimization interrupted.\"\n        }\n        return status_map.get(model.status,\n                              f\"Unknown status code {model.status}\")\nif __name__ == \"__main__\":\n    result = farmer_optimization()\n    print(f\"Optimal profit: {result}\")",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B005",
  "description": "The contract reservations for the next year for products I, II, and III of a certain factory in each quarter are shown in Table 1-10.\n\nTable 1-10\n| Product | 1    | 2    | 3    | 4    |\n|---------|------|------|------|------|\n| I       | 1500 | 1000 | 2000 | 1200 |\n| II      | 1500 | 1500 | 1200 | 1500 |\n| III     | 1000 | 2000 | 1500 | 2500 |\n\nAt the beginning of the first quarter, there is no inventory for these three products, and it is required to have 150 units in stock for each product by the end of the fourth quarter. It is known that the factory has 15,000 production hours per quarter, and each unit of products I, II, and III requires 2, 4, and 3 hours respectively. Due to a change in equipment, product I cannot be produced in the second quarter. It is stipulated that if the products cannot be delivered on time, a compensation of 20 yuan per unit per quarter delay is required for products I and II, while for product III, the compensation is 10 yuan. Additionally, for products produced but not delivered in the current quarter, the inventory cost is 5 yuan per unit per quarter. How should the factory schedule production to minimize the total cost of compensation and inventory?",
  "ground_truth": 10755.0,
  "formulation": null,
  "correct_program": "from gurobipy import Model, GRB, quicksum\n\n\ndef solve_factory_scheduling():\n    # --- 模型初始化 ---\n    model = Model(\"FactoryProductionScheduling\")\n\n    # --- 集合定义 ---\n    products = [\"I\", \"II\", \"III\"]\n    quarters = list(range(4))  # 0: Q1, 1: Q2, 2: Q3, 3: Q4\n\n    # --- 参数定义 ---\n    demand = {\n        (\"I\", 0): 1500,\n        (\"I\", 1): 1000,\n        (\"I\", 2): 2000,\n        (\"I\", 3): 1200,\n        (\"II\", 0): 1500,\n        (\"II\", 1): 1500,\n        (\"II\", 2): 1200,\n        (\"II\", 3): 1500,\n        (\"III\", 0): 1000,\n        (\"III\", 1): 2000,\n        (\"III\", 2): 1500,\n        (\"III\", 3): 2500,\n    }\n\n    initial_inventory = {prod: 0 for prod in products}  # 期初库存\n    ending_inventory_target = {prod: 150 for prod in products}  # 第四季度末库存目标\n\n    production_hours_per_quarter = 15000  # 每季度可用生产工时\n\n    hours_per_unit = {  # 每单位产品所需工时\n        \"I\": 2,\n        \"II\": 4,\n        \"III\": 3,\n    }\n\n    # 产品I在第二季度 (索引1) 不能生产\n    production_restriction_product = \"I\"\n    production_restriction_quarter = 1\n\n    backlog_cost_per_unit_per_quarter = { # 单位产品每季度延期赔偿\n        \"I\": 20,\n        \"II\": 20,\n        \"III\": 10,\n    }\n\n    inventory_cost_per_unit_per_quarter = 5  # 单位产品每季度库存成本\n\n    # --- 决策变量 ---\n    # P[p, q]: 在季度q生产产品p的数量\n    P = model.addVars(products,\n                      quarters,\n                      name=\"Production\",\n                    #   vtype=GRB.CONTINUOUS,\n                      vtype=GRB.INTEGER,\n                      lb=0)\n    # I[p, q]: 在季度q末产品p的库存量\n    I = model.addVars(products,\n                      quarters,\n                      name=\"Inventory\",\n                    #   vtype=GRB.CONTINUOUS,\n                      vtype=GRB.INTEGER,\n                      lb=0)\n    # B[p, q]: 在季度q末产品p的积压订单量\n    B = model.addVars(products,\n                      quarters,\n                      name=\"Backlog\",\n                    #   vtype=GRB.CONTINUOUS,\n                      vtype=GRB.INTEGER,\n                      lb=0)\n\n    # --- 目标函数: 最小化总成本 (赔偿成本 + 库存成本) ---\n    total_backlog_cost = quicksum(\n        B[p, q] * backlog_cost_per_unit_per_quarter[p] for p in products\n        for q in quarters)\n    total_inventory_cost = quicksum(\n        I[p, q] * inventory_cost_per_unit_per_quarter for p in products\n        for q in quarters)\n\n    model.setObjective(total_backlog_cost + total_inventory_cost, GRB.MINIMIZE)\n\n    # --- 约束条件 ---\n    for q in quarters:\n        # 1. 生产能力约束 (每季度总工时)\n        model.addConstr(quicksum(P[p, q] * hours_per_unit[p] for p in products)\n                        <= production_hours_per_quarter,\n                        name=f\"Capacity_Q{q+1}\")\n\n        for p in products:\n            # 2. 库存平衡约束\n            # 期初库存 (I_prev) + 本期生产 (P) - 本期需求 (D) = 期末库存 (I_curr) - 期末积压 (B_curr)\n            # I_prev - B_prev + P = D + I_curr - B_curr (如果B代表的是净效应)\n            # 我们使用: I[p,q-1] + P[p,q] - Demand[p,q] = I[p,q] - B[p,q]\n            # 这意味着 I[p,q] 和 B[p,q] 中至少一个为0 (或模型会趋向于此以最小化成本)\n\n            inventory_at_start_of_quarter = I[\n                p, q - 1] if q > 0 else initial_inventory[p]\n            # 积压订单是上期末的，本期需要优先满足\n            # 修正库存平衡方程：\n            # (上期末库存 - 上期末积压) + 本期生产 - 本期需求 = (本期末库存 - 本期末积压)\n            # I[p, q-1] - B[p, q-1] + P[p,q] - D[p,q] = I[p,q] - B[p,q]\n            # 整理为： I[p,q-1] + P[p,q] + B[p,q] = D[p,q] + I[p,q] + B[p,q-1]\n            # 这个形式更标准，表示 (可供量) + (新欠货) = (需求) + (结转库存) + (已满足的旧欠货或继续欠)\n\n            backlog_at_start_of_quarter = B[p, q - 1] if q > 0 else 0  # 初始无积压\n\n            model.addConstr(inventory_at_start_of_quarter + P[p, q] +\n                            B[p, q] == demand[p, q] + I[p, q] +\n                            backlog_at_start_of_quarter,\n                            name=f\"InventoryBalance_{p}_Q{q+1}\")\n\n    # 3. 特定生产限制: 产品I在第二季度 (索引1) 不能生产\n    model.addConstr(\n        P[production_restriction_product, production_restriction_quarter] == 0,\n        name=\n        f\"NoProduction_{production_restriction_product}_Q{production_restriction_quarter+1}\"\n    )\n\n    # 4. 期末库存要求: 第四季度末 (索引3)\n    for p in products:\n        model.addConstr(I[p, quarters[-1]] >= ending_inventory_target[p],\n                        name=f\"EndingInventory_{p}\")\n        # 确保第四季度末没有积压订单，虽然目标函数会尝试最小化积压，但这里可以明确要求\n        # 如果允许第四季度末有积压，则不需要此约束。题目未明确禁止，但通常目标是清零。\n        # 考虑到有期末库存目标，清零积压是合理的。\n        model.addConstr(B[p, quarters[-1]] == 0, name=f\"EndingBacklogZero_{p}\")\n\n    # --- 模型求解 ---\n    model.optimize()\n\n    # --- 打印结果 ---\n    if model.status == GRB.OPTIMAL:\n        print(f\"\\n找到最优生产计划! 最小总成本: {model.objVal:,.2f} 元\")\n        print(\"-\" * 100)\n        print(\n            f\"{'产品':<5} | {'季度':<5} | {'生产量':>10} | {'期末库存':>10} | {'期末积压':>10} | {'需求量':>10}\"\n        )\n        print(\"=\" * 100)\n        for q in quarters:\n            for p in products:\n                print(\n                    f\"{p:<5} | {q+1:<5} | {P[p,q].X:>10.1f} | {I[p,q].X:>10.1f} | {B[p,q].X:>10.1f} | {demand[p,q]:>10}\"\n                )\n            print(\"-\" * 100)\n\n        print(\"\\n成本构成:\")\n        calc_total_backlog_cost = sum(\n            B[p, q].X * backlog_cost_per_unit_per_quarter[p] for p in products\n            for q in quarters)\n        calc_total_inventory_cost = sum(\n            I[p, q].X * inventory_cost_per_unit_per_quarter for p in products\n            for q in quarters)\n        print(f\"  总延期赔偿成本: {calc_total_backlog_cost:,.2f} 元\")\n        print(f\"  总库存持有成本: {calc_total_inventory_cost:,.2f} 元\")\n        print(\n            f\"  计算得到的总成本: {calc_total_backlog_cost + calc_total_inventory_cost:,.2f} 元\"\n        )\n\n    elif model.status == GRB.INFEASIBLE:\n        print(\"模型不可行。请检查约束条件是否相互冲突。\")\n        print(\"正在计算不可行子系统 (IIS) 来帮助定位问题...\")\n        model.computeIIS()\n        model.write(\"factory_scheduling_iis.ilp\")\n        print(\"IIS 已写入 factory_scheduling_iis.ilp 文件。\")\n    elif model.status == GRB.UNBOUNDED:\n        print(\"模型无界。目标函数可以无限减小。\")\n    else:\n        print(f\"优化过程因状态码 {model.status} 而停止。\")\n\n\nif __name__ == '__main__':\n    solve_factory_scheduling()",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B006",
  "description": "An Italian transportation company needs to move some empty containers from its 6 warehouses (located in Verona, Perugia, Rome, Pescara, Taranto, and Lamezia) to major national ports (Genoa, Venice, Ancona, Naples, Bari). The container inventory at the warehouses is as follows:\n\n|  | Empty Containers |\n|:---:|:---:|\n| Verona | 10 |\n| Perugia | 12 |\n| Rome | 20 |\n| Pescara | 24 |\n| Taranto | 18 |\n| Lamezia | 40 |\n\nThe demand at the ports is as follows:\n\n|  | Container Demand |\n|:---:|:---:|\n| Genoa | 20 |\n| Venice | 15 |\n| Ancona | 25 |\n| Naples | 33 |\n| Bari | 21 |\n\nThe transport is carried out by a fleet of trucks. The cost to transport each container is proportional to the distance traveled by the trucks, with a rate of 30 euros per kilometer. Each truck can carry up to 2 containers. The distances are as follows:\n\n|  | Genoa | Venice | Ancona | Naples | Bari |\n|:---:|:---:|:---:|:---:|:---:|:---:|\n| Verona | $290 \\mathrm{~km}$ | $115 \\mathrm{~km}$ | $355 \\mathrm{~km}$ | $715 \\mathrm{~km}$ | $810 \\mathrm{~km}$ |\n| Perugia | $380 \\mathrm{~km}$ | $340 \\mathrm{~km}$ | $165 \\mathrm{~km}$ | $380 \\mathrm{~km}$ | $610 \\mathrm{~km}$ |\n| Rome | $505 \\mathrm{~km}$ | $530 \\mathrm{~km}$ | $285 \\mathrm{~km}$ | $220 \\mathrm{~km}$ | $450 \\mathrm{~km}$ |\n| Pescara | $655 \\mathrm{~km}$ | $450 \\mathrm{~km}$ | $155 \\mathrm{~km}$ | $240 \\mathrm{~km}$ | $315 \\mathrm{~km}$ |\n| Taranto | $1010 \\mathrm{~km}$ | $840 \\mathrm{~km}$ | $550 \\mathrm{~km}$ | $305 \\mathrm{~km}$ | $95 \\mathrm{~km}$ |\n| Lamezia | $1072 \\mathrm{~km}$ | $1097 \\mathrm{~km}$ | $747 \\mathrm{~km}$ | $372 \\mathrm{~km}$ | $333 \\mathrm{~km}$ |\n\nWrite a mathematical program to find the minimum cost transportation policy and solve it using COPTPY.",
  "ground_truth": 904590.0,
  "formulation": null,
  "correct_program": "def optimize_container_transportation():\n    from gurobipy import Model, GRB\n\n    # Data\n    warehouses = ['Verona', 'Perugia', 'Rome', 'Pescara', 'Taranto', 'Lamezia']\n    ports = ['Genoa', 'Venice', 'Ancona', 'Naples', 'Bari']\n\n    supply = [10, 12, 20, 24, 18, 40]\n    demand = [20, 15, 25, 33, 21]\n\n    # Distances in km\n    distances = [\n        [290, 115, 355, 715, 810],  # Verona\n        [380, 340, 165, 380, 610],  # Perugia\n        [505, 530, 285, 220, 450],  # Rome\n        [655, 450, 155, 240, 315],  # Pescara\n        [1010, 840, 550, 305, 95],  # Taranto\n        [1072, 1097, 747, 372, 333]  # Lamezia\n    ]\n\n    cost_per_km = 30\n\n    # Initialize model\n    m = Model(\"ContainerTransport\")\n\n    # Decision variables\n    x = {}  # containers shipped from warehouse i to port j\n    y = {}  # number of trucks on route i->j\n\n    for i in range(len(warehouses)):\n        for j in range(len(ports)):\n            var_name_x = f\"x_{i}_{j}\"\n            var_name_y = f\"y_{i}_{j}\"\n            x[i, j] = m.addVar(vtype=GRB.INTEGER, lb=0, name=var_name_x)\n            y[i, j] = m.addVar(vtype=GRB.INTEGER, lb=0, name=var_name_y)\n\n    m.update()\n\n    # Objective: minimize total transportation cost\n    total_cost = 0\n    for i in range(len(warehouses)):\n        for j in range(len(ports)):\n            c_ij = cost_per_km * distances[i][j]\n            total_cost += c_ij * x[i, j]\n    m.setObjective(total_cost, GRB.MINIMIZE)\n\n    # Supply constraints\n    for i in range(len(warehouses)):\n        m.addConstr(sum(x[i, j] for j in range(len(ports))) <= supply[i],\n                    name=f\"Supply_{i}\")\n\n    # Demand constraints\n    for j in range(len(ports)):\n        m.addConstr(sum(x[i, j] for i in range(len(warehouses))) >= demand[j],\n                    name=f\"Demand_{j}\")\n\n    # Truck capacity constraints\n    for i in range(len(warehouses)):\n        for j in range(len(ports)):\n            m.addConstr(x[i, j] <= 2 * y[i, j], name=f\"TruckCap_{i}_{j}\")\n\n    # Optimize\n    m.optimize()\n\n    # Check feasibility and return result\n    if m.status == GRB.OPTIMAL:\n        return m.objVal\n    else:\n        return None\n\nif __name__ == \"__main__\":\n    result = optimize_container_transportation()\n    if result is not None:\n        print(f\"Optimal transportation cost: {result}\")\n    else:\n        print(\"No feasible solution found.\")",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B007",
  "description": "Now, we need to determine 4 out of 5 workers to complete one of the four tasks respectively. Due to each worker's different technical specialties, the time required for them to complete each task varies. The hours required by each worker to complete each task are shown in Table 5-2.\n\nTable 5-2\n| Worker | $A$ | $B$ | $C$ | $D$ |\n|--------|-----|-----|-----|-----|\n| I      | 9   | 4   | 3   | 7   |\n| II     | 4   | 6   | 5   | 6   |\n| III    | 5   | 4   | 7   | 5   |\n| IV     | 7   | 5   | 2   | 3   |\n| V      | 10  | 6   | 7   | 4   |\n\nTry to find a job assignment plan that minimizes the total working hours.",
  "ground_truth": 14.0,
  "formulation": null,
  "correct_program": "def optimize_worker_task_assignment():\n    from gurobipy import Model, GRB\n\n    # Data: hours required for each worker-task pair\n    hours = {\n        ('I', 'A'): 9,\n        ('I', 'B'): 4,\n        ('I', 'C'): 3,\n        ('I', 'D'): 7,\n        ('II', 'A'): 4,\n        ('II', 'B'): 6,\n        ('II', 'C'): 5,\n        ('II', 'D'): 6,\n        ('III', 'A'): 5,\n        ('III', 'B'): 4,\n        ('III', 'C'): 7,\n        ('III', 'D'): 5,\n        ('IV', 'A'): 7,\n        ('IV', 'B'): 5,\n        ('IV', 'C'): 2,\n        ('IV', 'D'): 3,\n        ('V', 'A'): 10,\n        ('V', 'B'): 6,\n        ('V', 'C'): 7,\n        ('V', 'D'): 4\n    }\n\n    workers = ['I', 'II', 'III', 'IV', 'V']\n    tasks = ['A', 'B', 'C', 'D']\n\n    # Create model\n    m = Model(\"WorkerTaskAssignment\")\n    m.setParam('OutputFlag', 0)  # Suppress output\n\n    # Decision variables: x_{i,j}\n    x = m.addVars(workers, tasks, vtype=GRB.BINARY, name='x')\n    # Worker selection variables: y_i\n    y = m.addVars(workers, vtype=GRB.BINARY, name='y')\n\n    # Objective: minimize total hours\n    m.setObjective(\n        sum(hours[(i, j)] * x[i, j] for i in workers for j in tasks),\n        GRB.MINIMIZE)\n\n    # Constraints:\n\n    # Each task assigned to exactly one worker\n    for j in tasks:\n        m.addConstr(sum(x[i, j] for i in workers) == 1,\n                    name=f\"Task_{j}_assignment\")\n\n    # Worker assignment constraints\n    for i in workers:\n        m.addConstr(sum(x[i, j] for j in tasks) <= y[i],\n                    name=f\"Worker_{i}_assignment_limit\")\n\n    # Exactly 4 workers are selected\n    m.addConstr(sum(y[i] for i in workers) == 4, name=\"Select_4_workers\")\n\n    # Linking constraints: worker assigned only if selected\n    for i in workers:\n        for j in tasks:\n            m.addConstr(x[i, j] <= y[i], name=f\"Link_{i}_{j}\")\n\n    # Optimize\n    m.optimize()\n\n    # Check feasibility and return optimal value\n    if m.status == GRB.OPTIMAL:\n        return m.objVal\n    else:\n        return None\n\nif __name__ == \"__main__\":\n    result = optimize_worker_task_assignment()\n    if result is not None:\n        print(f\"Optimal total hours: {result}\")\n    else:\n        print(\"No feasible solution found.\")",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B008",
  "description": "Haus Toys can manufacture and sell toy trucks, toy airplanes, toy boats, and toy trains. The profit for each truck sold is $5, each airplane $10, each boat $8, and each train $7. How many types of toys should Haus Toys manufacture to maximize profits?\n\nThere are 890 units of wood available. Each truck requires 12 units, each airplane 20 units, each boat 15 units, and each train 10 units.\n\nThere are 500 units of steel available. Each airplane requires 3 units, each boat 5 units, each train 4 units, and each truck 6 units.\n\nIf Haus Toys manufactures trucks, they will not manufacture trains.\n\nHowever, if they manufacture boats, they will also manufacture airplanes.\n\nThe number of toy boats manufactured cannot exceed the number of toy trains manufactured.",
  "ground_truth": 623.0,
  "formulation": null,
  "correct_program": "def optimize_toy_production(\n        wood_available=890,\n        steel_available=500,\n        profit_truck=5,\n        profit_airplane=10,\n        profit_boat=8,\n        profit_train=7,\n        M=1000  # Big-M value\n):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create model\n    model = gp.Model(\"HausToysOptimization\")\n    model.setParam('OutputFlag', 0)  # Silence output\n\n    # Decision variables\n    T = model.addVar(vtype=GRB.INTEGER, name=\"T\")  # Trucks\n    A = model.addVar(vtype=GRB.INTEGER, name=\"A\")  # Airplanes\n    B = model.addVar(vtype=GRB.INTEGER, name=\"B\")  # Boats\n    R = model.addVar(vtype=GRB.INTEGER, name=\"R\")  # Trains\n\n    # Binary variables for logical conditions\n    y_T = model.addVar(vtype=GRB.BINARY, name=\"y_T\")\n    y_R = model.addVar(vtype=GRB.BINARY, name=\"y_R\")\n    y_B = model.addVar(vtype=GRB.BINARY, name=\"y_B\")\n\n    # Objective: maximize profit\n    model.setObjective(\n        profit_truck * T + profit_airplane * A + profit_boat * B +\n        profit_train * R, GRB.MAXIMIZE)\n\n    # Resource constraints\n    model.addConstr(12 * T + 20 * A + 15 * B + 10 * R <= wood_available,\n                    \"Wood\")\n    model.addConstr(6 * T + 3 * A + 5 * B + 4 * R <= steel_available, \"Steel\")\n\n    # Boats cannot exceed trains\n    model.addConstr(B <= R, \"BoatTrainLimit\")\n\n    # Logical constraints for trucks and trains (mutual exclusivity)\n    model.addConstr(T <= M * y_T, \"TruckLogical\")\n    model.addConstr(R <= M * y_R, \"TrainLogical\")\n    model.addConstr(y_T + y_R <= 1, \"MutualExclusion\")\n\n    # Logical constraints for boats and airplanes\n    model.addConstr(A >= y_B, \"AirplaneBoat\")\n    model.addConstr(B <= y_B * M, \"BoatBinary\")\n\n    # Optional: enforce non-negativity (default in Gurobi)\n    # Variables are already non-negative by default unless specified otherwise\n\n    # Optimize\n    model.optimize()\n\n    # Check feasibility\n    if model.status == GRB.OPTIMAL:\n        return model.objVal\n    else:\n        return None\nif __name__ == \"__main__\":\n    result = optimize_toy_production()\n    print(f\"Optimal profit: {result}\")",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B009",
  "description": "A convenience supermarket is planning to open several chain stores in a newly built residential area in the northwest suburb of the city. For shopping convenience, the distance from any residential area to one of the chain stores should not exceed $800 \\mathrm{~m}$. Table 5-1 shows the new residential areas and the residential areas within a radius of $800 \\mathrm{~m}$ from each of them. Question: What is the minimum number of chain stores the supermarket needs to build among the mentioned residential areas, and in which residential areas should they be built?\n\n| Area Code | Residential Areas within $800 \\mathrm{~m}$ Radius |\n|-----------|---------------------------------------------------|\n| A         | A, C, E, G, H, I                                  |\n| B         | B, H, I                                           |\n| C         | A, C, G, H, I                                     |\n| D         | D, J                                              |\n| E         | A, E, G                                           |\n| F         | F, J, K                                           |\n| G         | A, C, E, G                                        |\n| H         | A, B, C, H, I                                     |\n| I         | A, B, C, H, I                                     |\n| J         | D, F, J, K, L                                     |\n| K         | F, J, K, L                                        |\n| L         | J, K, L                                           |",
  "ground_truth": 3.0,
  "formulation": null,
  "correct_program": "from gurobipy import Model, GRB, quicksum\n\n\ndef solve_supermarket_location():\n    # --- 模型初始化 ---\n    model = Model(\"SupermarketSetCovering\")\n\n    # --- 集合定义 ---\n    # 住宅区既是潜在的建店地点，也是需要被覆盖的区域\n    locations = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\"]\n    areas_to_cover = locations[:]  # 创建一个副本\n\n    # --- 参数定义 ---\n    # coverage_data[loc] 是一个列表，包含地点loc建店可以覆盖的所有区域\n    coverage_data = {\n        \"A\": [\"A\", \"C\", \"E\", \"G\", \"H\", \"I\"],\n        \"B\": [\"B\", \"H\", \"I\"],\n        \"C\": [\"A\", \"C\", \"G\", \"H\", \"I\"],\n        \"D\": [\"D\", \"J\"],\n        \"E\": [\"A\", \"E\", \"G\"],\n        \"F\": [\"F\", \"J\", \"K\"],\n        \"G\": [\"A\", \"C\", \"E\", \"G\"],\n        \"H\": [\"A\", \"B\", \"C\", \"H\", \"I\"],\n        \"I\": [\"A\", \"B\", \"C\", \"H\", \"I\"],\n        \"J\": [\"D\", \"F\", \"J\", \"K\", \"L\"],\n        \"K\": [\"F\", \"J\", \"K\", \"L\"],\n        \"L\": [\"J\", \"K\", \"L\"],\n    }\n\n    # --- 决策变量 ---\n    # build[loc]: 是否在地点loc建店 (1=是, 0=否)\n    build = model.addVars(locations, name=\"BuildStore\", vtype=GRB.BINARY)\n\n    # --- 目标函数: 最小化建店数量 ---\n    model.setObjective(quicksum(build[loc] for loc in locations), GRB.MINIMIZE)\n\n    # --- 约束条件: 每个区域至少被一个店覆盖 ---\n    for area in areas_to_cover:\n        # 找出哪些潜在店址可以覆盖当前区域 area\n        covering_locations = []\n        for loc_candidate in locations:\n            if area in coverage_data[loc_candidate]:\n                covering_locations.append(loc_candidate)\n\n        # 添加约束: sum(build[loc] for loc in covering_locations) >= 1\n        if covering_locations:  # 确保列表不为空，尽管在此问题中每个区域都至少能被自己覆盖\n            model.addConstr(quicksum(build[loc] for loc in covering_locations)\n                            >= 1,\n                            name=f\"CoverArea_{area}\")\n        else:\n            print(f\"警告: 区域 {area} 无法被任何潜在店址覆盖。请检查数据。\")\n\n    # --- 模型求解 ---\n    model.optimize()\n\n    # --- 打印结果 ---\n    if model.status == GRB.OPTIMAL:\n        print(f\"\\n找到最优选址方案! 最少建店数量: {model.objVal:.0f}\")\n        print(\"建店地点:\")\n        for loc in locations:\n            if build[loc].X > 0.5:  # 检查二元变量是否为1\n                print(f\"  - 在区域 {loc} 建店\")\n\n        print(\"\\n各区域覆盖情况:\")\n        for area in areas_to_cover:\n            covered_by_stores = []\n            for loc in locations:\n                if build[loc].X > 0.5 and area in coverage_data[loc]:\n                    covered_by_stores.append(loc)\n            print(\n                f\"  区域 {area} 被以下店址覆盖: {', '.join(covered_by_stores) if covered_by_stores else '未被覆盖 (错误!)'}\"\n            )\n\n    elif model.status == GRB.INFEASIBLE:\n        print(\"模型不可行。请检查约束条件或覆盖数据。\")\n        print(\"可能原因：某个区域无法被任何潜在店址覆盖。\")\n    elif model.status == GRB.UNBOUNDED:\n        print(\"模型无界。(在此问题中不应发生)\")\n    else:\n        print(f\"优化过程因状态码 {model.status} 而停止。\")\n\n\nif __name__ == '__main__':\n    solve_supermarket_location()",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B012",
  "description": "Tom and Jerry just bought a farm in Sunshine Valley, and they are considering using it to plant corn, wheat, soybeans, and sorghum. The profit per acre for planting corn is $1500, the profit per acre for planting wheat is $1200, the profit per acre for planting soybeans is $1800, and the profit per acre for planting sorghum is $1600. To maximize their profit, how many acres of land should they allocate to each crop? Tom and Jerry’s farm has a total area of 100 acres.\n\nThe land area used for planting corn must be at least twice the land area used for planting wheat.\n\nThe land area used for planting soybeans must be at least half the land area used for planting sorghum.\n\nThe land area used for planting wheat must be three times the land area used for planting sorghum.",
  "ground_truth": 180000.0,
  "formulation": null,
  "correct_program": "def optimize_crop_allocation(total_land=100,\n                             profit_c=1500,\n                             profit_w=1200,\n                             profit_s=1800,\n                             profit_so=1600):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"Crop_Profit_Maximization\")\n\n    # Decision variables\n    x_c = model.addVar(name=\"corn\", lb=0)\n    x_w = model.addVar(name=\"wheat\", lb=0)\n    x_s = model.addVar(name=\"soybeans\", lb=0)\n    x_so = model.addVar(name=\"sorghum\", lb=0)\n\n    # Set objective: maximize profit\n    model.setObjective(\n        profit_c * x_c + profit_w * x_w + profit_s * x_s + profit_so * x_so,\n        GRB.MAXIMIZE)\n\n    # Add constraints\n    # Total land constraint\n    model.addConstr(x_c + x_w + x_s + x_so <= total_land, \"TotalLand\")\n    # Wheat equals three times sorghum\n    model.addConstr(x_w == 3 * x_so, \"WheatSorghumRatio\")\n    # Corn at least twice wheat\n    model.addConstr(x_c >= 2 * x_w, \"CornWheatRatio\")\n    # Soybeans at least half sorghum\n    model.addConstr(x_s >= 0.5 * x_so, \"SoySorghumRatio\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the total profit of the optimal solution\n        return model.objVal\n    else:\n        # No feasible solution found\n        return None\nif __name__ == \"__main__\":\n    result = optimize_crop_allocation()\n    if result is not None:\n        print(f\"Optimal total profit: {result}\")\n    else:\n        print(\"No feasible solution found.\")",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B015",
  "description": "A store plans to formulate the purchasing and sales plan for a certain product for the first quarter of next year. It is known that the warehouse capacity of the store can store up to 500 units of the product, and there are 200 units in stock at the end of this year. The store purchases goods once at the beginning of each month. The purchasing and selling prices of the product in each month are shown in Table 1.3.\n\nTable 1.3\n\n| Month | 1 | 2 | 3 |\n| :---: | :---: | :---: | :---: |\n| Purchasing Price (Yuan) | 8 | 6 | 9 |\n| Selling Price (Yuan) | 9 | 8 | 10 |\n\nNow, determine how many units should be purchased and sold each month to maximize the total profit, and express this problem as a linear programming model.",
  "ground_truth": 4100.0,
  "formulation": null,
  "correct_program": "from gurobipy import Model, GRB\n\n# 创建模型\nmodel = Model(\"Procurement_and_Sales_Plan\")\n\n# 数据输入\npurchase_prices = [8, 6, 9]\nsell_prices = [9, 8, 10]\nmonths = range(3)  # 0-based index for months 1, 2, 3\n\n# 变量定义\nx = model.addVars(months, vtype=GRB.INTEGER, name=\"Purchase\", lb=0)  # 采购量\ny = model.addVars(months, vtype=GRB.INTEGER, name=\"Sell\", lb=0)  # 销售量\ns = model.addVars(months, vtype=GRB.INTEGER, name=\"Inventory\", lb=0)  # 库存量\n\n# 初始库存\ninitial_inventory = 200\n\n# 添加库存约束\nfor t in months:\n    if t == 0:\n        prev_inventory = initial_inventory\n    else:\n        prev_inventory = s[t - 1]\n\n    # 库存平衡方程\n    model.addConstr(s[t] == prev_inventory + x[t] - y[t],\n                    name=f\"Inventory_Balance_{t+1}\")\n\n    # 库存不超过容量\n    model.addConstr(s[t] <= 500, name=f\"Inventory_Capacity_{t+1}\")\n    model.addConstr(prev_inventory + x[t] <= 500, name=f\"Inventory_Capacity2_{t+1}\")\n\n    # 销售不能超过当前库存\n    model.addConstr(y[t] <= prev_inventory + x[t], name=f\"Sales_Limit_{t+1}\")\n\n# 目标函数：最大化利润\nprofit = sum(\n    (sell_prices[t] * y[t] - purchase_prices[t] * x[t]) for t in months)\nmodel.setObjective(profit, GRB.MAXIMIZE)\n\n# 求解\nmodel.optimize()\n\n# 输出结果\nif model.status == GRB.OPTIMAL:\n    print(\"\\nOptimal solution found:\")\n    for t in months:\n        print(\n            f\"Month {t+1}: \"\n            f\"Purchased = {x[t].X:.0f}, Sold = {y[t].X:.0f}, Inventory = {s[t].X:.0f}\"\n        )\n    print(f\"\\nTotal Profit = {model.objVal:.2f} yuan\")\nelse:\n    print(\"No optimal solution found.\")",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B016",
  "description": "Certain strategic bomber groups are tasked with destroying enemy military targets. It is known that the target has four key parts, and destroying any one of them will suffice. The fuel consumption limit for completing this task is 48,000 liters, with a maximum of 48 heavy bombs and 32 light bombs. When carrying heavy bombs, each liter of fuel allows a distance of 2 km, whereas with light bombs, each liter allows 3 km. Additionally, each aircraft can only carry one bomb per trip, and each bombing run requires fuel not only for the round trip (each liter of fuel allows 4 km when the aircraft is empty) but also 100 liters for both takeoff and landing per trip. Relevant data is shown in Table 1-17.\n\nTable 1-17\n| Key Part | Distance from Airport (km) | Probability of Destruction per Heavy Bomb | Probability of Destruction per Light Bomb |\n|----------|----------------------------|-----------------------------------------|------------------------------------------|\n|          |                            |                                         |                                          |\n| 1        | 450                        | 0.10                                    | 0.08                                     |\n| 2        | 480                        | 0.20                                    | 0.16                                     |\n| 3        | 540                        | 0.15                                    | 0.12                                     |\n| 4        | 600                        | 0.25                                    | 0.20                                     |\n\nTo maximize the probability of destroying the enemy military target, how should the bombing plan be determined? Establish a linear programming model for this problem.",
  "ground_truth": 0.9999999992023356,
  "formulation": null,
  "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\nimport math\n\n\ndef solve_bomber_problem():\n    try:\n        # --- Problem Data ---\n        # Key Part | Distance (km) | P(Destroy | Heavy) | P(Destroy | Light)\n        # 1        | 450           | 0.10             | 0.08\n        # 2        | 480           | 0.20             | 0.16\n        # 3        | 540           | 0.15             | 0.12\n        # 4        | 600           | 0.25             | 0.20\n\n        num_parts = 4\n        parts = range(num_parts)\n\n        distances = [450, 480, 540, 600]  # km\n        prob_destroy_heavy = [0.10, 0.20, 0.15, 0.25]\n        prob_destroy_light = [0.08, 0.16, 0.12, 0.20]\n\n        # Resource Limits\n        max_fuel = 48000  # liters\n        max_heavy_bombs = 48\n        max_light_bombs = 32\n\n        # Fuel Consumption Parameters\n        eff_heavy_loaded = 2.0  # km/liter\n        eff_light_loaded = 3.0  # km/liter\n        eff_empty_return = 4.0  # km/liter (return trip)\n        fuel_takeoff_landing = 100  # liters per trip\n\n        # --- Pre-calculations ---\n\n        # Fuel per trip for each bomb type to each part\n        fuel_per_heavy_trip = []\n        for d in distances:\n            # Fuel to target (loaded) + Fuel return (empty) + Takeoff/Landing\n            fuel = (d / eff_heavy_loaded) + (\n                d / eff_empty_return) + fuel_takeoff_landing\n            fuel_per_heavy_trip.append(fuel)\n\n        fuel_per_light_trip = []\n        for d in distances:\n            # Fuel to target (loaded) + Fuel return (empty) + Takeoff/Landing\n            fuel = (d / eff_light_loaded) + (\n                d / eff_empty_return) + fuel_takeoff_landing\n            fuel_per_light_trip.append(fuel)\n\n        # Objective function coefficients: log(P(not destroyed by one bomb))\n        # log(1 - p) will be negative. We want to minimize this sum.\n        log_prob_not_destroy_heavy = []\n        for p in prob_destroy_heavy:\n            if p < 1.0:  # Ensure p is not 1 to avoid log(0)\n                log_prob_not_destroy_heavy.append(math.log(1 - p))\n            else:  # Should not happen with given data, but good for robustness\n                log_prob_not_destroy_heavy.append(\n                    -float('inf'))  # Effectively forces use if possible\n\n        log_prob_not_destroy_light = []\n        for p in prob_destroy_light:\n            if p < 1.0:\n                log_prob_not_destroy_light.append(math.log(1 - p))\n            else:\n                log_prob_not_destroy_light.append(-float('inf'))\n\n        # --- Model Creation ---\n        model = gp.Model(\"StrategicBomberPlanning\")\n\n        # --- Decision Variables ---\n        # x_h[i]: number of heavy bombs assigned to part i\n        x_h = model.addVars(num_parts,\n                            vtype=GRB.INTEGER,\n                            name=\"HeavyBombs\",\n                            lb=0)\n        # x_l[i]: number of light bombs assigned to part i\n        x_l = model.addVars(num_parts,\n                            vtype=GRB.INTEGER,\n                            name=\"LightBombs\",\n                            lb=0)\n\n        # --- Objective Function ---\n        # Minimize the sum of log probabilities of NOT destroying each part\n        # This is equivalent to maximizing the probability of destroying at least one part\n        objective = gp.quicksum(log_prob_not_destroy_heavy[i] * x_h[i] for i in parts) + \\\n                    gp.quicksum(log_prob_not_destroy_light[i] * x_l[i] for i in parts)\n        model.setObjective(objective, GRB.MINIMIZE)\n\n        # --- Constraints ---\n\n        # 1. Total heavy bombs constraint\n        model.addConstr(\n            gp.quicksum(x_h[i] for i in parts) <= max_heavy_bombs,\n            \"MaxHeavyBombs\")\n\n        # 2. Total light bombs constraint\n        model.addConstr(\n            gp.quicksum(x_l[i] for i in parts) <= max_light_bombs,\n            \"MaxLightBombs\")\n\n        # 3. Total fuel consumption constraint\n        total_fuel_consumed = gp.quicksum(fuel_per_heavy_trip[i] * x_h[i] for i in parts) + \\\n                              gp.quicksum(fuel_per_light_trip[i] * x_l[i] for i in parts)\n        model.addConstr(total_fuel_consumed <= max_fuel, \"MaxFuel\")\n\n        # --- Optimize Model ---\n        model.optimize()\n\n        # --- Results ---\n        print(\"-\" * 30)\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal solution found!\")\n            print(\n                f\"Objective Value (sum of log-probabilities of non-destruction): {model.objVal:.4f}\"\n            )\n\n            # Calculate overall probability of success\n            # P_success = 1 - exp(model.objVal) because model.objVal = ln(Q_total)\n            prob_success = 1 - math.exp(model.objVal)\n            print(\n                f\"Maximized Probability of Destroying at least one Target: {prob_success:.4%}\"\n            )\n            print(\"-\" * 30)\n\n            print(\"Bombing Plan:\")\n            total_h_bombs_used = 0\n            total_l_bombs_used = 0\n            actual_fuel_consumed = 0\n\n            for i in parts:\n                num_h = x_h[i].X\n                num_l = x_l[i].X\n                if num_h > 0.5 or num_l > 0.5:  # Check if any bombs assigned (due to float results)\n                    print(f\"  Key Part {i+1}:\")\n                    print(f\"    Heavy Bombs: {num_h:.0f}\")\n                    print(f\"    Light Bombs: {num_l:.0f}\")\n                total_h_bombs_used += num_h\n                total_l_bombs_used += num_l\n                actual_fuel_consumed += num_h * fuel_per_heavy_trip[\n                    i] + num_l * fuel_per_light_trip[i]\n\n            print(\"-\" * 30)\n            print(\"Resource Utilization:\")\n            print(\n                f\"  Total Heavy Bombs Used: {total_h_bombs_used:.0f} / {max_heavy_bombs}\"\n            )\n            print(\n                f\"  Total Light Bombs Used: {total_l_bombs_used:.0f} / {max_light_bombs}\"\n            )\n            print(\n                f\"  Total Fuel Consumed: {actual_fuel_consumed:.2f} / {max_fuel} liters\"\n            )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\n                \"Model is infeasible. No solution exists under the given constraints.\"\n            )\n        elif model.status == GRB.UNBOUNDED:\n            print(\"Model is unbounded.\")\n        else:\n            print(f\"Optimization was stopped with status {model.status}\")\n\n    except gp.GurobiError as e:\n        print(f\"Error code {e.errno}: {e}\")\n    except AttributeError:\n        print(\n            \"Gurobi or one of its components is not available. Make sure Gurobi is installed and licensed.\"\n        )\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == \"__main__\":\n    solve_bomber_problem()",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B018",
  "description": "A furniture store can choose to order chairs from three different manufacturers: A, B, and C. The cost of ordering each chair from manufacturer A is $50, from manufacturer B is $45, and from manufacturer C is $40. The store needs to minimize the total cost of the order.\n\nAdditionally, each order from manufacturer A will include 15 chairs, while each order from manufacturers B and C will include 10 chairs. The number of orders must be an integer. The store needs to order at least 100 chairs.\n\nEach order from manufacturer A will include 15 chairs, while each order from manufacturers B and C will include 10 chairs. The store needs to order at most 500 chairs.\n\nIf the store decides to order chairs from manufacturer A, it must also order at least 10 chairs from manufacturer B.\n\nFurthermore, if the store decides to order chairs from manufacturer B, it must also order chairs from manufacturer C.",
  "ground_truth": 4000.0,
  "formulation": null,
  "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_furniture_order_problem():\n    try:\n        # --- Problem Data ---\n        # Costs per chair\n        cost_per_chair_A = 50\n        cost_per_chair_B = 45\n        cost_per_chair_C = 40\n\n        # Chairs per order\n        chairs_per_order_A = 15\n        chairs_per_order_B = 10\n        chairs_per_order_C = 10\n\n        # Cost per order\n        cost_per_order_A = cost_per_chair_A * chairs_per_order_A\n        cost_per_order_B = cost_per_chair_B * chairs_per_order_B\n        cost_per_order_C = cost_per_chair_C * chairs_per_order_C\n\n        # Chair limits\n        min_total_chairs = 100\n        max_total_chairs = 500\n\n        # --- Model Creation ---\n        model = gp.Model(\"FurnitureOrderOptimization\")\n\n        # --- Decision Variables ---\n        # Number of orders from each manufacturer (must be integer)\n        orders_A = model.addVar(vtype=GRB.INTEGER, name=\"Orders_A\", lb=0)\n        orders_B = model.addVar(vtype=GRB.INTEGER, name=\"Orders_B\", lb=0)\n        orders_C = model.addVar(vtype=GRB.INTEGER, name=\"Orders_C\", lb=0)\n\n        # Binary variables to indicate if any order is placed with a manufacturer\n        # use_A = 1 if orders_A > 0, 0 otherwise\n        # use_B = 1 if orders_B > 0, 0 otherwise\n        use_A = model.addVar(vtype=GRB.BINARY, name=\"Use_A\")\n        use_B = model.addVar(vtype=GRB.BINARY, name=\"Use_B\")\n        # use_C is not strictly needed for the B->C condition if directly linking orders_C to use_B\n\n        # --- Objective Function ---\n        # Minimize the total cost of ordering\n        total_cost = (orders_A * cost_per_order_A +\n                      orders_B * cost_per_order_B +\n                      orders_C * cost_per_order_C)\n        model.setObjective(total_cost, GRB.MINIMIZE)\n\n        # --- Constraints ---\n\n        # 1. Calculate total number of chairs ordered\n        total_chairs = (orders_A * chairs_per_order_A +\n                        orders_B * chairs_per_order_B +\n                        orders_C * chairs_per_order_C)\n\n        # 2. Total chairs constraints\n        model.addConstr(total_chairs >= min_total_chairs, \"MinTotalChairs\")\n        model.addConstr(total_chairs <= max_total_chairs, \"MaxTotalChairs\")\n\n        # 3. Link binary 'use' variables to the number of orders\n        # If orders_A > 0, then use_A must be 1.\n        # If orders_A = 0, then use_A must be 0.\n        # Gurobi's indicator constraints are suitable here.\n        # (use_A == 1) => (orders_A >= 1)\n        # (use_A == 0) => (orders_A == 0)\n        model.addConstr((use_A == 1) >> (orders_A >= 1), \"Link_use_A_if_one\")\n        model.addConstr((use_A == 0) >> (orders_A == 0), \"Link_use_A_if_zero\")\n\n        # Similarly for use_B and orders_B\n        model.addConstr((use_B == 1) >> (orders_B >= 1), \"Link_use_B_if_one\")\n        model.addConstr((use_B == 0) >> (orders_B == 0), \"Link_use_B_if_zero\")\n\n        # 4. Conditional ordering constraints:\n        # \"If the store decides to order chairs from manufacturer A (orders_A > 0, so use_A = 1),\n        # it must also order at least 10 chairs from manufacturer B (orders_B * 10 >= 10, so orders_B >= 1).\"\n        model.addConstr((use_A == 1) >> (orders_B >= 1),\n                        \"Conditional_A_implies_B\")\n\n        # \"If the store decides to order chairs from manufacturer B (orders_B > 0, so use_B = 1),\n        # it must also order chairs from manufacturer C (orders_C >= 1).\"\n        model.addConstr((use_B == 1) >> (orders_C >= 1),\n                        \"Conditional_B_implies_C\")\n\n        # --- Optimize Model ---\n        model.optimize()\n\n        # --- Results ---\n        print(\"-\" * 40)\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal solution found!\")\n            print(f\"Minimum Total Cost: ${model.objVal:,.2f}\")\n            print(\"-\" * 40)\n            print(\"Order Plan:\")\n            print(f\"  Orders from Manufacturer A: {orders_A.X:.0f}\")\n            print(f\"    Chairs from A: {orders_A.X * chairs_per_order_A:.0f}\")\n            print(f\"  Orders from Manufacturer B: {orders_B.X:.0f}\")\n            print(f\"    Chairs from B: {orders_B.X * chairs_per_order_B:.0f}\")\n            print(f\"  Orders from Manufacturer C: {orders_C.X:.0f}\")\n            print(f\"    Chairs from C: {orders_C.X * chairs_per_order_C:.0f}\")\n            print(\"-\" * 40)\n\n            actual_total_chairs = (orders_A.X * chairs_per_order_A +\n                                   orders_B.X * chairs_per_order_B +\n                                   orders_C.X * chairs_per_order_C)\n            print(f\"Total Chairs Ordered: {actual_total_chairs:.0f}\")\n            print(\"-\" * 40)\n\n            print(\"Status of 'Use' Variables (for verification):\")\n            print(f\"  Use Manufacturer A (use_A): {use_A.X:.0f}\")\n            print(f\"  Use Manufacturer B (use_B): {use_B.X:.0f}\")\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\n                \"Model is infeasible. No solution exists that satisfies all constraints.\"\n            )\n            print(\n                \"Consider reviewing the constraints, especially the conditional ones and chair limits.\"\n            )\n        elif model.status == GRB.UNBOUNDED:\n            print(\n                \"Model is unbounded. This typically means the objective can be improved indefinitely,\"\n            )\n            print(\n                \"which might indicate an issue with constraints or objective direction for minimization.\"\n            )\n        else:\n            print(f\"Optimization was stopped with status: {model.status}\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == \"__main__\":\n    solve_furniture_order_problem()",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B019",
  "description": "Bright Future Toys wants to build and sell robots, model cars, building blocks, and dolls. The profit for each robot sold is $15, for each model car sold is $8, for each set of building blocks sold is $12, and for each doll sold is $5. How many types of toys should Bright Future Toys manufacture to maximize profit?\nThere are 1200 units of plastic available. Each robot requires 30 units of plastic, each model car requires 10 units of plastic, each set of building blocks requires 20 units of plastic, and each doll requires 15 units of plastic.\n\nThere are 800 units of electronic components available. Each robot requires 8 units of electronic components, each model car requires 5 units of electronic components, each set of building blocks requires 3 units of electronic components, and each doll requires 2 units of electronic components.\n\nIf Bright Future Toys manufactures robots, they will not manufacture dolls.\n\nHowever, if they manufacture model cars, they will also manufacture building blocks.\n\nThe number of dolls manufactured cannot exceed the number of model cars manufactured.",
  "ground_truth": 956.0,
  "formulation": null,
  "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_toy_production_problem():\n    try:\n        # --- Problem Data ---\n        toys = [\"robots\", \"cars\", \"blocks\", \"dolls\"]\n        profits = {\"robots\": 15, \"cars\": 8, \"blocks\": 12, \"dolls\": 5}\n\n        # Resource consumption per toy\n        plastic_usage = {\"robots\": 30, \"cars\": 10, \"blocks\": 20, \"dolls\": 15}\n        electronics_usage = {\"robots\": 8, \"cars\": 5, \"blocks\": 3, \"dolls\": 2}\n\n        # Resource availability\n        max_plastic = 1200\n        max_electronics = 800\n\n        # --- Model Creation ---\n        model = gp.Model(\"BrightFutureToys\")\n\n        # --- Decision Variables ---\n        # Quantity of each toy to produce (integer, non-negative)\n        qty = model.addVars(toys, vtype=GRB.INTEGER, name=\"qty\", lb=0)\n\n        # Binary variables to indicate if a type of toy is manufactured\n        # use_toy[t] = 1 if qty[t] > 0, 0 otherwise\n        use_toy = model.addVars(toys, vtype=GRB.BINARY, name=\"use\")\n\n        # --- Objective Function ---\n        # Maximize total profit\n        total_profit = gp.quicksum(profits[t] * qty[t] for t in toys)\n        model.setObjective(total_profit, GRB.MAXIMIZE)\n\n        # --- Constraints ---\n\n        # 1. Resource Constraints\n        # Plastic\n        model.addConstr(\n            gp.quicksum(plastic_usage[t] * qty[t] for t in toys)\n            <= max_plastic, \"PlasticLimit\")\n        # Electronic Components\n        model.addConstr(\n            gp.quicksum(electronics_usage[t] * qty[t] for t in toys)\n            <= max_electronics, \"ElectronicsLimit\")\n\n        # 2. Link binary 'use_toy' variables to 'qty' variables\n        # If qty[t] > 0, then use_toy[t] must be 1.\n        # If qty[t] = 0, then use_toy[t] must be 0.\n        # We can use a \"big M\" approach or indicator constraints. Indicators are cleaner.\n        # A large enough M could be max_plastic / min_plastic_usage_per_toy or similar.\n        # For example, max robots = 1200/30 = 40. max cars = 1200/10 = 120.\n        # Let's use a simpler M for now, or better, indicator constraints.\n        for t in toys:\n            # (use_toy[t] == 1) => (qty[t] >= 1)\n            model.addConstr((use_toy[t] == 1) >> (qty[t] >= 1),\n                            f\"Link_use_{t}_if_one\")\n            # (use_toy[t] == 0) => (qty[t] == 0)\n            model.addConstr((use_toy[t] == 0) >> (qty[t] == 0),\n                            f\"Link_use_{t}_if_zero\")\n\n        # 3. Conditional Production Constraints\n        # \"If Bright Future Toys manufactures robots, they will not manufacture dolls.\"\n        # This means if use_toy[\"robots\"] = 1, then use_toy[\"dolls\"] = 0 (which implies qty[\"dolls\"] = 0).\n        # A simple way to write this: use_toy[\"robots\"] + use_toy[\"dolls\"] <= 1\n        model.addConstr(use_toy[\"robots\"] + use_toy[\"dolls\"] <= 1,\n                        \"Robots_No_Dolls\")\n        # Alternatively, using indicator:\n        # model.addConstr((use_toy[\"robots\"] == 1) >> (qty[\"dolls\"] == 0), \"Robots_No_Dolls_Indicator\")\n\n        # \"However, if they manufacture model cars, they will also manufacture building blocks.\"\n        # This means if use_toy[\"cars\"] = 1, then use_toy[\"blocks\"] = 1 (which implies qty[\"blocks\"] >= 1).\n        # use_toy[\"blocks\"] >= use_toy[\"cars\"]\n        model.addConstr(use_toy[\"blocks\"] >= use_toy[\"cars\"],\n                        \"Cars_Implies_Blocks\")\n        # Alternatively, using indicator:\n        # model.addConstr((use_toy[\"cars\"] == 1) >> (qty[\"blocks\"] >= 1), \"Cars_Implies_Blocks_Indicator\")\n\n        # 4. Relationship Constraint\n        # \"The number of dolls manufactured cannot exceed the number of model cars manufactured.\"\n        model.addConstr(qty[\"dolls\"] <= qty[\"cars\"], \"Dolls_leq_Cars\")\n\n        # --- Optimize Model ---\n        model.optimize()\n\n        # --- Results ---\n        print(\"-\" * 40)\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal production plan found!\")\n            print(f\"Maximum Total Profit: ${model.objVal:,.2f}\")\n            print(\"-\" * 40)\n            print(\"Production Quantities:\")\n            types_manufactured = 0\n            for t in toys:\n                qty_val = qty[t].X\n                if qty_val > 0.5:  # Check if quantity is positive (accounting for potential float issues)\n                    print(f\"  {t.capitalize()}: {qty_val:.0f} units\")\n                    types_manufactured += 1\n                else:\n                    print(f\"  {t.capitalize()}: 0 units\")\n            print(\"-\" * 40)\n            print(f\"Total types of toys to manufacture: {types_manufactured}\")\n            print(\"-\" * 40)\n\n            print(\"Resource Utilization:\")\n            plastic_used = sum(plastic_usage[t] * qty[t].X for t in toys)\n            electronics_used = sum(electronics_usage[t] * qty[t].X\n                                   for t in toys)\n            print(f\"  Plastic Used: {plastic_used:.0f} / {max_plastic} units\")\n            print(\n                f\"  Electronic Components Used: {electronics_used:.0f} / {max_electronics} units\"\n            )\n            print(\"-\" * 40)\n\n            print(\"Status of 'Use Toy' Variables (for verification):\")\n            for t in toys:\n                print(\n                    f\"  Manufacture {t.capitalize()} (use_{t}): {use_toy[t].X:.0f}\"\n                )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\n                \"Model is infeasible. No solution exists that satisfies all constraints.\"\n            )\n            print(\n                \"Consider reviewing the constraints, especially the conditional ones and resource limits.\"\n            )\n        elif model.status == GRB.UNBOUNDED:\n            print(\n                \"Model is unbounded. This typically means the objective can be improved indefinitely.\"\n            )\n        else:\n            print(f\"Optimization was stopped with status: {model.status}\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == \"__main__\":\n    solve_toy_production_problem()",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B020",
  "description": "A restaurant needs to order dining tables from three different suppliers, A, B, and C. The cost of ordering each dining table from Supplier A is $120, from Supplier B is $110, and from Supplier C is $100. The restaurant needs to minimize the total cost of the order.\n\nAdditionally, each order from Supplier A will include 20 tables, while each order from Suppliers B and C will include 15 tables. The number of orders must be an integer. The restaurant needs to order at least 150 tables.\n\nEach order from Supplier A will include 20 tables, and each order from Suppliers B and C will include 15 tables. The restaurant needs to order no more than 600 tables.\n\nIf the restaurant decides to order tables from Supplier A, it must also order at least 30 tables from Supplier B.\n\nAdditionally, if the restaurant decides to order tables from Supplier B, it must also order tables from Supplier C.",
  "ground_truth": 15000.0,
  "formulation": null,
  "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_restaurant_table_order_problem():\n    try:\n        # --- Problem Data ---\n        # Costs per table\n        cost_per_table_A = 120\n        cost_per_table_B = 110\n        cost_per_table_C = 100\n\n        # Tables per order\n        tables_per_order_A = 20\n        tables_per_order_B = 15\n        tables_per_order_C = 15\n\n        # Cost per order (derived)\n        cost_per_order_A = cost_per_table_A * tables_per_order_A\n        cost_per_order_B = cost_per_table_B * tables_per_order_B\n        cost_per_order_C = cost_per_table_C * tables_per_order_C\n\n        # Total table quantity limits\n        min_total_tables = 150\n        max_total_tables = 600\n\n        # Conditional requirement: if A is used, at least 30 tables from B\n        min_tables_from_B_if_A = 30\n        # Calculate minimum orders from B if A is used\n        min_orders_from_B_if_A = -(\n            -min_tables_from_B_if_A // tables_per_order_B)  # Ceiling division\n\n        # --- Model Creation ---\n        model = gp.Model(\"RestaurantTableOrderOptimization\")\n\n        # --- Decision Variables ---\n        # Number of orders from each supplier (must be integer, non-negative)\n        orders_A = model.addVar(vtype=GRB.INTEGER, name=\"Orders_A\", lb=0)\n        orders_B = model.addVar(vtype=GRB.INTEGER, name=\"Orders_B\", lb=0)\n        orders_C = model.addVar(vtype=GRB.INTEGER, name=\"Orders_C\", lb=0)\n\n        # Binary variables to indicate if any order is placed with a supplier\n        # use_A = 1 if orders_A > 0, 0 otherwise\n        # use_B = 1 if orders_B > 0, 0 otherwise\n        use_A = model.addVar(vtype=GRB.BINARY, name=\"Use_A\")\n        use_B = model.addVar(vtype=GRB.BINARY, name=\"Use_B\")\n        # use_C is not strictly needed for the B->C condition if directly linking orders_C to use_B,\n        # but can be added for clarity if desired. For now, we'll derive its usage.\n\n        # --- Objective Function ---\n        # Minimize the total cost of ordering\n        total_cost = (orders_A * cost_per_order_A +\n                      orders_B * cost_per_order_B +\n                      orders_C * cost_per_order_C)\n        model.setObjective(total_cost, GRB.MINIMIZE)\n\n        # --- Constraints ---\n\n        # 1. Calculate total number of tables ordered\n        total_tables_ordered = (orders_A * tables_per_order_A +\n                                orders_B * tables_per_order_B +\n                                orders_C * tables_per_order_C)\n\n        # 2. Total tables constraints\n        model.addConstr(total_tables_ordered >= min_total_tables,\n                        \"MinTotalTables\")\n        model.addConstr(total_tables_ordered <= max_total_tables,\n                        \"MaxTotalTables\")\n\n        # 3. Link binary 'use' variables to the number of orders\n        # Gurobi's indicator constraints are suitable here.\n        # (use_A == 1) => (orders_A >= 1)\n        # (use_A == 0) => (orders_A == 0)\n        model.addConstr((use_A == 1) >> (orders_A >= 1), \"Link_use_A_if_one\")\n        model.addConstr((use_A == 0) >> (orders_A == 0), \"Link_use_A_if_zero\")\n\n        # Similarly for use_B and orders_B\n        model.addConstr((use_B == 1) >> (orders_B >= 1), \"Link_use_B_if_one\")\n        model.addConstr((use_B == 0) >> (orders_B == 0), \"Link_use_B_if_zero\")\n\n        # 4. Conditional ordering constraints:\n        # \"If the restaurant decides to order tables from Supplier A (use_A = 1),\n        # it must also order at least 30 tables from Supplier B.\"\n        # This means orders_B * tables_per_order_B >= 30, so orders_B >= min_orders_from_B_if_A.\n        model.addConstr((use_A == 1) >> (orders_B >= min_orders_from_B_if_A),\n                        \"Conditional_A_implies_B_orders\")\n\n        # \"Additionally, if the restaurant decides to order tables from Supplier B (use_B = 1),\n        # it must also order tables from Supplier C (orders_C >= 1).\"\n        model.addConstr((use_B == 1) >> (orders_C >= 1),\n                        \"Conditional_B_implies_C_orders\")\n\n        # --- Optimize Model ---\n        model.optimize()\n\n        # --- Results ---\n        print(\"-\" * 40)\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal solution found!\")\n            print(f\"Minimum Total Cost: ${model.objVal:,.2f}\")\n            print(\"-\" * 40)\n            print(\"Order Plan:\")\n            print(f\"  Orders from Supplier A: {orders_A.X:.0f}\")\n            print(f\"    Tables from A: {orders_A.X * tables_per_order_A:.0f}\")\n            print(f\"  Orders from Supplier B: {orders_B.X:.0f}\")\n            print(f\"    Tables from B: {orders_B.X * tables_per_order_B:.0f}\")\n            print(f\"  Orders from Supplier C: {orders_C.X:.0f}\")\n            print(f\"    Tables from C: {orders_C.X * tables_per_order_C:.0f}\")\n            print(\"-\" * 40)\n\n            actual_total_tables = (orders_A.X * tables_per_order_A +\n                                   orders_B.X * tables_per_order_B +\n                                   orders_C.X * tables_per_order_C)\n            print(f\"Total Tables Ordered: {actual_total_tables:.0f}\")\n            print(\n                f\"  (Min required: {min_total_tables}, Max allowed: {max_total_tables})\"\n            )\n            print(\"-\" * 40)\n\n            print(\"Status of 'Use Supplier' Variables (for verification):\")\n            print(f\"  Use Supplier A (use_A): {use_A.X:.0f}\")\n            print(f\"  Use Supplier B (use_B): {use_B.X:.0f}\")\n            if orders_C.X > 0.5:  # Check if C was used\n                print(f\"  Use Supplier C: 1 (derived from orders_C > 0)\")\n            else:\n                print(f\"  Use Supplier C: 0 (derived from orders_C == 0)\")\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\n                \"Model is infeasible. No solution exists that satisfies all constraints.\"\n            )\n            print(\n                \"Consider reviewing the constraints, especially the conditional ones and table limits.\"\n            )\n            # You can compute and print an Irreducible Inconsistent Subsystem (IIS)\n            # to help debug infeasibility:\n            # model.computeIIS()\n            # model.write(\"model_iis.ilp\")\n            # print(\"IIS written to model_iis.ilp\")\n        elif model.status == GRB.UNBOUNDED:\n            print(\n                \"Model is unbounded. This typically means the objective can be improved indefinitely,\"\n            )\n            print(\n                \"which might indicate an issue with constraints or objective direction for minimization.\"\n            )\n        else:\n            print(f\"Optimization was stopped with status: {model.status}\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == \"__main__\":\n    solve_restaurant_table_order_problem()",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B021",
  "description": "A company plans to produce 3 types of products $A_{1}, A_{2}, A_{3}$. It can produce for 22 days in a month. The following table gives the maximum demand (unit $=100 \\mathrm{~kg}$), price ($\\$ / 100 \\mathrm{Kg}$), production cost (per 100Kg product), and production quota (the maximum number of 100kg units that can be produced in one day if all production lines are devoted to this product).\n\n| Product | $A_{1}$ | $A_{2}$ | $A_{3}$ |\n| :---: | :---: | :---: | :---: |\n| Maximum Demand | 5300 | 4500 | 5400 |\n| Selling Price | $124$ | $109$ | $115$ |\n| Production Cost | $73.30$ | $52.90$ | $65.40$ |\n| Production Quota | 500 | 450 | 550 |\n\nThe fixed activation cost of the production line is as follows:\n\n| Product | $A_{1}$ | $A_{2}$ | $A_{3}$ |\n| :---: | :---: | :---: | :---: |\n| Activation Cost | $170000$ | $150000$ | $100000$ |\n\nMinimum production batch:\n\n$$\n\\begin{array}{c|ccc}\nProduct & A_{1} & A_{2} & A_{3} \\\\\n\\hline\nMinimum Batch & 20 & 20 & 16\n\\end{array}\n$$\n\nPlease formulate an operations research model to determine a production plan that maximizes total revenue while accommodating fixed activation costs and minimum production batch constraints.",
  "ground_truth": 270290.0,
  "formulation": null,
  "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_complete_production_planning():\n    \"\"\"\n    Solves the production planning problem with fixed activation costs,\n    minimum batch sizes, and a shared time resource constraint.\n    \"\"\"\n    try:\n        # --- 1. Problem Data ---\n        products = ['A1', 'A2', 'A3']\n\n        max_demand = {'A1': 5300, 'A2': 4500, 'A3': 5400}  # units of 100kg\n        selling_price = {'A1': 124, 'A2': 109, 'A3': 115}  # $/100kg\n        production_cost = {'A1': 73.30, 'A2': 52.90, 'A3': 65.40}  # $/100kg\n        production_quota = {'A1': 500, 'A2': 450, 'A3': 550}  # 100kg units/day\n\n        activation_cost = {'A1': 170000, 'A2': 150000, 'A3': 100000}  # $\n        min_batch = {'A1': 20, 'A2': 20, 'A3': 16}  # units of 100kg\n\n        available_days = 22\n\n        # Pre-calculate profit per unit for clarity\n        profit_per_unit = {\n            p: selling_price[p] - production_cost[p]\n            for p in products\n        }\n\n        # --- 2. Model Creation ---\n        model = gp.Model(\"CompleteProductionPlanning\")\n\n        # --- 3. Decision Variables ---\n        # produce_qty[p]: quantity of product p to produce (in 100kg units)\n        produce_qty = model.addVars(products,\n                                    vtype=GRB.INTEGER,\n                                    name=\"produce_qty\",\n                                    lb=0)\n\n        # use_product[p]: binary variable, 1 if product p is produced, 0 otherwise\n        use_product = model.addVars(products,\n                                    vtype=GRB.BINARY,\n                                    name=\"use_product\")\n\n        # --- 4. Objective Function ---\n        # Maximize total profit = (sum of unit profits * quantity) - (sum of activation costs if produced)\n\n        # Variable profit from units produced\n        total_variable_profit = gp.quicksum(profit_per_unit[p] * produce_qty[p]\n                                            for p in products)\n\n        # Conditional activation costs\n        total_activation_cost = gp.quicksum(activation_cost[p] * use_product[p]\n                                            for p in products)\n\n        model.setObjective(total_variable_profit - total_activation_cost,\n                           GRB.MAXIMIZE)\n\n        # --- 5. Constraints ---\n\n        # Constraint 5.1: Shared Resource Constraint (Total Production Time)\n        # The one that was missing from the \"incorrect\" code.\n        model.addConstr(\n            gp.quicksum(produce_qty[p] / production_quota[p] for p in products)\n            <= available_days, \"TotalProductionTime\")\n\n        # Constraints applied to each product individually\n        for p in products:\n            # Constraint 5.2: Maximum Demand Constraint\n            # The production quantity cannot exceed market demand.\n            model.addConstr(produce_qty[p] <= max_demand[p], f\"MaxDemand_{p}\")\n\n            # Constraint 5.3: Link production quantity to the binary decision variable\n            # If we decide to produce (use_product[p] = 1), then production quantity must be >= min_batch.\n            # This correctly models the minimum batch size condition.\n            model.addConstr(produce_qty[p] >= min_batch[p] * use_product[p],\n                            f\"MinBatchLink_{p}\")\n\n            # Constraint 5.4: Link the binary variable to an upper bound on production.\n            # If we do not produce (use_product[p] = 0), quantity must be 0.\n            # If we do produce (use_product[p] = 1), quantity is limited by a large number (\"Big M\").\n            # A good \"Big M\" is the maximum possible demand for that product.\n            model.addConstr(produce_qty[p] <= max_demand[p] * use_product[p],\n                            f\"ActivationLink_{p}\")\n\n        # --- 6. Optimize Model ---\n        model.optimize()\n\n        # --- 7. Results ---\n        print(\"-\" * 50)\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal production plan found!\")\n            print(f\"Maximum Total Profit: ${model.objVal:,.2f}\")\n            print(\"-\" * 50)\n            print(\"Production Details:\")\n            total_days_used = 0\n            for p in products:\n                qty = produce_qty[p].X\n                days_for_p = qty / production_quota[p]\n                total_days_used += days_for_p\n\n                print(f\"  Product {p}:\")\n                if use_product[\n                        p].X > 0.5:  # Check if this product was activated\n                    print(f\"    Status: PRODUCED\")\n                    print(f\"    Produce Quantity (100kg units): {qty:.0f}\")\n                    print(f\"    Days Used: {days_for_p:.2f} days\")\n                    net_profit_p = (profit_per_unit[p] *\n                                    qty) - activation_cost[p]\n                    print(\n                        f\"    Net Profit (incl. activation cost): ${net_profit_p:,.2f}\"\n                    )\n                else:\n                    print(f\"    Status: NOT PRODUCED\")\n                print(\"-\" * 25)\n\n            print(\"Overall Resource Utilization:\")\n            print(\n                f\"  Total Production Days Used: {total_days_used:.2f} / {available_days} days\"\n            )\n            print(\"-\" * 50)\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\n                \"Model is infeasible. No solution exists that satisfies all constraints.\"\n            )\n        else:\n            print(f\"Optimization was stopped with status: {model.status}\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == \"__main__\":\n    solve_complete_production_planning()",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B022",
  "description": "Hongdou Clothing Factory uses three special equipment to produce shirts, short-sleeved shirts, and casual clothes respectively. It is known that the labor, material usage, selling price, and variable cost of each of the above products are as shown in Table 5-10.\n\nTable 5-10\n\n| Product Name | Labor per unit | Material per unit | Selling Price | Variable Cost |\n|--------------|----------------|------------------|---------------|---------------|\n| Shirt        | 3              | 4                | 120           | 60            |\n| Short-sleeve | 2              | 3                | 80            | 40            |\n| Casual Cloth | 6              | 6                | 180           | 80            |\n\nIt is known that the available labor per week is 1500 units, the available material is 1600 units, and the weekly fixed costs for the three special equipment for producing shirts, short-sleeved shirts, and casual clothes are 2000, 1500, and 1000 respectively. Design a weekly production plan for the factory to maximize its profit.",
  "ground_truth": 21500.0,
  "formulation": null,
  "correct_program": "def hongdou_factory_optimization(labor_per_unit=[3, 2, 6],\n                                 material_per_unit=[4, 3, 6],\n                                 selling_price=[120, 80, 180],\n                                 variable_cost=[60, 40, 80],\n                                 labor_available=1500,\n                                 material_available=1600,\n                                 fixed_costs=[2000, 1500, 1000]):\n    from gurobipy import Model, GRB\n\n    n = 3  # number of products\n\n    # Net profit per unit for each product\n    profit_per_unit = [selling_price[i] - variable_cost[i] for i in range(n)]\n    total_fixed_cost = sum(fixed_costs)\n\n    try:\n        m = Model()\n        m.setParam('OutputFlag', 0)\n\n        # Decision variables: x[i] = number of units produced for product i\n        x = [\n            m.addVar(lb=0, vtype=GRB.CONTINUOUS, name=f\"x_{i+1}\")\n            for i in range(n)\n        ]\n\n        # Objective: maximize total profit\n        m.setObjective(\n            sum(profit_per_unit[i] * x[i]\n                for i in range(n)) - total_fixed_cost, GRB.MAXIMIZE)\n\n        # Labor constraint\n        m.addConstr(\n            sum(labor_per_unit[i] * x[i] for i in range(n)) <= labor_available,\n            \"Labor\")\n\n        # Material constraint\n        m.addConstr(\n            sum(material_per_unit[i] * x[i] for i in range(n))\n            <= material_available, \"Material\")\n\n        # Solve\n        m.optimize()\n\n        if m.status == GRB.OPTIMAL:\n            return m.objVal\n        else:\n            return None\n    except Exception:\n        return None\n\nprint(hongdou_factory_optimization())",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B023",
  "description": "A manufacturing company needs to transport 1800 units of product from the warehouse to three different sales points. The company has four transportation options to choose from: truck, van, motorcycle, and electric vehicle. Since the van and electric vehicle both consume a lot of energy, the company wants to choose only one of these two options. Each trip with a truck generates 100 units of pollution, a van generates 50 units of pollution, a motorcycle generates 10 units of pollution, and an electric vehicle generates 0 units of pollution. The total pollution generated from all trips cannot exceed 2000 units. At least 10 trips must use a truck. Trucks, vans, motorcycles, and electric vehicles can transport 100 units, 80 units, 40 units, and 60 units of product per trip, respectively. The company needs to ensure that the total amount of transported product is at least 1800 units.",
  "ground_truth": 1000.0,
  "formulation": null,
  "correct_program": "def optimize_transportation():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"TransportationOptimization\")\n\n    # Decision variables\n    T = m.addVar(name=\"TruckTrips\", lb=10, vtype=GRB.INTEGER)\n    V = m.addVar(name=\"VanTrips\", lb=0, vtype=GRB.INTEGER)\n    M = m.addVar(name=\"MotorcycleTrips\", lb=0, vtype=GRB.INTEGER)\n    E = m.addVar(name=\"ElectricTrips\", lb=0, vtype=GRB.INTEGER)\n\n    y_V = m.addVar(name=\"UseVan\", vtype=GRB.BINARY)\n    y_E = m.addVar(name=\"UseElectric\", vtype=GRB.BINARY)\n\n    m.update()\n\n    # Set objective: minimize total pollution\n    m.setObjective(100 * T + 50 * V * y_V + 10 * M, GRB.MINIMIZE)\n\n    # Constraints\n    # Total units transported\n    m.addConstr(100 * T + 80 * V * y_V + 40 * M + 60 * E * y_E >= 1800,\n                name=\"Demand\")\n\n    # Pollution limit\n    m.addConstr(100 * T + 50 * V * y_V + 10 * M <= 2000, name=\"PollutionLimit\")\n\n    # Van/Electric vehicle exclusivity\n    m.addConstr(y_V + y_E <= 1, name=\"ModeChoice\")\n\n    # Minimum truck trips\n    m.addConstr(T >= 10, name=\"MinTruckTrips\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        return m.objVal\n    else:\n        return None\nif __name__ == \"__main__\":\n    result = optimize_transportation()\n    if result is not None:\n        print(f\"Optimal total pollution: {result}\")\n    else:\n        print(\"No feasible solution found.\")",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B024",
  "description": "An investor plans to invest 100,000 yuan, with two investment options to choose from. The first investment guarantees a return of 0.7 yuan for every 1 yuan invested after one year. The second investment guarantees a return of 2 yuan for every 1 yuan invested after two years, but the investment time must be in multiples of two years. In order to maximize the investor's earnings by the end of the third year, how should the investments be made? Formulate this as a linear programming problem.",
  "ground_truth": 510000.0,
  "formulation": null,
  "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_investment_problem():\n    \"\"\"\n    Solves the multi-period investment problem using Gurobi.\n    \"\"\"\n    try:\n        # Initial capital\n        K = 100000.0\n\n        # Create a new model\n        model = gp.Model(\"InvestmentStrategy\")\n\n        # --- Decision Variables ---\n        # x_ij: amount invested in option i at the start of year j (0-indexed for time)\n        # Option 1: 1-year term, 1 yuan becomes 1.7 yuan (0.7 profit)\n        # Option 2: 2-year term, 1 yuan becomes 3 yuan (2 profit)\n\n        # Investments at Start of Year 1 (Time 0)\n        x10 = model.addVar(name=\"x10\", lb=0.0,\n                           vtype=GRB.CONTINUOUS)  # Opt1, Year 1\n        x20 = model.addVar(name=\"x20\", lb=0.0,\n                           vtype=GRB.CONTINUOUS)  # Opt2, Year 1 (matures EOY2)\n\n        # Investments at Start of Year 2 (Time 1)\n        x11 = model.addVar(name=\"x11\", lb=0.0,\n                           vtype=GRB.CONTINUOUS)  # Opt1, Year 2\n        x21 = model.addVar(name=\"x21\", lb=0.0,\n                           vtype=GRB.CONTINUOUS)  # Opt2, Year 2 (matures EOY3)\n\n        # Investments at Start of Year 3 (Time 2)\n        x12 = model.addVar(name=\"x12\", lb=0.0,\n                           vtype=GRB.CONTINUOUS)  # Opt1, Year 3\n        # No x22 as Opt2 takes 2 years and goal is EOY3\n\n        # --- Objective Function ---\n        # Maximize total earnings by the end of year 3.\n        # Earnings = (Total value at EOY3) - K\n        # Total value = K + 0.7*x10 + 2*x20 + 0.7*x11 + 2*x21 + 0.7*x12\n        # Earnings = 0.7*x10 + 2*x20 + 0.7*x11 + 2*x21 + 0.7*x12\n        objective = 0.7 * x10 + 2.0 * x20 + 0.7 * x11 + 2.0 * x21 + 0.7 * x12\n        model.setObjective(objective, GRB.MAXIMIZE)\n\n        # --- Constraints ---\n        # Constraint 1: Cash availability at Start of Year 1 (Time 0)\n        model.addConstr(x10 + x20 <= K, \"Cash_Year1_Start\")\n\n        # Constraint 2: Cash availability at Start of Year 2 (Time 1)\n        # Money available = (K - x10 - x20) (uninvested T0) + 1.7*x10 (from x10 maturing)\n        # x11 + x21 <= K + 0.7*x10 - x20\n        model.addConstr(x11 + x21 - 0.7 * x10 + x20 <= K, \"Cash_Year2_Start\")\n\n        # Constraint 3: Cash availability at Start of Year 3 (Time 2)\n        # Money available at T2 = (Cash_Available_T1 - x11 - x21) (uninvested T1)\n        #                         + 1.7*x11 (from x11 maturing)\n        #                         + 3.0*x20 (from x20 maturing)\n        # Cash_Available_T1 = K + 0.7*x10 - x20\n        # Money available at T2 = (K + 0.7*x10 - x20 - x11 - x21) + 1.7*x11 + 3.0*x20\n        #                       = K + 0.7*x10 + 2.0*x20 + 0.7*x11 - x21\n        # x12 <= K + 0.7*x10 + 2.0*x20 + 0.7*x11 - x21\n        model.addConstr(x12 - 0.7 * x10 - 2.0 * x20 - 0.7 * x11 + x21 <= K,\n                        \"Cash_Year3_Start\")\n\n        # Suppress Gurobi output to console\n        model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal solution found.\")\n            print(f\"Maximum Earnings: {model.objVal:.2f} yuan\")\n            print(\"\\nInvestment Plan:\")\n            print(f\"  Start of Year 1 (Time 0):\")\n            print(f\"    Invest in Option 1 (x10): {x10.X:.2f} yuan\")\n            print(f\"    Invest in Option 2 (x20): {x20.X:.2f} yuan\")\n\n            available_t1 = K - x10.X - x20.X + 1.7 * x10.X\n            print(\n                f\"\\n  Cash available at Start of Year 2 (Time 1): {available_t1:.2f} yuan\"\n            )\n            print(f\"  Start of Year 2 (Time 1):\")\n            print(f\"    Invest in Option 1 (x11): {x11.X:.2f} yuan\")\n            print(f\"    Invest in Option 2 (x21): {x21.X:.2f} yuan\")\n\n            available_t2 = available_t1 - x11.X - x21.X + 1.7 * x11.X + 3.0 * x20.X\n            print(\n                f\"\\n  Cash available at Start of Year 3 (Time 2): {available_t2:.2f} yuan\"\n            )\n            print(f\"  Start of Year 3 (Time 2):\")\n            print(f\"    Invest in Option 1 (x12): {x12.X:.2f} yuan\")\n\n            total_value_eoy3 = K + model.objVal\n            print(\n                f\"\\nTotal value at End of Year 3: {total_value_eoy3:.2f} yuan\")\n\n        else:\n            print(\"No optimal solution found. Status code:\", model.status)\n\n    except gp.GurobiError as e:\n        print(f\"Error code {e.errno}: {e}\")\n    except AttributeError:\n        print(\n            \"Encountered an attribute error, Gurobi might not be installed or licensed correctly.\"\n        )\n\n\nif __name__ == '__main__':\n    solve_investment_problem()",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B025",
  "description": "The number of salespeople required at a 24-hour convenience store in different time periods is as follows: 2:00-6:00 - 10 people, 6:00-10:00 - 15 people, 10:00-14:00 - 25 people, 14:00-18:00 - 20 people, 18:00-22:00 - 18 people, 22:00-2:00 - 12 people. Salespeople start their shifts at 2:00, 6:00, 10:00, 14:00, 18:00, and 22:00, working continuously for 8 hours. Determine the minimum number of salespeople needed to meet the requirements.",
  "ground_truth": 53.0,
  "formulation": null,
  "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_staffing_problem():\n    \"\"\"\n    Solves the salespeople staffing problem using Gurobi.\n    Minimizes the total number of salespeople required to meet demand\n    across different time periods, with 8-hour shifts.\n    \"\"\"\n    try:\n        # Create a new model\n        model = gp.Model(\"StaffingOptimization\")\n\n        # --- Data ---\n        # Time periods (start_hour, end_hour) and demand\n        # For clarity, let's map period indices to actual start times for variables\n        # P0: 2:00-6:00, P1: 6:00-10:00, ..., P5: 22:00-2:00\n        demands = {\n            0: 10,  # 2:00 - 6:00\n            1: 15,  # 6:00 - 10:00\n            2: 25,  # 10:00 - 14:00\n            3: 20,  # 14:00 - 18:00\n            4: 18,  # 18:00 - 22:00\n            5: 12  # 22:00 - 2:00 (next day)\n        }\n        num_periods = len(demands)  # Should be 6\n\n        # Shift start times (represented by an index for variables)\n        # x[0] starts at 2:00\n        # x[1] starts at 6:00\n        # x[2] starts at 10:00\n        # x[3] starts at 14:00\n        # x[4] starts at 18:00\n        # x[5] starts at 22:00\n        shift_start_times_desc = [\n            \"2:00\", \"6:00\", \"10:00\", \"14:00\", \"18:00\", \"22:00\"\n        ]\n\n        # --- Decision Variables ---\n        # x[i]: number of salespeople starting their shift at the i-th possible start time\n        x = model.addVars(num_periods, vtype=GRB.INTEGER, name=\"x\", lb=0)\n\n        # --- Objective Function ---\n        # Minimize the total number of salespeople\n        model.setObjective(gp.quicksum(x[i] for i in range(num_periods)),\n                           GRB.MINIMIZE)\n\n        # --- Constraints ---\n        # Demand coverage for each period.\n        # Each salesperson works for 8 hours, covering two 4-hour periods.\n\n        # Period 0 (2:00-6:00): Covered by staff starting at 22:00 (x[5]) and 2:00 (x[0])\n        model.addConstr(x[5] + x[0] >= demands[0], \"Demand_02_06\")\n\n        # Period 1 (6:00-10:00): Covered by staff starting at 2:00 (x[0]) and 6:00 (x[1])\n        model.addConstr(x[0] + x[1] >= demands[1], \"Demand_06_10\")\n\n        # Period 2 (10:00-14:00): Covered by staff starting at 6:00 (x[1]) and 10:00 (x[2])\n        model.addConstr(x[1] + x[2] >= demands[2], \"Demand_10_14\")\n\n        # Period 3 (14:00-18:00): Covered by staff starting at 10:00 (x[2]) and 14:00 (x[3])\n        model.addConstr(x[2] + x[3] >= demands[3], \"Demand_14_18\")\n\n        # Period 4 (18:00-22:00): Covered by staff starting at 14:00 (x[3]) and 18:00 (x[4])\n        model.addConstr(x[3] + x[4] >= demands[4], \"Demand_18_22\")\n\n        # Period 5 (22:00-2:00): Covered by staff starting at 18:00 (x[4]) and 22:00 (x[5])\n        model.addConstr(x[4] + x[5] >= demands[5], \"Demand_22_02\")\n\n        # Suppress Gurobi output to console\n        model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal solution found.\")\n            print(f\"Minimum total salespeople needed: {model.objVal:.0f}\")\n            print(\"\\nNumber of salespeople starting at each shift:\")\n            for i in range(num_periods):\n                print(\n                    f\"  Start at {shift_start_times_desc[i]}: {x[i].X:.0f} salespeople\"\n                )\n\n            print(\"\\nVerification of coverage:\")\n            print(\n                f\"  Period 2:00-6:00 (Demand: {demands[0]}): Covered by {x[5].X + x[0].X:.0f} (x5={x[5].X:.0f} + x0={x[0].X:.0f})\"\n            )\n            print(\n                f\"  Period 6:00-10:00 (Demand: {demands[1]}): Covered by {x[0].X + x[1].X:.0f} (x0={x[0].X:.0f} + x1={x[1].X:.0f})\"\n            )\n            print(\n                f\"  Period 10:00-14:00 (Demand: {demands[2]}): Covered by {x[1].X + x[2].X:.0f} (x1={x[1].X:.0f} + x2={x[2].X:.0f})\"\n            )\n            print(\n                f\"  Period 14:00-18:00 (Demand: {demands[3]}): Covered by {x[2].X + x[3].X:.0f} (x2={x[2].X:.0f} + x3={x[3].X:.0f})\"\n            )\n            print(\n                f\"  Period 18:00-22:00 (Demand: {demands[4]}): Covered by {x[3].X + x[4].X:.0f} (x3={x[3].X:.0f} + x4={x[4].X:.0f})\"\n            )\n            print(\n                f\"  Period 22:00-2:00 (Demand: {demands[5]}): Covered by {x[4].X + x[5].X:.0f} (x4={x[4].X:.0f} + x5={x[5].X:.0f})\"\n            )\n\n        else:\n            print(\"No optimal solution found. Status code:\", model.status)\n\n    except gp.GurobiError as e:\n        print(f\"Error code {e.errno}: {e}\")\n    except AttributeError:\n        print(\n            \"Encountered an attribute error, Gurobi might not be installed or licensed correctly.\"\n        )\n\n\nif __name__ == '__main__':\n    solve_staffing_problem()",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B026",
  "description": "A factory produces three types of products: I, II, and III. Each product needs to go through two processing procedures, A and B. The factory has two pieces of equipment that can complete process A, denoted as A1 and A2; it has three pieces of equipment that complete process B, denoted as B1, B2, and B3. Product I can be processed on any equipment for A and B; Product II can be processed on any A equipment but only on B1 for process B; Product III can only be processed on A2 and B2. Given the unit processing time on various machines, raw material costs, product sale prices, effective machine hours, and the costs of operating the machines at full capacity as shown in Table 1-4, the task is to arrange the optimal production plan to maximize the factory's profit.\n\nTable 1-4\n| Equipment  | Product I | Product II | Product III | Effective Machine Hours | Operating Costs at Full Capacity (Yuan) |\n|------------|-----------|------------|-------------|--------------------------|------------------------------------------|\n| A1         | 5         | 10         |             | 6000                     | 300                                      |\n| A2         | 7         | 9          | 12          | 10000                    | 321                                      |\n| B1         | 6         | 8          |             | 4000                     | 250                                      |\n| B2         | 4         |            | 11          | 7000                     | 783                                      |\n| B3         | 7         |            |             | 4000                     | 200                                      |\n| Raw Material Cost (Yuan/Unit) | 0.25 | 0.35       | 0.50       |                          |                                          |\n| Unit Price (Yuan/Unit)        | 1.25 | 2.00       | 2.80       |                          |                                          |",
  "ground_truth": 1146.57,
  "formulation": null,
  "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_factory_production():\n    \"\"\"\n    Solves the factory production planning problem to maximize profit.\n    \"\"\"\n    try:\n        # Create a new model\n        model = gp.Model(\"FactoryProductionOptimization\")\n\n        # --- Data ---\n        # Processing times (hours/unit)\n        proc_times = {\n            ('I', 'A1'): 5,\n            ('I', 'A2'): 7,\n            ('II', 'A1'): 10,\n            ('II', 'A2'): 9,\n            ('III', 'A2'): 12,  # Product III only on A2 for Process A\n            ('I', 'B1'): 6,\n            ('I', 'B2'): 4,\n            ('I', 'B3'): 7,\n            ('II', 'B1'): 8,  # Product II only on B1 for Process B\n            ('III', 'B2'): 11  # Product III only on B2 for Process B\n        }\n\n        # Effective machine hours (capacity)\n        capacities = {\n            'A1': 6000,\n            'A2': 10000,\n            'B1': 4000,\n            'B2': 7000,\n            'B3': 4000\n        }\n\n        # Operating costs at full capacity (Yuan)\n        ocfc = {'A1': 300, 'A2': 321, 'B1': 250, 'B2': 783, 'B3': 200}\n\n        # Variable operating costs per hour (Yuan/hr)\n        voc = {m: ocfc[m] / capacities[m] for m in capacities}\n\n        # Raw material costs (Yuan/unit)\n        rmc = {'I': 0.25, 'II': 0.35, 'III': 0.50}\n\n        # Unit sale prices (Yuan/unit)\n        sp = {'I': 1.25, 'II': 2.00, 'III': 2.80}\n\n        products = ['I', 'II', 'III']\n        machines_A = ['A1', 'A2']\n        machines_B = ['B1', 'B2', 'B3']\n        all_machines = machines_A + machines_B\n\n        # --- Decision Variables ---\n        # X_p: Total units of product p to produce\n        X = model.addVars(products, name=\"X\", lb=0.0)\n\n        # x_pm: Quantity of product p processed on machine m\n        # For Process A machines\n        x_IA1 = model.addVar(name=\"x_I_A1\", lb=0.0)\n        x_IA2 = model.addVar(name=\"x_I_A2\", lb=0.0)\n        x_IIA1 = model.addVar(name=\"x_II_A1\", lb=0.0)\n        x_IIA2 = model.addVar(name=\"x_II_A2\", lb=0.0)\n        x_IIIA2 = model.addVar(name=\"x_III_A2\", lb=0.0)  # P-III only on A2\n\n        # For Process B machines\n        x_IB1 = model.addVar(name=\"x_I_B1\", lb=0.0)\n        x_IB2 = model.addVar(name=\"x_I_B2\", lb=0.0)\n        x_IB3 = model.addVar(name=\"x_I_B3\", lb=0.0)\n        x_IIB1 = model.addVar(name=\"x_II_B1\", lb=0.0)  # P-II only on B1\n        x_IIIB2 = model.addVar(name=\"x_III_B2\", lb=0.0)  # P-III only on B2\n\n        # --- Objective Function: Maximize Profit ---\n        total_revenue = gp.quicksum(sp[p] * X[p] for p in products)\n        total_rmc = gp.quicksum(rmc[p] * X[p] for p in products)\n\n        # Variable operating costs\n        op_cost_A1 = (proc_times[('I', 'A1')] * x_IA1 +\n                      proc_times[('II', 'A1')] * x_IIA1) * voc['A1']\n        op_cost_A2 = (proc_times[('I', 'A2')] * x_IA2 +\n                      proc_times[('II', 'A2')] * x_IIA2 +\n                      proc_times[('III', 'A2')] * x_IIIA2) * voc['A2']\n        op_cost_B1 = (proc_times[('I', 'B1')] * x_IB1 +\n                      proc_times[('II', 'B1')] * x_IIB1) * voc['B1']\n        op_cost_B2 = (proc_times[('I', 'B2')] * x_IB2 +\n                      proc_times[('III', 'B2')] * x_IIIB2) * voc['B2']\n        op_cost_B3 = (proc_times[('I', 'B3')] * x_IB3) * voc['B3']\n\n        total_variable_op_cost = op_cost_A1 + op_cost_A2 + op_cost_B1 + op_cost_B2 + op_cost_B3\n\n        profit = total_revenue - total_rmc - total_variable_op_cost\n        model.setObjective(profit, GRB.MAXIMIZE)\n\n        # --- Constraints ---\n        # 1. Machine Capacity Constraints\n        model.addConstr(\n            proc_times[('I', 'A1')] * x_IA1 + proc_times[('II', 'A1')] * x_IIA1\n            <= capacities['A1'], \"Cap_A1\")\n        model.addConstr(\n            proc_times[('I', 'A2')] * x_IA2 +\n            proc_times[('II', 'A2')] * x_IIA2 +\n            proc_times[('III', 'A2')] * x_IIIA2 <= capacities['A2'], \"Cap_A2\")\n        model.addConstr(\n            proc_times[('I', 'B1')] * x_IB1 + proc_times[('II', 'B1')] * x_IIB1\n            <= capacities['B1'], \"Cap_B1\")\n        model.addConstr(\n            proc_times[('I', 'B2')] * x_IB2 +\n            proc_times[('III', 'B2')] * x_IIIB2 <= capacities['B2'], \"Cap_B2\")\n        model.addConstr(proc_times[('I', 'B3')] * x_IB3 <= capacities['B3'],\n                        \"Cap_B3\")\n\n        # 2. Production Flow Conservation\n        # Product I\n        model.addConstr(x_IA1 + x_IA2 == X['I'], \"Flow_I_A\")\n        model.addConstr(x_IB1 + x_IB2 + x_IB3 == X['I'], \"Flow_I_B\")\n        # Product II\n        model.addConstr(x_IIA1 + x_IIA2 == X['II'], \"Flow_II_A\")\n        model.addConstr(x_IIB1 == X['II'], \"Flow_II_B\")  # P-II only on B1\n        # Product III\n        model.addConstr(x_IIIA2 == X['III'], \"Flow_III_A\")  # P-III only on A2\n        model.addConstr(x_IIIB2 == X['III'], \"Flow_III_B\")  # P-III only on B2\n\n        # Suppress Gurobi output to console\n        model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal production plan found.\")\n            print(f\"Maximum Profit: {model.objVal:.2f} Yuan\")\n            print(\"\\nTotal units of each product to produce:\")\n            for p in products:\n                print(f\"  Product {p}: {X[p].X:.2f} units\")\n\n            print(\"\\nProduction allocation (units on each machine):\")\n            print(\"  Process A:\")\n            print(f\"    Product I on A1 (x_I_A1): {x_IA1.X:.2f}\")\n            print(f\"    Product I on A2 (x_I_A2): {x_IA2.X:.2f}\")\n            print(f\"    Product II on A1 (x_II_A1): {x_IIA1.X:.2f}\")\n            print(f\"    Product II on A2 (x_II_A2): {x_IIA2.X:.2f}\")\n            print(f\"    Product III on A2 (x_III_A2): {x_IIIA2.X:.2f}\")\n            print(\"  Process B:\")\n            print(f\"    Product I on B1 (x_I_B1): {x_IB1.X:.2f}\")\n            print(f\"    Product I on B2 (x_I_B2): {x_IB2.X:.2f}\")\n            print(f\"    Product I on B3 (x_I_B3): {x_IB3.X:.2f}\")\n            print(f\"    Product II on B1 (x_II_B1): {x_IIB1.X:.2f}\")\n            print(f\"    Product III on B2 (x_III_B2): {x_IIIB2.X:.2f}\")\n\n            print(\"\\nMachine Utilization (Hours Used / Capacity):\")\n            hours_A1 = proc_times[('I', 'A1')] * x_IA1.X + proc_times[\n                ('II', 'A1')] * x_IIA1.X\n            hours_A2 = proc_times[('I', 'A2')] * x_IA2.X + proc_times[(\n                'II', 'A2')] * x_IIA2.X + proc_times[('III', 'A2')] * x_IIIA2.X\n            hours_B1 = proc_times[('I', 'B1')] * x_IB1.X + proc_times[\n                ('II', 'B1')] * x_IIB1.X\n            hours_B2 = proc_times[('I', 'B2')] * x_IB2.X + proc_times[\n                ('III', 'B2')] * x_IIIB2.X\n            hours_B3 = proc_times[('I', 'B3')] * x_IB3.X\n\n            print(\n                f\"  Machine A1: {hours_A1:.2f} / {capacities['A1']} hours ({hours_A1/capacities['A1']*100:.1f}%)\"\n            )\n            print(\n                f\"  Machine A2: {hours_A2:.2f} / {capacities['A2']} hours ({hours_A2/capacities['A2']*100:.1f}%)\"\n            )\n            print(\n                f\"  Machine B1: {hours_B1:.2f} / {capacities['B1']} hours ({hours_B1/capacities['B1']*100:.1f}%)\"\n            )\n            print(\n                f\"  Machine B2: {hours_B2:.2f} / {capacities['B2']} hours ({hours_B2/capacities['B2']*100:.1f}%)\"\n            )\n            print(\n                f\"  Machine B3: {hours_B3:.2f} / {capacities['B3']} hours ({hours_B3/capacities['B3']*100:.1f}%)\"\n            )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\"Model is infeasible. Check constraints and data.\")\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            # model.computeIIS()\n            # model.write(\"model_iis.ilp\")\n            # print(\"IIS written to model_iis.ilp\")\n        else:\n            print(f\"Optimization was stopped with status {model.status}\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_factory_production()",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B027",
  "description": "Someone has a fund of 300,000 yuan and has the following investment projects in the next three years:\n(1) Investment can be made at the beginning of each year within three years, with an annual profit of 20% of the investment amount, and the principal and interest can be used for investment in the following year;\n(2) Investment is only allowed at the beginning of the first year, and it can be recovered at the end of the second year, with the total principal and interest amounting to 150% of the investment amount, but the investment limit is no more than 150,000 yuan;\n(3) Investment is allowed at the beginning of the second year within three years, and it can be recovered at the end of the third year, with the total principal and interest amounting to 160% of the investment amount, and the investment limit is 200,000 yuan;\n(4) Investment is allowed at the beginning of the third year within three years, and it can be recovered in one year with a profit of 40%, and the investment limit is 100,000 yuan.\nChapter One: Linear Programming and Simplex Method\nTry to determine an investment plan for this person that maximizes the principal and interest at the end of the third year.",
  "ground_truth": 580000.0,
  "formulation": null,
  "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_investment_problem():\n    \"\"\"\n    Solves the multi-period investment problem using Gurobi to maximize\n    the total principal and interest at the end of the third year.\n    \"\"\"\n    try:\n        # Initial capital\n        K0 = 300000.0\n\n        # Create a new model\n        model = gp.Model(\"MultiPeriodInvestment\")\n\n        # --- Decision Variables ---\n        # x_ij: amount invested in project i at the start of year j\n        # Project 1: Annual, 20% profit (return 1.2)\n        x11 = model.addVar(name=\"x11_P1_Y1\", lb=0.0,\n                           vtype=GRB.CONTINUOUS)  # P1, Start of Year 1\n        x12 = model.addVar(name=\"x12_P1_Y2\", lb=0.0,\n                           vtype=GRB.CONTINUOUS)  # P1, Start of Year 2\n        x13 = model.addVar(name=\"x13_P1_Y3\", lb=0.0,\n                           vtype=GRB.CONTINUOUS)  # P1, Start of Year 3\n\n        # Project 2: Start Y1, 2-year, 150% total return (factor 1.5), limit 150k\n        x21 = model.addVar(name=\"x21_P2_Y1\", lb=0.0, vtype=GRB.CONTINUOUS)\n\n        # Project 3: Start Y2, 2-year, 160% total return (factor 1.6), limit 200k\n        x32 = model.addVar(name=\"x32_P3_Y2\", lb=0.0, vtype=GRB.CONTINUOUS)\n\n        # Project 4: Start Y3, 1-year, 40% profit (return 1.4), limit 100k\n        x43 = model.addVar(name=\"x43_P4_Y3\", lb=0.0, vtype=GRB.CONTINUOUS)\n\n        # --- Objective Function ---\n        # Maximize total principal and interest at the end of Year 3.\n        # Z = K0 + 0.2*x11 + 0.5*x21 + 0.2*x12 + 0.6*x32 + 0.2*x13 + 0.4*x43\n        objective = K0 + 0.2 * x11 + 0.5 * x21 + 0.2 * x12 + 0.6 * x32 + 0.2 * x13 + 0.4 * x43\n        model.setObjective(objective, GRB.MAXIMIZE)\n\n        # --- Constraints ---\n        # 1. Cash Availability at Start of Year 1\n        model.addConstr(x11 + x21 <= K0, \"Cash_SOY1\")\n\n        # 2. Cash Availability at Start of Year 2\n        # Investments_SOY2 <= K0 + 0.2*x11 - x21\n        # x12 + x32 - 0.2*x11 + x21 <= K0\n        model.addConstr(x12 + x32 - 0.2 * x11 + x21 <= K0, \"Cash_SOY2\")\n\n        # 3. Cash Availability at Start of Year 3\n        # Investments_SOY3 <= K0 + 0.2*x11 + 0.5*x21 + 0.2*x12 - x32\n        # x13 + x43 - 0.2*x11 - 0.5*x21 - 0.2*x12 + x32 <= K0\n        model.addConstr(\n            x13 + x43 - 0.2 * x11 - 0.5 * x21 - 0.2 * x12 + x32 <= K0,\n            \"Cash_SOY3\")\n\n        # 4. Investment Limit for Project 2\n        model.addConstr(x21 <= 150000, \"Limit_P2\")\n\n        # 5. Investment Limit for Project 3\n        model.addConstr(x32 <= 200000, \"Limit_P3\")\n\n        # 6. Investment Limit for Project 4\n        model.addConstr(x43 <= 100000, \"Limit_P4\")\n\n        # Suppress Gurobi output to console\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal investment plan found.\")\n            print(\n                f\"Maximum Principal and Interest at End of Year 3: {model.objVal:.2f} yuan\"\n            )\n\n            total_profit = model.objVal - K0\n            print(f\"Total Profit over 3 years: {total_profit:.2f} yuan\")\n\n            print(\"\\nInvestment Plan Details (yuan):\")\n            print(\"  Start of Year 1:\")\n            print(f\"    Project 1 (Annual, 20% profit): {x11.X:.2f}\")\n            print(\n                f\"    Project 2 (2-year, 150% return, limit 150k): {x21.X:.2f}\"\n            )\n            cash_soy1_invested = x11.X + x21.X\n            cash_soy1_uninvested = K0 - cash_soy1_invested\n            print(f\"    Total invested at SOY1: {cash_soy1_invested:.2f}\")\n            print(f\"    Uninvested cash from SOY1: {cash_soy1_uninvested:.2f}\")\n\n            cash_available_soy2 = K0 + 0.2 * x11.X - x21.X\n            print(\n                f\"\\n  Cash available at Start of Year 2: {cash_available_soy2:.2f}\"\n            )\n            print(\"  Start of Year 2:\")\n            print(f\"    Project 1 (Annual, 20% profit): {x12.X:.2f}\")\n            print(\n                f\"    Project 3 (2-year, 160% return, limit 200k): {x32.X:.2f}\"\n            )\n            cash_soy2_invested = x12.X + x32.X\n            cash_soy2_uninvested = cash_available_soy2 - cash_soy2_invested\n            print(f\"    Total invested at SOY2: {cash_soy2_invested:.2f}\")\n            print(f\"    Uninvested cash from SOY2: {cash_soy2_uninvested:.2f}\")\n\n            cash_available_soy3 = K0 + 0.2 * x11.X + 0.5 * x21.X + 0.2 * x12.X - x32.X\n            print(\n                f\"\\n  Cash available at Start of Year 3: {cash_available_soy3:.2f}\"\n            )\n            print(\"  Start of Year 3:\")\n            print(f\"    Project 1 (Annual, 20% profit): {x13.X:.2f}\")\n            print(\n                f\"    Project 4 (1-year, 40% profit, limit 100k): {x43.X:.2f}\")\n            cash_soy3_invested = x13.X + x43.X\n            cash_soy3_uninvested = cash_available_soy3 - cash_soy3_invested\n            print(f\"    Total invested at SOY3: {cash_soy3_invested:.2f}\")\n            print(\n                f\"    Uninvested cash from SOY3 (carried to EOY3): {cash_soy3_uninvested:.2f}\"\n            )\n\n        else:\n            print(\"No optimal solution found. Status code:\", model.status)\n\n    except gp.GurobiError as e:\n        print(f\"Error code {e.errno}: {e}\")\n    except AttributeError:\n        print(\n            \"Encountered an attribute error. Gurobi might not be installed or licensed correctly.\"\n        )\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_investment_problem()",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B029",
  "description": "Suppose a certain animal needs at least $700 \\mathrm{~g}$ of protein, $30 \\mathrm{~g}$ of minerals, and $100 \\mathrm{mg}$ of vitamins daily. There are 5 types of feed available, and the nutritional content and price per gram of each type of feed are shown in Table 1-5:\nTry to formulate a linear programming model that meets the animal's growth needs while minimizing the cost of selecting the feed.\nTable 1-6\n| Feed | Protein (g) | Minerals (g) | Vitamins (mg) | Price (¥/kg) | Feed | Protein (g) | Minerals (g) | Vitamins (mg) | Price (¥/kg) |\n|------|-------------|--------------|---------------|--------------|------|-------------|--------------|---------------|--------------|\n| 1    | 3           | 1            | 0.5           | 0.2          | 4    | 6           | 2            | 2             | 0.3          |\n| 2    | 2           | 0.5          | 1             | 0.7          | 5    | 18          | 0.5          | 0.8           | 0.8          |\n| 3    | 1           | 0.2          | 0.2           | 0.4          |      |             |              |               |              |",
  "ground_truth": 32.43589743589744,
  "formulation": null,
  "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_feed_mix_problem():\n    \"\"\"\n    Solves the animal feed mix optimization problem using Gurobi.\n    The goal is to minimize the cost of feed while meeting daily nutritional requirements.\n    \"\"\"\n    try:\n        # --- Data ---\n        # Nutritional content per kg of feed: (Protein (g), Minerals (g), Vitamins (mg))\n        # Price per kg of feed (¥/kg)\n\n        feeds_data = {\n            # Feed_ID: [Protein, Minerals, Vitamins, Price]\n            1: [3, 1, 0.5, 0.2],\n            2: [2, 0.5, 1, 0.7],\n            3: [1, 0.2, 0.2, 0.4],\n            4: [6, 2, 2, 0.3],\n            5: [18, 0.5, 0.8, 0.8]\n        }\n\n        feed_ids = list(feeds_data.keys())\n\n        # Daily nutritional requirements\n        min_protein = 700  # g\n        min_minerals = 30  # g\n        min_vitamins = 100  # mg\n\n        # --- Create a new model ---\n        model = gp.Model(\"FeedMixOptimization\")\n\n        # --- Decision Variables ---\n        # x[i]: amount of feed i to use, in kilograms (kg)\n        x = model.addVars(feed_ids, name=\"x\", lb=0.0, vtype=GRB.CONTINUOUS)\n\n        # --- Objective Function ---\n        # Minimize the total cost of the feed mixture\n        # Cost = sum(price_i * x_i for i in feeds)\n        total_cost = gp.quicksum(feeds_data[i][3] * x[i] for i in feed_ids)\n        model.setObjective(total_cost, GRB.MINIMIZE)\n\n        # --- Constraints ---\n        # 1. Protein Requirement\n        model.addConstr(\n            gp.quicksum(feeds_data[i][0] * x[i] for i in feed_ids)\n            >= min_protein, \"ProteinRequirement\")\n\n        # 2. Minerals Requirement\n        model.addConstr(\n            gp.quicksum(feeds_data[i][1] * x[i] for i in feed_ids)\n            >= min_minerals, \"MineralsRequirement\")\n\n        # 3. Vitamins Requirement\n        model.addConstr(\n            gp.quicksum(feeds_data[i][2] * x[i] for i in feed_ids)\n            >= min_vitamins, \"VitaminsRequirement\")\n\n        # Suppress Gurobi output to console\n        model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal feed mix found.\")\n            print(f\"Minimum Cost: {model.objVal:.2f} ¥\")\n            print(\"\\nAmount of each feed to use (kg):\")\n            total_feed_kg = 0\n            for i in feed_ids:\n                if x[i].X > 1e-6:  # Print only if the amount is significant\n                    print(f\"  Feed {i}: {x[i].X:.2f} kg\")\n                    total_feed_kg += x[i].X\n            print(f\"\\nTotal kilograms of feed: {total_feed_kg:.2f} kg\")\n\n            # Verification of nutritional intake\n            achieved_protein = sum(feeds_data[i][0] * x[i].X for i in feed_ids)\n            achieved_minerals = sum(feeds_data[i][1] * x[i].X\n                                    for i in feed_ids)\n            achieved_vitamins = sum(feeds_data[i][2] * x[i].X\n                                    for i in feed_ids)\n            print(\"\\nNutritional Intake with this mix:\")\n            print(\n                f\"  Protein: {achieved_protein:.2f} g (Required: >= {min_protein} g)\"\n            )\n            print(\n                f\"  Minerals: {achieved_minerals:.2f} g (Required: >= {min_minerals} g)\"\n            )\n            print(\n                f\"  Vitamins: {achieved_vitamins:.2f} mg (Required: >= {min_vitamins} mg)\"\n            )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\n                \"Model is infeasible. The nutritional requirements cannot be met with the given feeds under the specified constraints.\"\n            )\n            # You can compute and print IIS (Irreducible Inconsistent Subsystem) to help debug\n            # model.computeIIS()\n            # model.write(\"feed_mix_iis.ilp\")\n            # print(\"IIS written to feed_mix_iis.ilp. Review this file to find conflicting constraints.\")\n        else:\n            print(f\"Optimization was stopped with status: {model.status}\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_feed_mix_problem()",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B030",
  "description": "A factory produces three types of products, I, II, and III. Each product requires two processing stages, A and B. It is assumed that the factory has two types of equipment to complete the A processing stage, denoted as A1 and A2; and two types of equipment to complete the B processing stage, denoted as B1 and B2. Product I can be processed on any type of A equipment, but for the B processing stage, it can only be processed on B1 equipment; Product III can only be processed on A2 and B2 equipment. The processing time per piece, raw material cost, sales price of products, effective machine hours for various equipment, and costs of equipment at full capacity are given in Table 1-18. The requirement is to arrange the optimal production plan so that the factory's profit is maximized.\n\nTable 1-18\n| Equipment   | Product I | Product II | Product III | Effective Machine Hours | Cost of Equipment at Full Capacity (Yuan) |\n|-------------|-----------|------------|-------------|------------------------|-------------------------------------------|\n| A1          | 5         | 10         |             | 10000                 | 321                                       |\n| A2          | 7         | 9          | 12          | 4000                  | 250                                       |\n| B1          | 6         | 8          |             | 7000                  | 783                                       |\n| B2          | 4         |            | 11          | 4000                  | 200                                       |\n| B3          | 7         |            |             |                       |                                           |\n| Raw Material Cost (Yuan/Piece) | 0.25      | 0.35       | 0.50       |                        |                                           |\n| Unit Price (Yuan/Piece)        | 1.25      | 2.00       | 2.80       |                        |                                           |",
  "ground_truth": 712.875,
  "formulation": null,
  "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_factory_production_revised():\n    \"\"\"\n    Solves the revised factory production planning problem to maximize profit.\n    \"\"\"\n    try:\n        # Create a new model\n        model = gp.Model(\"FactoryProductionOptimizationRevised\")\n\n        # --- Data ---\n        # Processing times (hours/piece)\n        proc_times = {\n            ('I', 'A1'): 5,\n            ('I', 'A2'): 7,\n            ('II', 'A1'): 10,\n            ('II', 'A2'): 9,\n            ('III', 'A2'): 12,\n            ('I', 'B1'): 6,\n            ('II', 'B1'): 8,\n            ('III', 'B2'): 11\n        }\n\n        # Effective machine hours (capacity)\n        capacities = {'A1': 10000, 'A2': 4000, 'B1': 7000, 'B2': 4000}\n\n        # Operating costs at full capacity (Yuan)\n        ocfc = {'A1': 321, 'A2': 250, 'B1': 783, 'B2': 200}\n\n        # Variable operating costs per hour (Yuan/hr)\n        # It's good practice to calculate this precisely.\n        voc = {\n            m: ocfc[m] / capacities[m] if capacities[m] > 0 else 0\n            for m in capacities\n        }\n\n        # Raw material costs (Yuan/piece)\n        rmc = {'I': 0.25, 'II': 0.35, 'III': 0.50}\n\n        # Unit sale prices (Yuan/piece)\n        sp = {'I': 1.25, 'II': 2.00, 'III': 2.80}\n\n        products = ['I', 'II', 'III']\n\n        # --- Decision Variables ---\n        # X_p: Total pieces of product p to produce\n        X = model.addVars(products, name=\"X\", lb=0.0, vtype=GRB.INTEGER)\n\n        # x_pm: Quantity of product p processed on specific machine m, based on allowed routes\n        # Process A variables\n        x_IA1 = model.addVar(name=\"x_I_A1\", lb=0.0, vtype=GRB.INTEGER)\n        x_IA2 = model.addVar(name=\"x_I_A2\", lb=0.0, vtype=GRB.INTEGER)\n        x_IIA1 = model.addVar(name=\"x_II_A1\", lb=0.0, vtype=GRB.INTEGER)\n        x_IIA2 = model.addVar(name=\"x_II_A2\", lb=0.0, vtype=GRB.INTEGER)\n        x_IIIA2 = model.addVar(name=\"x_III_A2\", lb=0.0,\n                               vtype=GRB.INTEGER)  # Product III only on A2\n\n        # Process B variables\n        x_IB1 = model.addVar(name=\"x_I_B1\", lb=0.0,\n                             vtype=GRB.INTEGER)  # Product I only on B1\n        x_IIB1 = model.addVar(name=\"x_II_B1\", lb=0.0,\n                              vtype=GRB.INTEGER)  # Product II only on B1\n        x_IIIB2 = model.addVar(name=\"x_III_B2\", lb=0.0,\n                               vtype=GRB.INTEGER)  # Product III only on B2\n\n        # --- Objective Function: Maximize Profit ---\n        # Profit = Total Revenue - Total Raw Material Cost - Total Variable Operating Cost\n\n        total_revenue = gp.quicksum(sp[p] * X[p] for p in products)\n        total_rmc = gp.quicksum(rmc[p] * X[p] for p in products)\n\n        # Variable operating costs for each machine\n        op_cost_A1 = (proc_times[('I', 'A1')] * x_IA1 +\n                      proc_times[('II', 'A1')] * x_IIA1) * voc['A1']\n        op_cost_A2 = (proc_times[('I', 'A2')] * x_IA2 +\n                      proc_times[('II', 'A2')] * x_IIA2 +\n                      proc_times[('III', 'A2')] * x_IIIA2) * voc['A2']\n        op_cost_B1 = (proc_times[('I', 'B1')] * x_IB1 +\n                      proc_times[('II', 'B1')] * x_IIB1) * voc['B1']\n        op_cost_B2 = (proc_times[('III', 'B2')] * x_IIIB2) * voc['B2']\n\n        total_variable_op_cost = op_cost_A1 + op_cost_A2 + op_cost_B1 + op_cost_B2\n\n        profit = total_revenue - total_rmc - total_variable_op_cost\n        model.setObjective(profit, GRB.MAXIMIZE)\n\n        # --- Constraints ---\n        # 1. Machine Capacity Constraints\n        model.addConstr(\n            proc_times[('I', 'A1')] * x_IA1 + proc_times[('II', 'A1')] * x_IIA1\n            <= capacities['A1'], \"Cap_A1\")\n        model.addConstr(\n            proc_times[('I', 'A2')] * x_IA2 +\n            proc_times[('II', 'A2')] * x_IIA2 +\n            proc_times[('III', 'A2')] * x_IIIA2 <= capacities['A2'], \"Cap_A2\")\n        model.addConstr(\n            proc_times[('I', 'B1')] * x_IB1 + proc_times[('II', 'B1')] * x_IIB1\n            <= capacities['B1'], \"Cap_B1\")\n        model.addConstr(proc_times[('III', 'B2')] * x_IIIB2\n                        <= capacities['B2'], \"Cap_B2\")  # Only Prod III uses B2\n\n        # 2. Production Flow Conservation (linking total product X_p to machine allocations)\n        # Product I\n        model.addConstr(\n            x_IA1 + x_IA2 == X['I'],\n            \"Flow_I_A_Total\")  # Sum of A processing for I = Total I\n        model.addConstr(\n            x_IB1 == X['I'],\n            \"Flow_I_B_Total\")  # B processing for I (only on B1) = Total I\n\n        # Product II\n        model.addConstr(\n            x_IIA1 + x_IIA2 == X['II'],\n            \"Flow_II_A_Total\")  # Sum of A processing for II = Total II\n        model.addConstr(\n            x_IIB1 == X['II'],\n            \"Flow_II_B_Total\")  # B processing for II (only on B1) = Total II\n\n        # Product III\n        model.addConstr(x_IIIA2 == X['III'], \"Flow_III_A_Total\"\n                        )  # A processing for III (only on A2) = Total III\n        model.addConstr(x_IIIB2 == X['III'], \"Flow_III_B_Total\"\n                        )  # B processing for III (only on B2) = Total III\n\n        # Suppress Gurobi output to console\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal production plan found.\")\n            print(f\"Maximum Profit: {model.objVal:.2f} Yuan\")\n            print(\"\\nTotal pieces of each product to produce:\")\n            for p in products:\n                print(f\"  Product {p}: {X[p].X:.2f} pieces\")\n\n            print(\"\\nProduction allocation (pieces on each machine):\")\n            print(\"  Process A:\")\n            if x_IA1.X > 1e-6:\n                print(f\"    Product I on A1 (x_I_A1): {x_IA1.X:.2f}\")\n            if x_IA2.X > 1e-6:\n                print(f\"    Product I on A2 (x_I_A2): {x_IA2.X:.2f}\")\n            if x_IIA1.X > 1e-6:\n                print(f\"    Product II on A1 (x_II_A1): {x_IIA1.X:.2f}\")\n            if x_IIA2.X > 1e-6:\n                print(f\"    Product II on A2 (x_II_A2): {x_IIA2.X:.2f}\")\n            if x_IIIA2.X > 1e-6:\n                print(f\"    Product III on A2 (x_III_A2): {x_IIIA2.X:.2f}\")\n\n            print(\"  Process B:\")\n            if x_IB1.X > 1e-6:\n                print(f\"    Product I on B1 (x_I_B1): {x_IB1.X:.2f}\")\n            if x_IIB1.X > 1e-6:\n                print(f\"    Product II on B1 (x_II_B1): {x_IIB1.X:.2f}\")\n            if x_IIIB2.X > 1e-6:\n                print(f\"    Product III on B2 (x_III_B2): {x_IIIB2.X:.2f}\")\n\n            print(\n                \"\\nMachine Utilization (Hours Used / Capacity | % Utilization):\"\n            )\n            hours_A1 = proc_times.get(\n                ('I', 'A1'), 0) * x_IA1.X + proc_times.get(\n                    ('II', 'A1'), 0) * x_IIA1.X\n            hours_A2 = proc_times.get(\n                ('I', 'A2'), 0) * x_IA2.X + proc_times.get(\n                    ('II', 'A2'), 0) * x_IIA2.X + proc_times.get(\n                        ('III', 'A2'), 0) * x_IIIA2.X\n            hours_B1 = proc_times.get(\n                ('I', 'B1'), 0) * x_IB1.X + proc_times.get(\n                    ('II', 'B1'), 0) * x_IIB1.X\n            hours_B2 = proc_times.get(('III', 'B2'), 0) * x_IIIB2.X\n\n            util_A1 = (hours_A1 / capacities['A1'] *\n                       100) if capacities['A1'] > 0 else 0\n            util_A2 = (hours_A2 / capacities['A2'] *\n                       100) if capacities['A2'] > 0 else 0\n            util_B1 = (hours_B1 / capacities['B1'] *\n                       100) if capacities['B1'] > 0 else 0\n            util_B2 = (hours_B2 / capacities['B2'] *\n                       100) if capacities['B2'] > 0 else 0\n\n            print(\n                f\"  Machine A1: {hours_A1:.2f} / {capacities['A1']} hours | {util_A1:.1f}%\"\n            )\n            print(\n                f\"  Machine A2: {hours_A2:.2f} / {capacities['A2']} hours | {util_A2:.1f}%\"\n            )\n            print(\n                f\"  Machine B1: {hours_B1:.2f} / {capacities['B1']} hours | {util_B1:.1f}%\"\n            )\n            print(\n                f\"  Machine B2: {hours_B2:.2f} / {capacities['B2']} hours | {util_B2:.1f}%\"\n            )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\"Model is infeasible. Check constraints and data.\")\n            # To help debug, compute and print IIS (Irreducible Inconsistent Subsystem)\n            # model.computeIIS()\n            # model.write(\"factory_production_revised_iis.ilp\")\n            # print(\"IIS written to factory_production_revised_iis.ilp\")\n        else:\n            print(f\"Optimization was stopped with status {model.status}\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_factory_production_revised()",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B031",
  "description": "A product consists of three components produced by four workshops, each with a limited number of production hours. Table 1.4 below provides the production rates of the three components. The objective is to determine the number of hours each workshop should allocate to each component to maximize the number of completed products. Formulate this problem as a linear programming problem.\n\nTable 1.4\n\n| Workshop | Production Capacity (hours) | Production Rate (units/hour) |   |   |\n| :------: | :-------------------------: | :--------------------------: | - | - |\n|          |                             | Component 1 | Component 2  | Component 3 |\n|    A     |           100               |      10      |      15     |      5      |\n|    B     |           150               |      15      |      10     |      5      |\n|    C     |           80                |      20      |      5      |      10     |\n|    D     |           200               |      10      |      15     |      20     |",
  "ground_truth": 2924.0,
  "formulation": null,
  "correct_program": "from gurobipy import Model, GRB\n\n# Data from Table 1.4\nworkshops = ['A', 'B', 'C', 'D']\ncomponents = [1, 2, 3]\n\n# Production capacity (in hours) for each workshop\nprod_capacity = {'A': 100, 'B': 150, 'C': 80, 'D': 200}\n\n# Production rate (units/hour) for each component in each workshop\nprod_rate = {\n    ('A', 1): 10,\n    ('A', 2): 15,\n    ('A', 3): 5,\n    ('B', 1): 15,\n    ('B', 2): 10,\n    ('B', 3): 5,\n    ('C', 1): 20,\n    ('C', 2): 5,\n    ('C', 3): 10,\n    ('D', 1): 10,\n    ('D', 2): 15,\n    ('D', 3): 20\n}\n\n# Create model\nmodel = Model(\"Maximize_Complete_Products\")\n\n# Add variables\nx = model.addVars(workshops, components, lb=0, name=\"x\")  # Hours allocated\nz = model.addVar(name=\"z\", vtype=GRB.INTEGER)  # Number of complete products\n\n# Set objective: maximize z\nmodel.setObjective(z, GRB.MAXIMIZE)\n\n# Add constraints:\n\n# 1. For each component, total produced >= z\nfor j in components:\n    model.addConstr(sum(prod_rate[i, j] * x[i, j] for i in workshops) >= z,\n                    name=f\"Component_{j}_enough_for_z\")\n\n# 2. Workshop time availability constraint\nfor i in workshops:\n    model.addConstr(sum(x[i, j] for j in components) <= prod_capacity[i],\n                    name=f\"Workshop_{i}_time_limit\")\n\n# Optimize\nmodel.optimize()\n\n# Output results\nif model.status == GRB.OPTIMAL:\n    print(f\"\\nMaximum number of complete products: {z.X:.2f}\\n\")\n\n    print(\"Hours allocated per component:\")\n    for i in workshops:\n        for j in components:\n            if x[i, j].X > 0:\n                print(f\"Workshop {i}, Component {j}: {x[i, j].X:.2f} hours\")\nelse:\n    print(\"No optimal solution found.\")",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B032",
  "description": "A wealthy noble passed away, leaving the following inheritance:\n\n- A painting by Caillebotte: $25000\n- A bust of Diocletian: $5000\n- A Yuan dynasty Chinese vase: $20000\n- A 911 Porsche: $40000\n- Three diamonds: each $12000\n- A Louis XV sofa: $3000\n- Two very precious Jack Russell racing dogs: each $3000 (will stipulates they must not be separated)\n- A sculpture from 200 AD: $10000\n- A sailing boat: $15000\n- A Harley Davidson motorcycle: $10000\n- A piece of furniture once belonging to Cavour: $13000,\n\nwhich must be shared between two sons. How to formulate a mathematical program and solve it using COPTPY to minimize the difference in value between the two parts?",
  "ground_truth": 1000.0,
  "formulation": null,
  "correct_program": "def minimize_inheritance_difference():\n    from gurobipy import Model, GRB\n\n    # Item values\n    values = {\n        'painting': 25000,\n        'bust': 5000,\n        'vase': 20000,\n        'porsche': 40000,\n        'diamond1': 12000,\n        'diamond2': 12000,\n        'diamond3': 12000,\n        'sofa': 3000,\n        'dog1': 3000,\n        'dog2': 3000,\n        'sculpture': 10000,\n        'boat': 15000,\n        'motorcycle': 10000,\n        'cavour_furniture': 13000\n    }\n\n    # Initialize model\n    m = Model(\"InheritancePartition\")\n    m.setParam('OutputFlag', 0)  # Silence output\n\n    # Decision variables: y_i for each item\n    y_vars = {}\n    for item in values:\n        y_vars[item] = m.addVar(vtype=GRB.BINARY, name=f'y_{item}')\n\n    # Auxiliary variable for absolute difference\n    d = m.addVar(vtype=GRB.CONTINUOUS, name='d')\n\n    m.update()\n\n    # Total value\n    V_total = sum(values.values())\n\n    # Objective: minimize d\n    m.setObjective(d, GRB.MINIMIZE)\n\n    # Constraints for absolute difference linearization\n    sum_values_y = sum(values[item] * y_vars[item] for item in values)\n    m.addConstr(2 * sum_values_y - V_total <= d, \"abs_diff_upper\")\n    m.addConstr(-(2 * sum_values_y - V_total) <= d, \"abs_diff_lower\")\n\n    # Constraint: dogs must stay together\n    m.addConstr(y_vars['dog1'] == y_vars['dog2'], \"dogs_together\")\n\n    # Optimize\n    m.optimize()\n\n    if m.status == GRB.OPTIMAL:\n        # Return the minimal difference\n        return m.objVal\n    else:\n        return None\nif __name__ == \"__main__\":\n    result = minimize_inheritance_difference()\n    if result is not None:\n        print(f\"Minimal inheritance difference: {result}\")\n    else:\n        print(\"No feasible solution found.\")",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B033",
  "description": "The current problem faced by the company is how to use the fewest number of containers to pack the currently needed goods for transportation, while considering the weight of the goods, specific packaging requirements, and inventory limitations. Professional modeling and analysis are needed for a batch of goods’ transportation strategy to ensure maximum utilization of the limited container space.\n\nThe company currently has a batch to be transported, with each container able to hold a maximum of 60 tons of goods and each container used must load at least 18 tons of goods. The goods to be loaded include five types: A, B, C, D, and E, with quantities of 120, 90, 300, 90, and 120 respectively. The weights are 0.5 tons for A, 1 ton for B, 0.4 tons for C, 0.6 tons for D, and 0.65 tons for E. Additionally, to meet specific usage requirements, every time A goods are loaded, at least 1 unit of C must also be loaded, but loading C alone does not require simultaneously loading A; and considering the demand limitation for D goods, each container must load at least 12 units of D.\n\nEstablish an operations research model so that the company can use the fewest number of containers to pack this batch of goods.",
  "ground_truth": 7.0,
  "formulation": null,
  "correct_program": "def optimize_container_usage():\n    from gurobipy import Model, GRB\n\n    # Data\n    demands = {'A': 120, 'B': 90, 'C': 300, 'D': 90, 'E': 120}\n    weights = {'A': 0.5, 'B': 1.0, 'C': 0.4, 'D': 0.6, 'E': 0.65}\n    max_containers = 20  # Sufficient upper bound\n\n    M = 1e5  # Large number for big-M method\n\n    # Initialize model\n    model = Model(\"ContainerPacking\")\n\n    # Decision variables\n    y = model.addVars(max_containers, vtype=GRB.BINARY,\n                      name='y')  # Container usage\n    z_A = model.addVars(max_containers, vtype=GRB.BINARY,\n                        name='zA')  # Indicator for A loaded\n    x = model.addVars(demands.keys(),\n                      max_containers,\n                      lb=0,\n                      ub=GRB.INFINITY,\n                      name='x')\n\n    # Set objective: minimize number of containers used\n    model.setObjective(y.sum(), GRB.MINIMIZE)\n\n    # Demand constraints\n    for i in demands:\n        model.addConstr(sum(x[i, k] for k in range(max_containers))\n                        >= demands[i],\n                        name=f'demand_{i}')\n\n    # Capacity and minimum load constraints\n    for k in range(max_containers):\n        # Capacity constraint\n        model.addConstr(sum(weights[i] * x[i, k] for i in demands)\n                        <= 60 * y[k],\n                        name=f'capacity_{k}')\n        # Minimum load constraint\n        model.addConstr(sum(weights[i] * x[i, k] for i in demands)\n                        >= 18 * y[k],\n                        name=f'min_load_{k}')\n        # D goods minimum per container\n        model.addConstr(x['D', k] >= 12 * y[k], name=f'D_min_{k}')\n        # A and C packaging constraints\n        # If A is loaded, at least 1 unit of C\n        model.addConstr(x['A', k] <= M * z_A[k], name=f'A_load_indicator_{k}')\n        model.addConstr(x['C', k] >= z_A[k], name=f'C_condition_{k}')\n\n    # Optional: limit goods to their total demand\n    for i in demands:\n        for k in range(max_containers):\n            model.addConstr(x[i, k] <= demands[i], name=f'limit_{i}_{k}')\n\n    # Optimize\n    model.optimize()\n\n    # Check feasibility and return the minimal number of containers\n    if model.status == GRB.OPTIMAL:\n        total_containers = sum(y[k].X for k in range(max_containers))\n        return total_containers\n    else:\n        return None\nif __name__ == \"__main__\":\n    result = optimize_container_usage()\n    if result is not None:\n        print(f\"Optimal number of containers used: {result}\")\n    else:\n        print(\"No feasible solution found.\")",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B034",
  "description": "A fabric dyeing plant has 3 dyeing vats. Each batch of fabric must be dyed in sequence in each vat: first, the second, and third vats. The plant must color five batches of fabric of different sizes. The time required in hours to dye batch $i$ in vat $j$ is given in the following matrix:\n\n$$\n\\left(\\begin{array}{ccc}\n3 & 1 & 1 \\\\\n2 & 1.5 & 1 \\\\\n3 & 1.2 & 1.3 \\\\\n2 & 2 & 2 \\\\\n2.1 & 2 & 3\n\\end{array}\\right)\n$$\n\nSchedule the dyeing operations in the vats to minimize the completion time of the last batch.",
  "ground_truth": 14.1,
  "formulation": null,
  "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_dyeing_plant_scheduling():\n    \"\"\"\n    Solves the dyeing plant scheduling problem to minimize the makespan (completion time of the last batch).\n    This is a flow shop scheduling problem.\n    \"\"\"\n    try:\n        # --- Data ---\n        # Processing times p[i][j] for batch i on vat j (hours)\n        # Rows: Batches (0 to 4), Columns: Vats (0 to 2)\n        processing_times = [\n            [3, 1, 1],  # Batch 0\n            [2, 1.5, 1],  # Batch 1\n            [3, 1.2, 1.3],  # Batch 2\n            [2, 2, 2],  # Batch 3\n            [2.1, 2, 3]  # Batch 4\n        ]\n\n        num_batches = len(processing_times)\n        num_vats = len(processing_times[0])\n\n        batches = range(num_batches)\n        vats = range(num_vats)\n\n        # Calculate Big-M: Sum of all processing times is a safe upper bound for L\n        # and also an upper bound for any start time or makespan.\n        L = sum(sum(row)\n                for row in processing_times) * 2  # A sufficiently large number\n\n        # --- Create a new model ---\n        model = gp.Model(\"DyeingPlantScheduling\")\n\n        # --- Decision Variables ---\n        # s[i,j]: start time of batch i on vat j\n        s = model.addVars(batches,\n                          vats,\n                          name=\"s\",\n                          lb=0.0,\n                          vtype=GRB.CONTINUOUS)\n\n        # C_max: makespan (completion time of the last batch on the last vat)\n        C_max = model.addVar(name=\"C_max\", lb=0.0, vtype=GRB.CONTINUOUS)\n\n        # x[i,k,j]: binary variable, 1 if batch i precedes batch k on vat j, 0 otherwise\n        # Defined for i < k to avoid redundant pairs\n        x = {}\n        for j in vats:\n            for i in batches:\n                for k in batches:\n                    if i < k:\n                        x[i, k, j] = model.addVar(vtype=GRB.BINARY,\n                                                  name=f\"x_{i}_{k}_{j}\")\n\n        # --- Objective Function ---\n        # Minimize the makespan\n        model.setObjective(C_max, GRB.MINIMIZE)\n\n        # --- Constraints ---\n        # 1. Job Precedence Constraints (operations within the same batch)\n        # s_ij >= s_i,(j-1) + p_i,(j-1)\n        for i in batches:\n            for j in vats:\n                if j > 0:  # For vats 1 and 2 (0-indexed)\n                    model.addConstr(s[i, j] >= s[i, j - 1] +\n                                    processing_times[i][j - 1],\n                                    name=f\"JobPrecedence_b{i}_v{j}\")\n\n        # 2. Machine Capacity Constraints (Disjunctive constraints for operations on the same vat)\n        # For each vat j, and for each pair of batches i, k where i < k:\n        # s_kj >= s_ij + p_ij - L * (1 - x_ikj)\n        # s_ij >= s_kj + p_kj - L * x_ikj\n        for j in vats:\n            for i in batches:\n                for k in batches:\n                    if i < k:\n                        model.addConstr(s[k, j]\n                                        >= s[i, j] + processing_times[i][j] -\n                                        L * (1 - x[i, k, j]),\n                                        name=f\"MachineCap1_v{j}_b{i}_b{k}\")\n                        model.addConstr(s[i, j]\n                                        >= s[k, j] + processing_times[k][j] -\n                                        L * x[i, k, j],\n                                        name=f\"MachineCap2_v{j}_b{i}_b{k}\")\n\n        # 3. Makespan Definition\n        # C_max >= completion time of batch i on the last vat\n        # C_max >= s_i,(M-1) + p_i,(M-1)\n        last_vat_idx = num_vats - 1\n        for i in batches:\n            model.addConstr(C_max >= s[i, last_vat_idx] +\n                            processing_times[i][last_vat_idx],\n                            name=f\"Makespan_b{i}\")\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n        model.setParam('MIPGap',\n                       0.01)  # Set a MIP gap for faster convergence if needed\n        model.setParam('TimeLimit',\n                       120)  # Set a time limit (e.g., 120 seconds)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL or model.status == GRB.TIME_LIMIT and model.SolCount > 0:\n            if model.status == GRB.TIME_LIMIT:\n                print(\n                    \"Optimal solution not found within time limit. Displaying best solution found.\"\n                )\n            else:\n                print(\"Optimal solution found.\")\n\n            print(f\"\\nMinimum Makespan (C_max): {C_max.X:.2f} hours\")\n\n            print(\"\\nSchedule (Start Times s_ij):\")\n            for i in batches:\n                print(f\"  Batch {i+1}:\")\n                for j in vats:\n                    completion_time = s[i, j].X + processing_times[i][j]\n                    print(\n                        f\"    Vat {j+1}: Start = {s[i,j].X:.2f}, End = {completion_time:.2f} (Duration: {processing_times[i][j]})\"\n                    )\n\n            print(\"\\nSequence on Vats (derived from start times):\")\n            for j in vats:\n                vat_schedule = []\n                for i in batches:\n                    vat_schedule.append({\n                        'batch': i + 1,\n                        'start_time': s[i, j].X,\n                        'proc_time': processing_times[i][j]\n                    })\n\n                # Sort batches by start time on this vat\n                vat_schedule.sort(key=lambda e: e['start_time'])\n\n                sequence_str = \" -> \".join([\n                    f\"B{e['batch']}({e['start_time']:.2f}-{e['start_time']+e['proc_time']:.2f})\"\n                    for e in vat_schedule\n                ])\n                print(f\"  Vat {j+1} Sequence: {sequence_str}\")\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\"Model is infeasible. Check constraints and data.\")\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            # model.computeIIS()\n            # model.write(\"dyeing_plant_iis.ilp\")\n            # print(\"IIS written to dyeing_plant_iis.ilp.\")\n        elif model.status == GRB.TIME_LIMIT and model.SolCount == 0:\n            print(\"No solution found within the time limit.\")\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_dyeing_plant_scheduling()",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B036",
  "description": "A factory produces two types of microcomputers, A and B. Each type of microcomputer requires the same two production processes. The processing time, profit from sales, and the maximum weekly processing capacity for each type are shown in Table 3.1.\n\nTable 3.1\n\n| Process | Model |  | Maximum Weekly Processing Capacity |\n| :---: | :---: | :---: | :---: |\n|  | $\\\\mathrm{A}$ | $\\\\mathrm{B}$ |  |\n| I (hours / unit) | 4 | 6 | 150 |\n| II (hours / unit) | 3 | 2 | 70 |\n| Profit ($ per unit) | 300 | 450 |  |\n\nThe expected values for the factory's operational goals are as follows:\n\n$p_{1}$: The total weekly profit must not be less than $10,000.\n\n$p_{2}$: Due to contractual requirements, at least 10 units of Model A and at least 15 units of Model B must be produced per week.\n\n$p_{3}$: The weekly production time for Process I should be exactly 150 hours, and the production time for Process II should be fully utilized, with potential overtime if necessary.\n\nTry to establish the mathematical programming model for this problem.",
  "ground_truth": 11250.0,
  "formulation": null,
  "correct_program": "def optimize_microcomputers():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"Microcomputers_Production\")\n\n    # Decision variables\n    x_A = m.addVar(name=\"x_A\", lb=10, ub=150)  # at least 10, at most 150\n    x_B = m.addVar(name=\"x_B\", lb=15, ub=70)  # at least 15, at most 70\n\n    # Set the objective: maximize profit\n    m.setObjective(300 * x_A + 450 * x_B, GRB.MAXIMIZE)\n\n    # Add constraints\n    # Process I: exactly 150 hours\n    m.addConstr(4 * x_A + 6 * x_B == 150, name=\"Process_I\")\n    # Process II: exactly 70 hours\n    m.addConstr(3 * x_A + 2 * x_B == 70, name=\"Process_II\")\n    # Profit constraint: at least $10,000\n    m.addConstr(300 * x_A + 450 * x_B >= 10000, name=\"Profit_minimum\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        return m.objVal\n    else:\n        return None\nif __name__ == \"__main__\":\n    result = optimize_microcomputers()\n    if result is not None:\n        print(f\"Optimal total profit: {result}\")\n    else:\n        print(\"No feasible solution found.\")",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B037",
  "description": "There are three different products to be processed on three machine tools. Each product must first be processed on machine 1, then sequentially on machines 2 and 3. The order of processing the three products on each machine should remain the same. Assuming $t_{ij}$ represents the time to process the $i$-th product on the $j$-th machine, how should the schedule be arranged to minimize the total processing cycle for the three products? The timetable is as follows:\n| Product | Machine 1 | Machine 2 | Machine 3 |\n|---------|-----------|-----------|-----------|\n| Product 1 | 2           | 3           | 1           |\n| Product 2 | 4           | 2           | 3           |\n| Product 3 | 3           | 5           | 2           |",
  "ground_truth": 14.0,
  "formulation": null,
  "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_permutation_flow_shop():\n    \"\"\"\n    Solves a 3-product, 3-machine permutation flow shop scheduling problem\n    to minimize the makespan (total processing cycle).\n    \"\"\"\n    try:\n        # --- Data ---\n        # Processing times: t[product_idx][machine_idx]\n        # Product 1 (idx 0), Product 2 (idx 1), Product 3 (idx 2)\n        # Machine 1 (idx 0), Machine 2 (idx 1), Machine 3 (idx 2)\n        processing_times_data = [\n            [2, 3, 1],  # Product 1\n            [4, 2, 3],  # Product 2\n            [3, 5, 2]  # Product 3\n        ]\n\n        num_products = len(processing_times_data)\n        num_machines = len(processing_times_data[0])\n\n        products = range(num_products)  # Indices {0, 1, 2}\n        machines = range(num_machines)  # Indices {0, 1, 2}\n        positions = range(num_products)  # Sequence positions {0, 1, 2}\n\n        # --- Create Gurobi Model ---\n        model = gp.Model(\"PermutationFlowShop\")\n\n        # --- Decision Variables ---\n        # z[p,k]: 1 if product p is in k-th sequence position, 0 otherwise\n        z = model.addVars(products, positions, vtype=GRB.BINARY, name=\"z\")\n\n        # S[k,m]: Start time of the product in k-th sequence position on machine m\n        S = model.addVars(positions,\n                          machines,\n                          vtype=GRB.CONTINUOUS,\n                          name=\"S\",\n                          lb=0.0)\n\n        # C_max: Makespan (total processing cycle)\n        C_max = model.addVar(vtype=GRB.CONTINUOUS, name=\"C_max\", lb=0.0)\n\n        # --- Objective Function: Minimize Makespan ---\n        model.setObjective(C_max, GRB.MINIMIZE)\n\n        # --- Constraints ---\n        # 1. Assignment Constraints:\n        # Each product p is assigned to exactly one position k\n        for p in products:\n            model.addConstr(gp.quicksum(z[p, k] for k in positions) == 1,\n                            name=f\"ProductPos_{p}\")\n\n        # Each position k is filled by exactly one product p\n        for k in positions:\n            model.addConstr(gp.quicksum(z[p, k] for p in products) == 1,\n                            name=f\"PosProduct_{k}\")\n\n        # 2. Scheduling Constraints:\n        # PT[k,m] = processing time of product in k-th position on machine m\n        # This is not a variable but an expression used in constraints.\n\n        for k in positions:\n            for m in machines:\n                # Processing time of the job in k-th position on machine m\n                pt_km = gp.quicksum(z[p, k] * processing_times_data[p][m]\n                                    for p in products)\n\n                # Constraint for job processing sequence (same product, different machines)\n                if m > 0:\n                    # Processing time of the job in k-th position on machine m-1\n                    pt_k_m_minus_1 = gp.quicksum(\n                        z[p, k] * processing_times_data[p][m - 1]\n                        for p in products)\n                    model.addConstr(S[k, m] >= S[k, m - 1] + pt_k_m_minus_1,\n                                    name=f\"JobSeq_pos{k}_mach{m}\")\n\n                # Constraint for machine processing sequence (same machine, different products)\n                if k > 0:\n                    # Processing time of the job in (k-1)-th position on machine m\n                    pt_k_minus_1_m = gp.quicksum(z[p, k - 1] *\n                                                 processing_times_data[p][m]\n                                                 for p in products)\n                    model.addConstr(S[k, m] >= S[k - 1, m] + pt_k_minus_1_m,\n                                    name=f\"MachSeq_pos{k}_mach{m}\")\n\n        # The start time of the first product (position 0) on the first machine (machine 0)\n        # S[0,0] >= 0 is already handled by lb=0.0.\n        # We can fix it to 0 if desired: S[0,0].ub = 0 or model.addConstr(S[0,0] == 0)\n\n        # 3. Makespan Definition:\n        # C_max >= Completion time of the last product (pos N-1) on the last machine (mach NM-1)\n        last_pos = num_products - 1\n        last_mach = num_machines - 1\n        pt_last_job_last_machine = gp.quicksum(\n            z[p, last_pos] * processing_times_data[p][last_mach]\n            for p in products)\n        model.addConstr(C_max\n                        >= S[last_pos, last_mach] + pt_last_job_last_machine,\n                        name=\"MakespanDef\")\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal schedule found.\")\n            print(\n                f\"Minimum Total Processing Cycle (Makespan): {C_max.X:.2f} hours\"\n            )\n\n            print(\"\\nOptimal Product Sequence:\")\n            optimal_sequence_indices = [0] * num_products\n            for p in products:\n                for k in positions:\n                    if z[p, k].X > 0.5:  # Check if z[p,k] is 1\n                        optimal_sequence_indices[\n                            k] = p + 1  # Store product number (1-indexed)\n            print(\" -> \".join(map(str, optimal_sequence_indices)))\n\n            print(\n                \"\\nDetailed Schedule (Start Times S_km for product in k-th position on machine m):\"\n            )\n            print(\n                \"Pos = Position in Sequence, P# = Product Number, M# = Machine Number\"\n            )\n            for k in positions:\n                actual_product_idx = -1\n                for p_idx in products:\n                    if z[p_idx, k].X > 0.5:\n                        actual_product_idx = p_idx\n                        break\n\n                print(\n                    f\"\\n  Product at Sequence Position {k+1} (Actual Product {actual_product_idx+1}):\"\n                )\n                for m in machines:\n                    pt_val = processing_times_data[actual_product_idx][m]\n                    completion_time = S[k, m].X + pt_val\n                    print(\n                        f\"    Machine {m+1}: Start = {S[k,m].X:.2f}, Processing Time = {pt_val:.2f}, Completion = {completion_time:.2f}\"\n                    )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\"Model is infeasible. Check constraints and data.\")\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_permutation_flow_shop()",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B038",
  "description": "A company plans to transport goods between the city and the suburb and needs to choose the most environmentally friendly transportation method. The company can choose from the following three methods: motorcycle, small truck, and large truck. Each motorcycle trip produces 40 units of pollution, each small truck trip produces 70 units of pollution, and each large truck trip produces 100 units of pollution. The company's goal is to minimize total pollution.\n\nThe company can only choose two out of these three transportation methods.\n\nDue to certain road restrictions, the number of motorcycle trips cannot exceed 8.\n\nEach motorcycle trip can transport 10 units of products, each small truck trip can transport 20 units of products, and each large truck trip can transport 50 units of products. The company needs to transport at least 300 units of products.\n\nThe total number of trips must be less than or equal to 20.",
  "ground_truth": 600.0,
  "formulation": null,
  "correct_program": "def minimize_pollution(M=20):\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    model = Model(\"Minimize Pollution\")\n\n    # Decision variables\n    y_m = model.addVar(vtype=GRB.BINARY, name=\"motorcycle_method\")\n    y_s = model.addVar(vtype=GRB.BINARY, name=\"small_truck_method\")\n    y_l = model.addVar(vtype=GRB.BINARY, name=\"large_truck_method\")\n\n    x_m = model.addVar(vtype=GRB.INTEGER, lb=0, name=\"motorcycle_trips\")\n    x_s = model.addVar(vtype=GRB.INTEGER, lb=0, name=\"small_truck_trips\")\n    x_l = model.addVar(vtype=GRB.INTEGER, lb=0, name=\"large_truck_trips\")\n\n    # Set objective: minimize total pollution\n    model.setObjective(40 * x_m + 70 * x_s + 100 * x_l, GRB.MINIMIZE)\n\n    # Constraints\n    model.addConstr(y_m + y_s + y_l == 2, \"Method_Selection\")\n    model.addConstr(x_m <= 8, \"Motorcycle_Trip_Limit\")\n    model.addConstr(x_m <= M * y_m, \"Motorcycle_Method_Activation\")\n    model.addConstr(x_s <= M * y_s, \"SmallTruck_Method_Activation\")\n    model.addConstr(x_l <= M * y_l, \"LargeTruck_Method_Activation\")\n    model.addConstr(10 * x_m + 20 * x_s + 50 * x_l >= 300,\n                    \"Transport_Requirement\")\n    model.addConstr(x_m + x_s + x_l <= 20, \"Total_Trips_Limit\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        return model.objVal\n    else:\n        return None\nif __name__ == \"__main__\":\n    result = minimize_pollution()\n    if result is not None:\n        print(f\"Optimal total pollution: {result}\")\n    else:\n        print(\"No feasible solution found.\")",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B039",
  "description": "The independent country of Carelland mainly exports four commodities: steel, engines, electronic components, and plastic. Carelland's Minister of Finance (i.e., Minister of Economy) wants to maximize exports and minimize imports. The unit prices of steel, engines, electronics, and plastic on the world market are, in local currency (Klunz), 500, 1500, 300, 1200 respectively. Producing 1 unit of steel requires 0.02 units of engines, 0.01 units of plastic, 250 Klunz of other imported goods, and 6 person-months of labor. Producing 1 unit of engines requires 0.8 units of steel, 0.15 units of electronic components, 0.11 units of plastic, 300 Klunz of imported goods, and 1 person-year. One unit of electronics requires: 0.01 units of steel, 0.01 units of engines, 0.05 units of plastic, 50 Klunz of imported goods, and 6 person-months of labor. One unit of plastic requires: 0.03 units of engines, 0.2 units of steel, 0.05 units of electronic components, 300 Klunz of imported goods, and 2 person-years. Engine production is limited to 650000 units, and plastic production is limited to 60000 units. The total available labor force per year is 830000 person-months. Write a mathematical program to maximize domestic GDP and solve the problem using AMPL.",
  "ground_truth": 36288567.04,
  "formulation": null,
  "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"Carelland_GDP_Maximization\")\n\n# Define the commodities\ncommodities = [\"steel\", \"engines\", \"electronics\", \"plastic\"]\n\n# Unit prices in local currency (Klunz)\nunit_price = {\n    \"steel\": 500,\n    \"engines\": 1500,\n    \"electronics\": 300,\n    \"plastic\": 1200\n}\n\n# Input requirements matrix:\n# input_requirements[output][input] = amount of input needed to produce 1 unit of output\ninput_requirements = {\n    \"steel\": {\n        \"engines\": 0.02,\n        \"plastic\": 0.01,\n        \"steel\": 0,\n        \"electronics\": 0\n    },\n    \"engines\": {\n        \"steel\": 0.8,\n        \"electronics\": 0.15,\n        \"plastic\": 0.11,\n        \"engines\": 0\n    },\n    \"electronics\": {\n        \"steel\": 0.01,\n        \"engines\": 0.01,\n        \"plastic\": 0.05,\n        \"electronics\": 0\n    },\n    \"plastic\": {\n        \"steel\": 0.2,\n        \"engines\": 0.03,\n        \"electronics\": 0.05,\n        \"plastic\": 0\n    }\n}\n\n# Additional imported goods required (in Klunz)\nimported_goods = {\n    \"steel\": 250,\n    \"engines\": 300,\n    \"electronics\": 50,\n    \"plastic\": 300\n}\n\n# Labor requirements (in person-months)\nlabor_requirements = {\n    \"steel\": 6,  # 6 person-months\n    \"engines\": 12,  # 1 person-year = 12 person-months\n    \"electronics\": 6,  # 6 person-months\n    \"plastic\": 24  # 2 person-years = 24 person-months\n}\n\n# Production limits\nproduction_limits = {\"engines\": 650000, \"plastic\": 60000}\n\n# Total available labor force (in person-months)\ntotal_labor = 830000\n\n# Decision variables: quantity of each commodity to produce\nx = {}\nfor commodity in commodities:\n    x[commodity] = model.addVar(vtype=GRB.CONTINUOUS,\n                                name=f\"produce_{commodity}\")\n\n# Net export variables (production minus domestic consumption)\nnet_export = {}\nfor commodity in commodities:\n    net_export[commodity] = model.addVar(vtype=GRB.CONTINUOUS,\n                                         name=f\"net_export_{commodity}\")\n\n# Add constraints\n# 1. Commodity balance constraints\nfor commodity in commodities:\n    # Net export = production - domestic consumption\n    model.addConstr(\n        net_export[commodity] == x[commodity] -\n        gp.quicksum(input_requirements[other][commodity] * x[other]\n                    for other in commodities), f\"balance_{commodity}\")\n\n# 2. Production limit constraints\nfor commodity, limit in production_limits.items():\n    model.addConstr(x[commodity] <= limit, f\"limit_{commodity}\")\n\n# 3. Labor constraint\nmodel.addConstr(\n    gp.quicksum(labor_requirements[commodity] * x[commodity]\n                for commodity in commodities) <= total_labor,\n    \"labor_constraint\")\n\n# 4. Non-negativity constraint for net exports (assuming we can't import these commodities)\nfor commodity in commodities:\n    model.addConstr(net_export[commodity] >= 0,\n                    f\"non_negative_export_{commodity}\")\n\n# Objective function: Maximize GDP (value of production minus cost of imported goods)\ngdp = gp.quicksum(unit_price[commodity] * net_export[commodity]\n                  for commodity in commodities) - gp.quicksum(\n                      imported_goods[commodity] * x[commodity]\n                      for commodity in commodities)\n\nmodel.setObjective(gdp, GRB.MAXIMIZE)\n\n# Optimize the model\nmodel.optimize()\n\n# Print the results\nprint(\"\\n=== OPTIMAL SOLUTION ===\")\nif model.status == GRB.OPTIMAL:\n    print(\"\\nProduction Quantities:\")\n    for commodity in commodities:\n        print(f\"{commodity.capitalize()}: {x[commodity].X:.2f} units\")\n\n    print(\"\\nNet Exports:\")\n    for commodity in commodities:\n        print(f\"{commodity.capitalize()}: {net_export[commodity].X:.2f} units\")\n\n    print(\"\\nCost of Imported Goods:\")\n    total_import_cost = sum(imported_goods[commodity] * x[commodity].X\n                            for commodity in commodities)\n    print(f\"Total: {total_import_cost:.2f} Klunz\")\n\n    print(\"\\nValue of Exported Goods:\")\n    total_export_value = sum(unit_price[commodity] * net_export[commodity].X\n                             for commodity in commodities)\n    print(f\"Total: {total_export_value:.2f} Klunz\")\n\n    print(f\"\\nMaximum GDP: {model.ObjVal:.2f} Klunz\")\n\n    # Calculate and print resource utilization\n    labor_used = sum(labor_requirements[commodity] * x[commodity].X\n                     for commodity in commodities)\n    print(\n        f\"\\nLabor Used: {labor_used:.2f} person-months (out of {total_labor})\")\n\n    for commodity, limit in production_limits.items():\n        utilization = (x[commodity].X / limit) * 100 if limit > 0 else 0\n        print(\n            f\"{commodity.capitalize()} Production Capacity Used: {utilization:.2f}%\"\n        )\nelse:\n    print(f\"Optimization failed. Status code: {model.status}\")",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B040",
  "description": "A person has a fund of 500,000 yuan and the following investment projects available in the next three years:\n\n(1) Investment can be made at the beginning of each year within three years, and the annual profit is 20% of the investment amount.\n\n(2) Investment is only allowed at the beginning of the first year, and can be recovered at the end of the second year, with the total principal and interest being 150% of the investment amount. However, this type of investment is limited to no more than 120,000 yuan.\n\n(3) Investment at the beginning of the second year, recoverable at the end of the second year, with the total principal and interest being 160% of the investment amount. This type of investment is limited to 150,000 yuan.\n\n(4) Investment is allowed at the beginning of the third year, recoverable in one year, with a profit of 40%, and the investment limit is 100,000 yuan.\n\nDetermine an investment plan for the person that maximizes the total principal and interest by the end of the third year.",
  "ground_truth": 964640.0,
  "formulation": null,
  "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_investment_problem_new_scenario():\n    \"\"\"\n    Solves the multi-period investment problem to maximize\n    the total principal and interest at the end of the third year.\n    \"\"\"\n    try:\n        # Initial capital\n        K0 = 500000.0\n\n        # Create a new model\n        model = gp.Model(\"MultiPeriodInvestment_NewScenario\")\n\n        # --- Decision Variables ---\n        # x_ij: amount invested in project i at the start of year j\n\n        # Project 1: Annual, 20% profit (return 1.2)\n        x11 = model.addVar(name=\"x11_P1_Y1\", lb=0.0,\n                           vtype=GRB.CONTINUOUS)  # P1, Start of Year 1\n        x12 = model.addVar(name=\"x12_P1_Y2\", lb=0.0,\n                           vtype=GRB.CONTINUOUS)  # P1, Start of Year 2\n        x13 = model.addVar(name=\"x13_P1_Y3\", lb=0.0,\n                           vtype=GRB.CONTINUOUS)  # P1, Start of Year 3\n\n        # Project 2: Start Y1, 2-year, 150% total return (factor 1.5), limit 120k\n        # Matures EOY2 (SOY3)\n        x21 = model.addVar(name=\"x21_P2_Y1\", lb=0.0, vtype=GRB.CONTINUOUS)\n\n        # Project 3: Start Y2, 1-year, 160% total return (factor 1.6), limit 150k\n        # Matures EOY2 (SOY3)\n        x32 = model.addVar(name=\"x32_P3_Y2\", lb=0.0, vtype=GRB.CONTINUOUS)\n\n        # Project 4: Start Y3, 1-year, 40% profit (return 1.4), limit 100k\n        # Matures EOY3\n        x43 = model.addVar(name=\"x43_P4_Y3\", lb=0.0, vtype=GRB.CONTINUOUS)\n\n        # --- Objective Function ---\n        # Maximize total principal and interest at the end of Year 3.\n        # Z = K0 + 0.2*x11 + 0.5*x21 + 0.2*x12 + 0.6*x32 + 0.2*x13 + 0.4*x43\n        objective = K0 + 0.2 * x11 + 0.5 * x21 + 0.2 * x12 + 0.6 * x32 + 0.2 * x13 + 0.4 * x43\n        model.setObjective(objective, GRB.MAXIMIZE)\n\n        # --- Constraints ---\n        # 1. Cash Availability at Start of Year 1\n        # Investments_SOY1 <= K0\n        model.addConstr(x11 + x21 <= K0, \"Cash_SOY1\")\n\n        # 2. Cash Availability at Start of Year 2\n        # Investments_SOY2 <= K0 + 0.2*x11 - x21\n        # x12 + x32 - 0.2*x11 + x21 <= K0\n        model.addConstr(x12 + x32 - 0.2 * x11 + x21 <= K0, \"Cash_SOY2\")\n\n        # 3. Cash Availability at Start of Year 3\n        # Investments_SOY3 <= K0 + 0.2*x11 + 0.5*x21 + 0.2*x12 + 0.6*x32\n        # x13 + x43 - 0.2*x11 - 0.5*x21 - 0.2*x12 - 0.6*x32 <= K0\n        model.addConstr(\n            x13 + x43 - 0.2 * x11 - 0.5 * x21 - 0.2 * x12 - 0.6 * x32 <= K0,\n            \"Cash_SOY3\")\n\n        # 4. Investment Limit for Project 2\n        model.addConstr(x21 <= 120000, \"Limit_P2\")\n\n        # 5. Investment Limit for Project 3\n        model.addConstr(x32 <= 150000, \"Limit_P3\")\n\n        # 6. Investment Limit for Project 4\n        model.addConstr(x43 <= 100000, \"Limit_P4\")\n\n        # Suppress Gurobi output to console\n        model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal investment plan found.\")\n            print(\n                f\"Maximum Principal and Interest at End of Year 3: {model.objVal:.2f} yuan\"\n            )\n\n            total_profit = model.objVal - K0\n            print(f\"Total Profit over 3 years: {total_profit:.2f} yuan\")\n\n            print(\"\\nInvestment Plan Details (yuan):\")\n            # Start of Year 1\n            print(\"  Start of Year 1:\")\n            print(f\"    Project 1 (Annual, 20% profit, x11): {x11.X:.2f}\")\n            print(\n                f\"    Project 2 (2-year, 150% return, limit 120k, x21): {x21.X:.2f}\"\n            )\n            cash_soy1_invested = x11.X + x21.X\n            cash_soy1_uninvested = K0 - cash_soy1_invested\n            print(f\"    Total invested at SOY1: {cash_soy1_invested:.2f}\")\n            print(\n                f\"    Uninvested cash carried from SOY1: {cash_soy1_uninvested:.2f}\"\n            )\n\n            # Start of Year 2\n            cash_available_soy2 = K0 + 0.2 * x11.X - x21.X\n            print(\n                f\"\\n  Cash available at Start of Year 2: {cash_available_soy2:.2f}\"\n            )\n            print(\"  Start of Year 2:\")\n            print(f\"    Project 1 (Annual, 20% profit, x12): {x12.X:.2f}\")\n            print(\n                f\"    Project 3 (1-year, 160% return, limit 150k, x32): {x32.X:.2f}\"\n            )\n            cash_soy2_invested = x12.X + x32.X\n            cash_soy2_uninvested = cash_available_soy2 - cash_soy2_invested\n            print(f\"    Total invested at SOY2: {cash_soy2_invested:.2f}\")\n            print(\n                f\"    Uninvested cash carried from SOY2: {cash_soy2_uninvested:.2f}\"\n            )\n\n            # Start of Year 3\n            cash_available_soy3 = K0 + 0.2 * x11.X + 0.5 * x21.X + 0.2 * x12.X + 0.6 * x32.X\n            print(\n                f\"\\n  Cash available at Start of Year 3: {cash_available_soy3:.2f}\"\n            )\n            print(\"  Start of Year 3:\")\n            print(f\"    Project 1 (Annual, 20% profit, x13): {x13.X:.2f}\")\n            print(\n                f\"    Project 4 (1-year, 40% profit, limit 100k, x43): {x43.X:.2f}\"\n            )\n            cash_soy3_invested = x13.X + x43.X\n            cash_soy3_uninvested = cash_available_soy3 - cash_soy3_invested\n            print(f\"    Total invested at SOY3: {cash_soy3_invested:.2f}\")\n            print(\n                f\"    Uninvested cash from SOY3 (forms part of EOY3 total): {cash_soy3_uninvested:.2f}\"\n            )\n\n        else:\n            print(\"No optimal solution found. Status code:\", model.status)\n\n    except gp.GurobiError as e:\n        print(f\"Error code {e.errno}: {e}\")\n    except AttributeError:\n        print(\n            \"Encountered an attribute error. Gurobi might not be installed or licensed correctly.\"\n        )\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_investment_problem_new_scenario()",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B041",
  "description": "Two steel furnaces at a steel plant each use two methods of steelmaking simultaneously. The first method takes $a=2$ hours per furnace and costs $m=50$ in fuel expenses; the second method takes $b=3$ hours per furnace and costs $n=70$ in fuel expenses. Assuming each furnace produces $k=10$ tons of steel regardless of the method used, and that at least $d=30$ tons of steel must be produced within $c=12$ hours, how should these two methods be allocated to minimize fuel expenses? Formulate this problem as a linear programming model.",
  "ground_truth": 150.0,
  "formulation": null,
  "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_steelmaking_allocation():\n    \"\"\"\n    Solves the steelmaking allocation problem to minimize fuel expenses\n    subject to furnace time and steel production constraints.\n    \"\"\"\n    try:\n        # --- Parameters ---\n        # Method 1\n        time_m1 = 2.0  # hours per operation\n        cost_m1 = 50.0  # fuel expense per operation\n\n        # Method 2\n        time_m2 = 3.0  # hours per operation\n        cost_m2 = 70.0  # fuel expense per operation\n\n        # Production\n        steel_per_op = 10.0  # tons per operation (same for both methods)\n\n        # Constraints\n        min_total_steel = 30.0  # tons\n        max_furnace_hours = 12.0  # hours available per furnace\n\n        num_furnaces = 2\n        num_methods = 2\n\n        # --- Create Gurobi Model ---\n        model = gp.Model(\"Steelmaking_Allocation\")\n\n        # --- Decision Variables ---\n        # x[f,m]: number of times furnace f uses method m\n        # f=0 for Furnace 1, f=1 for Furnace 2\n        # m=0 for Method 1, m=1 for Method 2\n        x = model.addVars(num_furnaces,\n                          num_methods,\n                          name=\"x\",\n                          lb=0.0,\n                          vtype=GRB.CONTINUOUS)\n\n        # For easier reference using problem's notation:\n        # x11 = x[0,0] (Furnace 1, Method 1)\n        # x12 = x[0,1] (Furnace 1, Method 2)\n        # x21 = x[1,0] (Furnace 2, Method 1)\n        # x22 = x[1,1] (Furnace 2, Method 2)\n\n        # --- Objective Function: Minimize Total Fuel Expenses ---\n        objective = cost_m1 * (x[0,0] + x[1,0]) + \\\n                    cost_m2 * (x[0,1] + x[1,1])\n        model.setObjective(objective, GRB.MINIMIZE)\n\n        # --- Constraints ---\n        # 1. Time Constraint for Furnace 1 (f=0)\n        model.addConstr(time_m1 * x[0, 0] + time_m2 * x[0, 1]\n                        <= max_furnace_hours,\n                        name=\"Time_Furnace1\")\n\n        # 2. Time Constraint for Furnace 2 (f=1)\n        model.addConstr(time_m1 * x[1, 0] + time_m2 * x[1, 1]\n                        <= max_furnace_hours,\n                        name=\"Time_Furnace2\")\n\n        # 3. Steel Production Constraint\n        total_steel_produced = steel_per_op * (x[0, 0] + x[0, 1] + x[1, 0] +\n                                               x[1, 1])\n        model.addConstr(total_steel_produced >= min_total_steel,\n                        name=\"Min_Steel_Production\")\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal allocation found.\")\n            print(f\"Minimum Total Fuel Expenses: {model.ObjVal:.2f} Klunz\")\n\n            print(\n                \"\\nOptimal Allocation (Number of times each method is used):\")\n            print(f\"  Furnace 1, Method 1 (x11): {x[0,0].X:.2f} times\")\n            print(f\"  Furnace 1, Method 2 (x12): {x[0,1].X:.2f} times\")\n            print(f\"  Furnace 2, Method 1 (x21): {x[1,0].X:.2f} times\")\n            print(f\"  Furnace 2, Method 2 (x22): {x[1,1].X:.2f} times\")\n\n            # Verification of constraints\n            print(\"\\nVerification:\")\n            f1_hours = time_m1 * x[0, 0].X + time_m2 * x[0, 1].X\n            f2_hours = time_m1 * x[1, 0].X + time_m2 * x[1, 1].X\n            print(\n                f\"  Furnace 1 Hours Used: {f1_hours:.2f} / {max_furnace_hours}\"\n            )\n            print(\n                f\"  Furnace 2 Hours Used: {f2_hours:.2f} / {max_furnace_hours}\"\n            )\n\n            total_steel = steel_per_op * (x[0, 0].X + x[0, 1].X + x[1, 0].X +\n                                          x[1, 1].X)\n            print(\n                f\"  Total Steel Produced: {total_steel:.2f} tons (Min required: {min_total_steel})\"\n            )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\"Model is infeasible. Check constraints and parameters.\")\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            # model.computeIIS()\n            # model.write(\"steel_allocation_iis.ilp\")\n            # print(\"IIS written to steel_allocation_iis.ilp\")\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_steelmaking_allocation()",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B042",
  "description": "A production base needs to extract raw materials from warehouses A and B every day for production. The required raw materials are: at least 240 pieces of raw material A, at least 80 kg of raw material B, and at least 120 tons of raw material C. It is known that: Each truck from warehouse A can transport back to the production base 4 pieces of raw material A, 2 kg of raw material B, 6 tons of raw material C, with a freight cost of 200 yuan per truck; each truck from warehouse B can transport back to the production base 7 pieces of raw material A, 2 kg of raw material B, 2 tons of raw material C per day, with a freight cost of 160 yuan per truck. Question: In order to meet production needs, how many trucks should be dispatched daily from warehouse A and warehouse B to minimize the total freight cost?",
  "ground_truth": 6800.0,
  "formulation": null,
  "correct_program": "def optimize_truck_dispatch(\n        cost_A=200,  # freight cost per truck from warehouse A\n        cost_B=160,  # freight cost per truck from warehouse B\n        min_A=240,  # minimum raw material A pieces\n        min_B=80,  # minimum raw material B kg\n        min_C=120  # minimum raw material C tons\n):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"Truck_Dispatch_Optimization\")\n\n    # Decision variables: number of trucks from warehouses A and B\n    x_A = model.addVar(vtype=GRB.INTEGER, lb=0, name=\"x_A\")\n    x_B = model.addVar(vtype=GRB.INTEGER, lb=0, name=\"x_B\")\n\n    # Set objective: minimize total freight cost\n    model.setObjective(cost_A * x_A + cost_B * x_B, GRB.MINIMIZE)\n\n    # Add constraints for raw materials\n    # Raw material A\n    model.addConstr(4 * x_A + 7 * x_B >= min_A, \"Raw_A\")\n    # Raw material B\n    model.addConstr(2 * x_A + 2 * x_B >= min_B, \"Raw_B\")\n    # Raw material C\n    model.addConstr(6 * x_A + 2 * x_B >= min_C, \"Raw_C\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the optimal total freight cost\n        return model.objVal\n    else:\n        # No feasible solution found\n        return None\nif __name__ == \"__main__\":\n    result = optimize_truck_dispatch()\n    if result is not None:\n        print(f\"Optimal total freight cost: {result}\")\n    else:\n        print(\"No feasible solution found.\")",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B043",
  "description": "Given that there are $m=2$ production points for a certain type of material, where the output at the $i$-th point $(i=1,2)$ is $a_i$, $a_1 = 100$, and $a_2 = 150$. This material is to be shipped to $n=2$ demand points, where the demand at the $j$-th point $(j=1, 2)$ is $b_j$, $b_1 = 80$, and $b_2 = 120$. It is known that $\\sum_i a_i \\geqslant \\sum_j b_j$. It is also known that when shipping from production points to demand points, it must pass through one of the $p=2$ intermediate marshaling stations. If the $k$-th $(k=1, 2)$ intermediate marshaling station is used, a fixed cost $f_k$ is incurred regardless of the transshipment volume, where $f_1 = 10$ and $f_2 = 15$. The $k$-th intermediate marshaling station has a maximum transshipment capacity limitation $q_k$, where $q_1 = 100$ and $q_2 = 100$. Let $c_{i k}$ and $c'_{k j}$ denote the unit transportation cost from $i$ to $k$ and from $k$ to $j$, respectively, where $c_{11}=2$, $c_{12}=3$, $c_{21}=4$, $c_{22}=1$, $c'_{11}=3$, $c'_{12}=2$, $c'_{21}=1$, and $c'_{22}=4$. Try to determine a transportation plan for this material that minimizes the total cost.",
  "ground_truth": 685.0,
  "formulation": null,
  "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_fixed_charge_transshipment():\n    \"\"\"\n    Solves a fixed-charge transshipment problem with intermediate marshaling stations.\n    The goal is to minimize total transportation and fixed operational costs.\n    \"\"\"\n    try:\n        # --- Data ---\n        # Production points (sources)\n        production_points = [1, 2]\n        supply = {1: 100, 2: 150}  # a_i\n\n        # Demand points (sinks)\n        demand_points = [1, 2]\n        demand = {1: 80, 2: 120}  # b_j\n\n        # Marshaling stations\n        marshaling_stations = [1, 2]\n        fixed_costs = {1: 10, 2: 15}  # f_k\n        station_capacities = {1: 100, 2: 100}  # q_k\n\n        # Unit transportation costs from production i to station k (c_ik)\n        cost_ik = {(1, 1): 2, (1, 2): 3, (2, 1): 4, (2, 2): 1}\n\n        # Unit transportation costs from station k to demand j (c'_kj)\n        cost_kj = {(1, 1): 3, (1, 2): 2, (2, 1): 1, (2, 2): 4}\n\n        # --- Create Gurobi Model ---\n        model = gp.Model(\"FixedChargeTransshipment\")\n\n        # --- Decision Variables ---\n        # x[i,k]: amount shipped from production point i to marshaling station k\n        x = model.addVars(production_points,\n                          marshaling_stations,\n                          name=\"x\",\n                          lb=0.0,\n                          vtype=GRB.CONTINUOUS)\n\n        # y[k,j]: amount shipped from marshaling station k to demand point j\n        y = model.addVars(marshaling_stations,\n                          demand_points,\n                          name=\"y\",\n                          lb=0.0,\n                          vtype=GRB.CONTINUOUS)\n\n        # u[k]: 1 if marshaling station k is used, 0 otherwise\n        u = model.addVars(marshaling_stations, name=\"u\", vtype=GRB.BINARY)\n\n        # --- Objective Function: Minimize Total Cost ---\n        var_cost_ik = gp.quicksum(cost_ik[i, k] * x[i, k]\n                                  for i in production_points\n                                  for k in marshaling_stations)\n        var_cost_kj = gp.quicksum(cost_kj[k, j] * y[k, j]\n                                  for k in marshaling_stations\n                                  for j in demand_points)\n        total_fixed_cost = gp.quicksum(fixed_costs[k] * u[k]\n                                       for k in marshaling_stations)\n\n        model.setObjective(var_cost_ik + var_cost_kj + total_fixed_cost,\n                           GRB.MINIMIZE)\n\n        # --- Constraints ---\n        # 1. Supply Constraints: sum_k x[i,k] <= supply[i] for each i\n        for i in production_points:\n            model.addConstr(gp.quicksum(x[i, k] for k in marshaling_stations)\n                            <= supply[i],\n                            name=f\"Supply_{i}\")\n\n        # 2. Demand Constraints: sum_k y[k,j] == demand[j] for each j\n        for j in demand_points:\n            model.addConstr(gp.quicksum(\n                y[k, j] for k in marshaling_stations) == demand[j],\n                            name=f\"Demand_{j}\")\n\n        # 3. Flow Conservation at Marshaling Stations: sum_i x[i,k] == sum_j y[k,j] for each k\n        for k in marshaling_stations:\n            model.addConstr(gp.quicksum(\n                x[i, k] for i in production_points) == gp.quicksum(\n                    y[k, j] for j in demand_points),\n                            name=f\"FlowCons_Station_{k}\")\n\n        # 4. Marshaling Station Capacity and Usage: sum_i x[i,k] <= capacity[k] * u[k] for each k\n        for k in marshaling_stations:\n            model.addConstr(gp.quicksum(x[i, k] for i in production_points)\n                            <= station_capacities[k] * u[k],\n                            name=f\"Capacity_Station_{k}\")\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal transportation plan found.\")\n            print(f\"Minimum Total Cost: {model.ObjVal:.2f}\")\n\n            print(\n                \"\\nShipments from Production Points to Marshaling Stations (x_ik):\"\n            )\n            for i in production_points:\n                for k in marshaling_stations:\n                    if x[i, k].X > 1e-6:  # Print only if flow is significant\n                        print(\n                            f\"  From Production {i} to Station {k}: {x[i,k].X:.2f} units\"\n                        )\n\n            print(\n                \"\\nShipments from Marshaling Stations to Demand Points (y_kj):\"\n            )\n            for k in marshaling_stations:\n                for j in demand_points:\n                    if y[k, j].X > 1e-6:  # Print only if flow is significant\n                        print(\n                            f\"  From Station {k} to Demand {j}: {y[k,j].X:.2f} units\"\n                        )\n\n            print(\"\\nMarshaling Station Usage (u_k):\")\n            total_flow_through_station = {}\n            for k in marshaling_stations:\n                flow = sum(x[i, k].X for i in production_points)\n                total_flow_through_station[k] = flow\n                if u[k].X > 0.5:  # If station is used\n                    print(\n                        f\"  Station {k}: Used (Fixed Cost: {fixed_costs[k]}). Flow: {flow:.2f} / Capacity: {station_capacities[k]}\"\n                    )\n                else:\n                    print(f\"  Station {k}: Not Used. Flow: {flow:.2f}\")\n\n            # Verification\n            print(\"\\nVerification:\")\n            print(\"  Supply Check:\")\n            for i in production_points:\n                shipped_from_i = sum(x[i, k].X for k in marshaling_stations)\n                print(\n                    f\"    Production {i}: Shipped {shipped_from_i:.2f}, Supply {supply[i]}\"\n                )\n\n            print(\"  Demand Check:\")\n            for j in demand_points:\n                received_at_j = sum(y[k, j].X for k in marshaling_stations)\n                print(\n                    f\"    Demand {j}: Received {received_at_j:.2f}, Demand {demand[j]}\"\n                )\n\n            print(\"  Station Flow Conservation Check:\")\n            for k in marshaling_stations:\n                inflow_k = sum(x[i, k].X for i in production_points)\n                outflow_k = sum(y[k, j].X for j in demand_points)\n                print(\n                    f\"    Station {k}: Inflow={inflow_k:.2f}, Outflow={outflow_k:.2f} (Difference: {inflow_k - outflow_k:.2f})\"\n                )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\"Model is infeasible. Check constraints and parameters.\")\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            # model.computeIIS()\n            # model.write(\"transshipment_iis.ilp\")\n            # print(\"IIS written to transshipment_iis.ilp.\")\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_fixed_charge_transshipment()",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B046",
  "description": "A certain farm has 100 hectares of land and 15,000 yuan in funds for production development. The labor force situation on the farm is 3,500 person-days in autumn and winter, and 4,000 person-days in spring and summer. If the labor force itself is not fully utilized, they can work externally, earning 2.1 yuan/person-day in spring and summer and 1.8 yuan/person-day in autumn and winter.\n\nThe farm cultivates three types of crops: soybeans, corn, and wheat, and also raises dairy cows and chickens. Crop cultivation requires no specialized investment, but raising animals involves an investment of 400 yuan per dairy cow and 3 yuan per chicken. Raising dairy cows requires allocating 1.5 hectares of land per cow to grow feed, and involves 100 person-days in autumn and winter, and 50 person-days in spring and summer per cow. The annual net income is 400 yuan per dairy cow. Raising chickens does not use land, requires 0.6 person-days in autumn and winter, and 0.3 person-days in spring and summer per chicken. Annual net income is 2 yuan per chicken. The current chicken coop can accommodate up to 3,000 chickens, and the cow barn can accommodate up to 32 dairy cows. The labor and income requirements for the three types of crops per year are shown in Table 1-9.\n\nTable 1-9\n| Item           | Soybean | Corn | Wheat |\n|----------------|---------|------|-------|\n| Person-days (Autumn/Winter) | 20      | 35   | 10    |\n| Person-days (Spring/Summer) | 50      | 75   | 40    |\n| Annual Net Income (Yuan/hectare) | 175     | 300   | 120   |\n\nDetermine the farm's operating plan to maximize annual net income.",
  "ground_truth": 20242.0,
  "formulation": null,
  "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_farm_optimization():\n    \"\"\"\n    Solves the farm operation planning problem to maximize annual net income.\n    \"\"\"\n    try:\n        # --- Data ---\n        # Resources\n        total_land = 100  # hectares\n        total_funds = 15000  # yuan\n        labor_aw_available = 3500  # person-days Autumn/Winter\n        labor_ss_available = 4000  # person-days Spring/Summer\n\n        # External labor income (yuan/person-day)\n        income_external_labor_aw = 1.8\n        income_external_labor_ss = 2.1\n\n        # Crop data: [Labor AW, Labor SS, Net Income/hectare]\n        crop_data = {\n            'Soybean': {\n                'labor_aw': 20,\n                'labor_ss': 50,\n                'income': 175\n            },\n            'Corn': {\n                'labor_aw': 35,\n                'labor_ss': 75,\n                'income': 300\n            },\n            'Wheat': {\n                'labor_aw': 10,\n                'labor_ss': 40,\n                'income': 120\n            }\n        }\n        crops = list(crop_data.keys())\n\n        # Animal data\n        # Dairy Cow\n        cow_investment = 400  # yuan/cow\n        cow_land_feed = 1.5  # hectares/cow\n        cow_labor_aw = 100  # person-days/cow\n        cow_labor_ss = 50  # person-days/cow\n        cow_income = 400  # yuan/cow\n        cow_max_capacity = 32\n\n        # Chicken\n        chicken_investment = 3  # yuan/chicken\n        # chicken_land_feed = 0 (explicitly stated \"does not use land\")\n        chicken_labor_aw = 0.6  # person-days/chicken\n        chicken_labor_ss = 0.3  # person-days/chicken\n        chicken_income = 2  # yuan/chicken\n        chicken_max_capacity = 3000\n\n        # --- Create Gurobi Model ---\n        model = gp.Model(\"FarmOptimization\")\n\n        # --- Decision Variables ---\n        # Crop cultivation (hectares)\n        X = model.addVars(crops, name=\"X\", lb=0.0, vtype=GRB.CONTINUOUS)\n\n        # Number of animals (integer)\n        N_cow = model.addVar(name=\"N_cow\", lb=0.0, vtype=GRB.INTEGER)\n        N_chicken = model.addVar(name=\"N_chicken\", lb=0.0, vtype=GRB.INTEGER)\n\n        # External labor sold (person-days)\n        L_aw_out = model.addVar(name=\"L_aw_out\", lb=0.0, vtype=GRB.CONTINUOUS)\n        L_ss_out = model.addVar(name=\"L_ss_out\", lb=0.0, vtype=GRB.CONTINUOUS)\n\n        # --- Objective Function: Maximize Total Annual Net Income ---\n        total_income = gp.quicksum(crop_data[c]['income'] * X[c] for c in crops) + \\\n                       cow_income * N_cow + \\\n                       chicken_income * N_chicken + \\\n                       income_external_labor_aw * L_aw_out + \\\n                       income_external_labor_ss * L_ss_out\n\n        model.setObjective(total_income, GRB.MAXIMIZE)\n\n        # --- Constraints ---\n        # 1. Land Constraint\n        land_for_cows = cow_land_feed * N_cow\n        total_land_used = gp.quicksum(X[c] for c in crops) + land_for_cows\n        model.addConstr(total_land_used <= total_land, name=\"LandLimit\")\n\n        # 2. Funds Constraint\n        total_investment = cow_investment * N_cow + chicken_investment * N_chicken\n        model.addConstr(total_investment <= total_funds, name=\"FundsLimit\")\n\n        # 3. Labor Constraint (Autumn/Winter)\n        labor_aw_farm = gp.quicksum(crop_data[c]['labor_aw'] * X[c] for c in crops) + \\\n                        cow_labor_aw * N_cow + \\\n                        chicken_labor_aw * N_chicken\n        model.addConstr(labor_aw_farm + L_aw_out <= labor_aw_available,\n                        name=\"LaborAWLimit\")\n\n        # 4. Labor Constraint (Spring/Summer)\n        labor_ss_farm = gp.quicksum(crop_data[c]['labor_ss'] * X[c] for c in crops) + \\\n                        cow_labor_ss * N_cow + \\\n                        chicken_labor_ss * N_chicken\n        model.addConstr(labor_ss_farm + L_ss_out <= labor_ss_available,\n                        name=\"LaborSSLimit\")\n\n        # 5. Animal Housing Capacity Constraints\n        model.addConstr(N_cow <= cow_max_capacity, name=\"CowCapacity\")\n        model.addConstr(N_chicken <= chicken_max_capacity,\n                        name=\"ChickenCapacity\")\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal farm operating plan found.\")\n            print(f\"Maximum Annual Net Income: {model.ObjVal:.2f} Yuan\")\n\n            print(\"\\nOptimal Plan Details:\")\n            print(\"  Crops (hectares):\")\n            for c in crops:\n                if X[c].X > 1e-6:\n                    print(f\"    {c}: {X[c].X:.2f} ha\")\n\n            print(\"  Animals (number):\")\n            if N_cow.X > 1e-6:\n                print(f\"    Dairy Cows: {N_cow.X:.0f}\")\n            if N_chicken.X > 1e-6:\n                print(f\"    Chickens: {N_chicken.X:.0f}\")\n\n            print(\"  External Labor Sold (person-days):\")\n            if L_aw_out.X > 1e-6:\n                print(\n                    f\"    Autumn/Winter: {L_aw_out.X:.2f} person-days (Income: {income_external_labor_aw * L_aw_out.X:.2f} Yuan)\"\n                )\n            if L_ss_out.X > 1e-6:\n                print(\n                    f\"    Spring/Summer: {L_ss_out.X:.2f} person-days (Income: {income_external_labor_ss * L_ss_out.X:.2f} Yuan)\"\n                )\n\n            print(\"\\nResource Utilization:\")\n            print(\n                f\"  Land Used: {total_land_used.getValue():.2f} / {total_land} ha ({(total_land_used.getValue()/total_land*100) if total_land > 0 else 0:.1f}%)\"\n            )\n            print(\n                f\"  Funds Used: {total_investment.getValue():.2f} / {total_funds} Yuan ({(total_investment.getValue()/total_funds*100) if total_funds > 0 else 0:.1f}%)\"\n            )\n            print(\n                f\"  Labor Autumn/Winter Used (Farm + External): {(labor_aw_farm.getValue() + L_aw_out.X):.2f} / {labor_aw_available} person-days (Farm: {labor_aw_farm.getValue():.2f}, External: {L_aw_out.X:.2f})\"\n            )\n            print(\n                f\"  Labor Spring/Summer Used (Farm + External): {(labor_ss_farm.getValue() + L_ss_out.X):.2f} / {labor_ss_available} person-days (Farm: {labor_ss_farm.getValue():.2f}, External: {L_ss_out.X:.2f})\"\n            )\n            print(f\"  Cow Capacity Used: {N_cow.X:.0f} / {cow_max_capacity}\")\n            print(\n                f\"  Chicken Capacity Used: {N_chicken.X:.0f} / {chicken_max_capacity}\"\n            )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\"Model is infeasible. Check constraints and data.\")\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            # model.computeIIS()\n            # model.write(\"farm_optimization_iis.ilp\")\n            # print(\"IIS written to farm_optimization_iis.ilp\")\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_farm_optimization()",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B047",
  "description": "A factory produces two models of microcomputers, A and B. Each model requires the same two processes. The processing time, sales profit, and the factory’s maximum weekly processing capacity for each model are shown in Table 3.1.\n\nTable 3.1\n\n| Process | Model | | Maximum Weekly Processing Capacity |\n| :---: | :---: | :---: | :---: |\n| | $A$ | $B$ | |\n| I (hours/unit) | 4 | 6 | 150 |\n| II (hours/unit) | 3 | 2 | 70 |\n| Profit (yuan/unit) | 300 | 450 | |\n\nGiven the factory's business goals:\n\n$p_{1}$: The total weekly profit should not be less than 10,000 yuan;\n\n$p_{2}$: Due to contract requirements, at least 10 units of model A and at least 15 units of model B must be produced each week;\n\n$p_{3}$: The processing time for Process I should be exactly 150 hours per week, and the processing time for Process II should ideally be fully utilized, with potential for appropriate overtime;\n\n$p_{4}$: If products are produced during overtime in Process II, the profit per unit is reduced by 20 yuan for model A and 25 yuan for model B, and the maximum overtime for Process II is 30 hours per week. Formulate the mathematical model for this problem.",
  "ground_truth": 11250.0,
  "formulation": null,
  "correct_program": "def optimize_microcomputer_production():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"Microcomputer_Production\")\n\n    # Decision variables\n    # Production quantities\n    x_A = m.addVar(name=\"x_A\", lb=10)  # at least 10 units of A\n    x_B = m.addVar(name=\"x_B\", lb=15)  # at least 15 units of B\n\n    # Overtime units produced\n    x_A_OT = m.addVar(name=\"x_A_OT\", lb=0)\n    x_B_OT = m.addVar(name=\"x_B_OT\", lb=0)\n\n    # Overtime hours in Process II\n    overtime_hours = m.addVar(name=\"overtime_hours\", lb=0, ub=30)\n\n    # Set objective: maximize profit considering reductions during overtime\n    profit = (300 * x_A + 450 * x_B - 20 * x_A_OT - 25 * x_B_OT)\n    m.setObjective(profit, GRB.MAXIMIZE)\n\n    # Constraints\n    # Process I exact utilization\n    m.addConstr(4 * x_A + 6 * x_B == 150, name=\"ProcessI_Capacity\")\n\n    # Process II regular hours\n    m.addConstr(3 * x_A + 2 * x_B <= 70, name=\"ProcessII_Regular_Capacity\")\n\n    # Overtime hours constraint\n    # Total overtime hours in Process II: 3 hours per unit of A during overtime, 2 hours per unit of B\n    m.addConstr(3 * x_A_OT + 2 * x_B_OT <= 30, name=\"Overtime_Hours_Limit\")\n\n    # Link overtime units to total production\n    m.addConstr(x_A_OT <= x_A, name=\"X_A_OT_Limit\")\n    m.addConstr(x_B_OT <= x_B, name=\"X_B_OT_Limit\")\n\n    # Calculate total overtime hours used\n    # Total overtime hours in Process II:\n    # 3 hours per unit of A during overtime, 2 hours per unit of B during overtime\n    m.addConstr(overtime_hours == 3 * x_A_OT + 2 * x_B_OT,\n                name=\"Total_Overtime_Hours\")\n\n    # Overtime hours cannot exceed 30\n    m.addConstr(overtime_hours <= 30, name=\"Max_Overtime_Hours\")\n\n    # Profit constraint\n    total_profit = (300 * x_A + 450 * x_B - 20 * x_A_OT - 25 * x_B_OT)\n    m.addConstr(total_profit >= 10000, name=\"Profit_Minimum\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        return m.objVal\n    else:\n        return None\nif __name__ == \"__main__\":\n    result = optimize_microcomputer_production()\n    if result is not None:\n        print(f\"Optimal profit: {result}\")\n    else:\n        print(\"No feasible solution found.\")",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B049",
  "description": "A store has formulated a purchase and sales plan for a certain product from July to December. It is known that the warehouse capacity must not exceed 500 units, with 200 units in stock at the end of June. Thereafter, purchases are made at the beginning of each month. Assume the purchase and selling prices of this product for each month are shown in Table 1-21. How much should be purchased and sold each month to maximize the total revenue?\n\nTable 1-21\n| Month | 7  | 8  | 9  | 10 | 11 | 12 |\n|-------|----|----|----|----|----|----|\n| Buy   | 28 | 24 | 25 | 27 | 23 | 23 |\n| Sell  | 29 | 24 | 26 | 28 | 22 | 25 |",
  "ground_truth": 9100.0,
  "formulation": null,
  "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_purchase_sales_plan():\n    \"\"\"\n    Solves the purchase and sales planning problem to maximize total profit\n    over a 6-month period, subject to warehouse capacity and inventory flow.\n    \"\"\"\n    try:\n        # --- Data ---\n        months = ['Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\n        num_months = len(months)\n\n        # Purchase prices (yuan/unit) for each month\n        purchase_prices = [28, 24, 25, 27, 23, 23]\n\n        # Selling prices (yuan/unit) for each month\n        selling_prices = [29, 24, 26, 28, 22, 25]\n\n        # Warehouse capacity\n        warehouse_capacity = 500  # units\n\n        # Initial inventory at the end of June (start of July)\n        initial_inventory = 200  # units\n\n        # --- Create Gurobi Model ---\n        model = gp.Model(\"PurchaseSalesPlan\")\n\n        # --- Decision Variables ---\n        # Buy[t]: quantity purchased at the beginning of month t\n        buy_vars = model.addVars(num_months,\n                                 name=\"Buy\",\n                                 lb=0.0,\n                                 vtype=GRB.INTEGER)\n\n        # Sell[t]: quantity sold during month t\n        sell_vars = model.addVars(num_months,\n                                  name=\"Sell\",\n                                  lb=0.0,\n                                  vtype=GRB.INTEGER)\n\n        # Inv[t]: inventory at the end of month t\n        inventory_vars = model.addVars(num_months,\n                                       name=\"Inventory\",\n                                       lb=0.0,\n                                       vtype=GRB.INTEGER)\n\n        # --- Objective Function: Maximize Total Profit ---\n        # Profit = (Selling Price * Amount Sold) - (Purchase Price * Amount Purchased)\n        total_profit = gp.quicksum(selling_prices[t] * sell_vars[t] -\n                                   purchase_prices[t] * buy_vars[t]\n                                   for t in range(num_months))\n        model.setObjective(total_profit, GRB.MAXIMIZE)\n\n        # --- Constraints ---\n        for t in range(num_months):\n            # Inventory at the start of the current month t\n            inventory_at_start_of_month_t = initial_inventory if t == 0 else inventory_vars[\n                t - 1]\n\n            # 1. Inventory Balance Constraint\n            # Inv[t] = Inv_at_start_of_month_t + Buy[t] - Sell[t]\n            model.addConstr(\n                inventory_vars[t] == inventory_at_start_of_month_t +\n                buy_vars[t] - sell_vars[t],\n                name=f\"InventoryBalance_{months[t]}\")\n\n            # 2. Warehouse Capacity Constraint\n            # Inv[t] <= warehouse_capacity\n            model.addConstr(inventory_vars[t] <= warehouse_capacity,\n                            name=f\"WarehouseCapacity_{months[t]}\")\n\n            # 3. Sales Constraint\n            # Sell[t] <= Inv_at_start_of_month_t + Buy[t]\n            model.addConstr(sell_vars[t]\n                            <= inventory_at_start_of_month_t + buy_vars[t],\n                            name=f\"SalesLimit_{months[t]}\")\n            model.addConstr(inventory_at_start_of_month_t + buy_vars[t] <= warehouse_capacity, name=f\"InventoryLimit_{months[t]}\")\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal purchase and sales plan found.\")\n            print(f\"Maximum Total Profit: {model.ObjVal:.2f} Yuan\")\n\n            print(\"\\nMonthly Plan Details:\")\n            print(\n                f\"{'Month':<5} | {'Purchase Price':<15} | {'Selling Price':<15} | {'Buy (Units)':<12} | {'Sell (Units)':<12} | {'End Inventory':<15}\"\n            )\n            print(\"-\" * 90)\n\n            current_inventory = initial_inventory\n            for t in range(num_months):\n                print(\n                    f\"{months[t]:<5} | {purchase_prices[t]:<15.2f} | {selling_prices[t]:<15.2f} | \"\n                    f\"{buy_vars[t].X:<12.2f} | {sell_vars[t].X:<12.2f} | {inventory_vars[t].X:<15.2f}\"\n                )\n                current_inventory = inventory_vars[\n                    t].X  # For manual check if needed\n\n            print(\"-\" * 90)\n            print(\n                f\"\\nInitial Inventory (End of June): {initial_inventory:.2f} units\"\n            )\n            print(\n                f\"Final Inventory (End of December): {inventory_vars[num_months-1].X:.2f} units\"\n            )\n\n            # Note on \"total revenue\" interpretation\n            print(\n                \"\\nNote: The objective was interpreted as maximizing total profit (Sales Revenue - Purchase Costs).\"\n            )\n            print(\n                \"If 'total revenue' strictly means only Sales Revenue, the objective function would need to be changed.\"\n            )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\"Model is infeasible. Check constraints and data.\")\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            # model.computeIIS()\n            # model.write(\"purchase_sales_iis.ilp\")\n            # print(\"IIS written to purchase_sales_iis.ilp.\")\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_purchase_sales_plan()",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B050",
  "description": "The number of nurses required in each time period over 24 hours at a certain hospital is as follows: 2:00-6:00 - 10 people, 6:00-10:00 - 15 people, 10:00-14:00 - 25 people, 14:00-18:00 - 20 people, 18:00-22:00 - 18 people, 22:00-2:00 - 12 people. Nurses start shifts in 6 batches at 2:00, 6:00, 10:00, 14:00, 18:00, and 22:00 and work continuously for 8 hours. Please determine: If the hospital can hire contract nurses with the same working hours as regular nurses, and if the pay for regular nurses is 10 yuan/hour and for contract nurses is 15 yuan/hour, should the hospital hire contract nurses and if so, how many?",
  "ground_truth": 4240.0,
  "formulation": null,
  "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_nurse_staffing_with_contract():\n    \"\"\"\n    Solves the nurse staffing problem with regular and contract nurses\n    to minimize total daily wage costs.\n    \"\"\"\n    try:\n        # Create a new model\n        model = gp.Model(\"NurseStaffingContract\")\n\n        # --- Data ---\n        # Demands for each 4-hour period (0 to 5)\n        # P0: 2:00-6:00, P1: 6:00-10:00, ..., P5: 22:00-2:00\n        demands = {\n            0: 10,  # 2:00 - 6:00\n            1: 15,  # 6:00 - 10:00\n            2: 25,  # 10:00 - 14:00\n            3: 20,  # 14:00 - 18:00\n            4: 18,  # 18:00 - 22:00\n            5: 12  # 22:00 - 2:00 (next day)\n        }\n        num_periods = len(demands)  # Should be 6\n\n        # Shift start times (represented by an index for variables)\n        # t=0 starts at 2:00, t=1 at 6:00, ..., t=5 at 22:00\n        shift_start_times_desc = [\n            \"2:00\", \"6:00\", \"10:00\", \"14:00\", \"18:00\", \"22:00\"\n        ]\n\n        # Costs\n        cost_regular_nurse_shift = 10 * 8  # 10 yuan/hour * 8 hours\n        cost_contract_nurse_shift = 15 * 8  # 15 yuan/hour * 8 hours\n\n        # --- Decision Variables ---\n        # xR[t]: number of regular nurses starting shift at time t\n        xR = model.addVars(num_periods, vtype=GRB.INTEGER, name=\"xR\", lb=0)\n        # xC[t]: number of contract nurses starting shift at time t\n        xC = model.addVars(num_periods, vtype=GRB.INTEGER, name=\"xC\", lb=0)\n\n        # --- Objective Function ---\n        # Minimize the total daily wage cost\n        total_cost = gp.quicksum(cost_regular_nurse_shift * xR[t] +\n                                 cost_contract_nurse_shift * xC[t]\n                                 for t in range(num_periods))\n        model.setObjective(total_cost, GRB.MINIMIZE)\n\n        # --- Constraints ---\n        # Demand coverage for each period.\n        # Each nurse works for 8 hours, covering two 4-hour periods.\n\n        # Period 0 (2:00-6:00): Covered by staff starting at 22:00 (t=5) and 2:00 (t=0)\n        model.addConstr((xR[5] + xC[5]) + (xR[0] + xC[0]) >= demands[0],\n                        \"Demand_P0\")\n\n        # Period 1 (6:00-10:00): Covered by staff starting at 2:00 (t=0) and 6:00 (t=1)\n        model.addConstr((xR[0] + xC[0]) + (xR[1] + xC[1]) >= demands[1],\n                        \"Demand_P1\")\n\n        # Period 2 (10:00-14:00): Covered by staff starting at 6:00 (t=1) and 10:00 (t=2)\n        model.addConstr((xR[1] + xC[1]) + (xR[2] + xC[2]) >= demands[2],\n                        \"Demand_P2\")\n\n        # Period 3 (14:00-18:00): Covered by staff starting at 10:00 (t=2) and 14:00 (t=3)\n        model.addConstr((xR[2] + xC[2]) + (xR[3] + xC[3]) >= demands[3],\n                        \"Demand_P3\")\n\n        # Period 4 (18:00-22:00): Covered by staff starting at 14:00 (t=3) and 18:00 (t=4)\n        model.addConstr((xR[3] + xC[3]) + (xR[4] + xC[4]) >= demands[4],\n                        \"Demand_P4\")\n\n        # Period 5 (22:00-2:00): Covered by staff starting at 18:00 (t=4) and 22:00 (t=5)\n        model.addConstr((xR[4] + xC[4]) + (xR[5] + xC[5]) >= demands[5],\n                        \"Demand_P5\")\n\n        # Suppress Gurobi output to console\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal staffing plan found.\")\n            print(f\"Minimum Total Daily Wage Cost: {model.objVal:.2f} Yuan\")\n\n            total_regular_nurses = sum(xR[t].X for t in range(num_periods))\n            total_contract_nurses = sum(xC[t].X for t in range(num_periods))\n\n            print(\n                f\"\\nTotal Regular Nurses to Hire: {total_regular_nurses:.0f}\")\n            print(\n                f\"Total Contract Nurses to Hire: {total_contract_nurses:.0f}\")\n\n            if total_contract_nurses > 0:\n                print(\"\\nDecision: The hospital SHOULD hire contract nurses.\")\n            else:\n                print(\n                    \"\\nDecision: The hospital does NOT need to hire contract nurses based on cost minimization.\"\n                )\n\n            print(\"\\nNumber of Nurses Starting at Each Shift:\")\n            print(f\"{'Start Time':<12} | {'Regular':<10} | {'Contract':<10}\")\n            print(\"-\" * 40)\n            for t in range(num_periods):\n                print(\n                    f\"{shift_start_times_desc[t]:<12} | {xR[t].X:<10.0f} | {xC[t].X:<10.0f}\"\n                )\n\n            print(\"\\nVerification of Coverage per Period:\")\n            coverage = [0] * num_periods\n            coverage[0] = (xR[5].X + xC[5].X) + (xR[0].X + xC[0].X)\n            coverage[1] = (xR[0].X + xC[0].X) + (xR[1].X + xC[1].X)\n            coverage[2] = (xR[1].X + xC[1].X) + (xR[2].X + xC[2].X)\n            coverage[3] = (xR[2].X + xC[2].X) + (xR[3].X + xC[3].X)\n            coverage[4] = (xR[3].X + xC[3].X) + (xR[4].X + xC[4].X)\n            coverage[5] = (xR[4].X + xC[4].X) + (xR[5].X + xC[5].X)\n\n            period_desc = [\n                \"2:00-6:00\", \"6:00-10:00\", \"10:00-14:00\", \"14:00-18:00\",\n                \"18:00-22:00\", \"22:00-2:00\"\n            ]\n            for p in range(num_periods):\n                print(\n                    f\"  Period {period_desc[p]} (Demand: {demands[p]}): Covered by {coverage[p]:.0f} nurses\"\n                )\n\n        else:\n            print(\"No optimal solution found. Status code:\", model.status)\n\n    except gp.GurobiError as e:\n        print(f\"Error code {e.errno}: {e}\")\n    except AttributeError:\n        print(\n            \"Encountered an attribute error, Gurobi might not be installed or licensed correctly.\"\n        )\n\n\nif __name__ == '__main__':\n    solve_nurse_staffing_with_contract()",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B051",
  "description": "For a certain 24-hour bus service, the number of drivers and crew members required during different time periods each day is shown in Table 1-2:\nTable 1-2\n\\begin{tabular}{|c|c|c||c|c|c|}\n\\hline Shift & Time & Required number & Shift & Time & Required number \\\\\n\\hline 1 & $6: 00 \\sim 10: 00$ & 60 & 4 & $18 ; 00 \\sim 22 ; 00$ & 50 \\\\\n\\hline 2 & $10 ; 00 \\sim 14 ; 00$ & 70 & 5 & $22 ; 00 \\sim 2 ; 00$ & 20 \\\\\n\\hline 3 & $14 ; 00 \\sim 18 ; 00$ & 60 & 6 & $2: 00 \\sim 6 ; 00$ & 30 \\\\\n\\hline\n\\end{tabular}\n\nAssuming that drivers and crew members start their shifts at the beginning of each time period and work continuously for 8 hours, determine the minimum number of drivers and crew members needed for this bus route. Formulate the linear programming model for this problem.",
  "ground_truth": 150.0,
  "formulation": null,
  "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_bus_staffing():\n    \"\"\"\n    Solves the bus service staffing problem to minimize the total number of\n    drivers and crew members needed.\n    \"\"\"\n    try:\n        # Create a new model\n        model = gp.Model(\"BusStaffingOptimization\")\n\n        # --- Data ---\n        # Demands for each 4-hour period, re-ordered chronologically\n        # Period 0: 2:00-6:00 (Original Shift 6)\n        # Period 1: 6:00-10:00 (Original Shift 1)\n        # Period 2: 10:00-14:00 (Original Shift 2)\n        # Period 3: 14:00-18:00 (Original Shift 3)\n        # Period 4: 18:00-22:00 (Original Shift 4)\n        # Period 5: 22:00-2:00 (Original Shift 5)\n        demands = {\n            0: 30,  # 2:00 - 6:00\n            1: 60,  # 6:00 - 10:00\n            2: 70,  # 10:00 - 14:00\n            3: 60,  # 14:00 - 18:00\n            4: 50,  # 18:00 - 22:00\n            5: 20  # 22:00 - 2:00 (next day)\n        }\n        num_periods = len(demands)  # Should be 6\n\n        # Shift start times descriptions for output\n        shift_start_times_desc = [\n            \"2:00\", \"6:00\", \"10:00\", \"14:00\", \"18:00\", \"22:00\"\n        ]\n        period_desc = [\n            \"2:00-6:00\", \"6:00-10:00\", \"10:00-14:00\", \"14:00-18:00\",\n            \"18:00-22:00\", \"22:00-2:00\"\n        ]\n\n        # --- Decision Variables ---\n        # x[t]: number of staff starting their 8-hour shift at the beginning of period t\n        x = model.addVars(num_periods, vtype=GRB.INTEGER, name=\"x\", lb=0)\n\n        # --- Objective Function ---\n        # Minimize the total number of staff members hired\n        model.setObjective(gp.quicksum(x[t] for t in range(num_periods)),\n                           GRB.MINIMIZE)\n\n        # --- Constraints ---\n        # Demand coverage for each period.\n        # Each staff member works for 8 hours, covering two 4-hour periods.\n\n        # Period 0 (2:00-6:00): Covered by staff starting at 22:00 (x[5]) and 2:00 (x[0])\n        model.addConstr(x[5] + x[0] >= demands[0], \"Demand_P0\")\n\n        # Period 1 (6:00-10:00): Covered by staff starting at 2:00 (x[0]) and 6:00 (x[1])\n        model.addConstr(x[0] + x[1] >= demands[1], \"Demand_P1\")\n\n        # Period 2 (10:00-14:00): Covered by staff starting at 6:00 (x[1]) and 10:00 (x[2])\n        model.addConstr(x[1] + x[2] >= demands[2], \"Demand_P2\")\n\n        # Period 3 (14:00-18:00): Covered by staff starting at 10:00 (x[2]) and 14:00 (x[3])\n        model.addConstr(x[2] + x[3] >= demands[3], \"Demand_P3\")\n\n        # Period 4 (18:00-22:00): Covered by staff starting at 14:00 (x[3]) and 18:00 (x[4])\n        model.addConstr(x[3] + x[4] >= demands[4], \"Demand_P4\")\n\n        # Period 5 (22:00-2:00): Covered by staff starting at 18:00 (x[4]) and 22:00 (x[5])\n        model.addConstr(x[4] + x[5] >= demands[5], \"Demand_P5\")\n\n        # Suppress Gurobi output to console\n        model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal staffing plan found.\")\n            print(\n                f\"Minimum total staff (drivers and crew) needed: {model.objVal:.0f}\"\n            )\n\n            print(\"\\nNumber of Staff Starting at Each Shift:\")\n            print(f\"{'Start Time':<12} | {'Number of Staff':<15}\")\n            print(\"-\" * 30)\n            for t in range(num_periods):\n                print(f\"{shift_start_times_desc[t]:<12} | {x[t].X:<15.0f}\")\n\n            print(\"\\nVerification of Coverage per Period:\")\n            coverage = [0] * num_periods\n            coverage[0] = x[5].X + x[0].X\n            coverage[1] = x[0].X + x[1].X\n            coverage[2] = x[1].X + x[2].X\n            coverage[3] = x[2].X + x[3].X\n            coverage[4] = x[3].X + x[4].X\n            coverage[5] = x[4].X + x[5].X\n\n            for p_idx in range(num_periods):\n                print(\n                    f\"  Period {period_desc[p_idx]} (Demand: {demands[p_idx]}): Covered by {coverage[p_idx]:.0f} staff\"\n                )\n\n        else:\n            print(\"No optimal solution found. Status code:\", model.status)\n\n    except gp.GurobiError as e:\n        print(f\"Error code {e.errno}: {e}\")\n    except AttributeError:\n        print(\n            \"Encountered an attribute error, Gurobi might not be installed or licensed correctly.\"\n        )\n\n\nif __name__ == '__main__':\n    solve_bus_staffing()",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B052",
  "description": "The Zhang family has 6 children: Harry, Hermione, Ron, Fred, George, and Ginny. The cost of taking Harry is $1200, Hermione is $1650, Ron is $750, Fred is $800, George is $800, and Ginny is $1500. Which children should the couple take to minimize the total cost of taking the children? They can take up to four children on the upcoming trip.\n\nGinny is the youngest, so the Zhang family will definitely take her.\n\nIf the couple takes Harry, they will not take Fred because Harry does not get along with him.\n\nIf the couple takes Harry, they will not take George because Harry does not get along with him.\n\nIf they take George, they must also take Fred.\n\nIf they take George, they must also take Hermione.\n\nEven though it will cost them a lot of money, the Zhang family has decided to take at least three children.",
  "ground_truth": 3050.0,
  "formulation": null,
  "correct_program": "def optimize_children_trip():\n    from gurobipy import Model, GRB\n\n    # Costs\n    cost_Harry = 1200\n    cost_Hermione = 1650\n    cost_Ron = 750\n    cost_Fred = 800\n    cost_George = 800\n    cost_Ginny = 1500  # always taken\n\n    # Initialize model\n    m = Model(\"Children_Trip_Optimization\")\n    m.setParam('OutputFlag', 0)  # suppress output\n\n    # Decision variables\n    y_Harry = m.addVar(vtype=GRB.BINARY, name='Harry')\n    y_Hermione = m.addVar(vtype=GRB.BINARY, name='Hermione')\n    y_Ron = m.addVar(vtype=GRB.BINARY, name='Ron')\n    y_Fred = m.addVar(vtype=GRB.BINARY, name='Fred')\n    y_George = m.addVar(vtype=GRB.BINARY, name='George')\n    y_Ginny = 1  # always taken\n\n    # Set objective\n    m.setObjective(\n        cost_Harry * y_Harry + cost_Hermione * y_Hermione + cost_Ron * y_Ron +\n        cost_Fred * y_Fred + cost_George * y_George + cost_Ginny, GRB.MINIMIZE)\n\n    # Constraints\n    total_children = y_Harry + y_Hermione + y_Ron + y_Fred + y_George + y_Ginny\n    m.addConstr(total_children >= 3, name='MinChildren')\n    m.addConstr(total_children <= 4, name='MaxChildren')\n\n    # Harry-Fred exclusion\n    m.addConstr(y_Harry + y_Fred <= 1, name='HarryFredExcl')\n    # Harry-Gorge exclusion\n    m.addConstr(y_Harry + y_George <= 1, name='HarryGeorgeExcl')\n    # George-Fred relationship\n    m.addConstr(y_George <= y_Fred, name='GeorgeFred')\n    # George-Hermione relationship\n    m.addConstr(y_George <= y_Hermione, name='GeorgeHermione')\n\n    # Optimize\n    m.optimize()\n\n    if m.status == GRB.OPTIMAL:\n        return m.objVal\n    else:\n        return None\nif __name__ == \"__main__\":\n    result = optimize_children_trip()\n    if result is not None:\n        print(f\"Optimal total cost for the trip: {result}\")\n    else:\n        print(\"No feasible solution found.\")",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B053",
  "description": "Given that a certain factory plans to produce three types of products, I, II, and III, each product needs to be processed on equipment $A, B, C$ as shown in Table 2-3:\n\nTable 2-3\n| Equipment Code | I  | II | III | Effective Monthly Equipment Hours |\n|----------------|----|----|-----|----------------------------------|\n| A              | 8  | 2  | 10  | 300                              |\n| B              | 10 | 5  | 8   | 400                              |\n| C              | 2  | 13 | 10  | 420                              |\n| Unit Product Profit (per thousand yuan) | 3  | 2  | 2.9 |           |\n\nHow can the equipment capacity be fully utilized to maximize production profit?",
  "ground_truth": 135.26666666666668,
  "formulation": null,
  "correct_program": "def optimize_factory_production():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"FactoryProductionMaxProfit\")\n\n    # Decision variables: production quantities of products I, II, III\n    x_I = m.addVar(name=\"x_I\", lb=0)\n    x_II = m.addVar(name=\"x_II\", lb=0)\n    x_III = m.addVar(name=\"x_III\", lb=0)\n\n    # Set the objective: maximize total profit\n    profit = 3 * x_I + 2 * x_II + 2.9 * x_III\n    m.setObjective(profit, GRB.MAXIMIZE)\n\n    # Add equipment capacity constraints\n    m.addConstr(8 * x_I + 2 * x_II + 10 * x_III <= 300, name=\"A_capacity\")\n    m.addConstr(10 * x_I + 5 * x_II + 8 * x_III <= 400, name=\"B_capacity\")\n    m.addConstr(2 * x_I + 13 * x_II + 10 * x_III <= 420, name=\"C_capacity\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal profit value\n        return m.objVal\n    else:\n        # No feasible solution found\n        return None\nif __name__ == \"__main__\":  \n    result = optimize_factory_production()\n    if result is not None:\n        print(f\"Optimal total profit: {result}\")\n    else:\n        print(\"No feasible solution found.\")",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B054",
  "description": "A master's student in Operations Research at a certain university is required to select two courses in mathematics, two in operations research, and two in computer science from a total of seven courses: Calculus, Operations Research, Data Structures, Management Statistics, Computer Simulation, Computer Programming, and Forecasting. Some courses belong to only one category: Calculus falls under Mathematics, Computer Programming under Computer Science. However, some courses fall under multiple categories: Operations Research can be considered both Operations Research and Mathematics, Data Structures both Computer Science and Mathematics, Management Statistics both Mathematics and Operations Research, Computer Simulation both Computer Science and Operations Research, and Forecasting both Operations Research and Mathematics. Courses that fall under multiple categories can fulfill the requirement of both categories simultaneously. Additionally, some courses have prerequisites: Computer Simulation or Data Structures requires Computer Programming first, Management Statistics requires Calculus first, and Forecasting requires Management Statistics first. The question is: What is the minimum number of courses a master's student must take, and which specific courses, to meet the above requirements?",
  "ground_truth": 4.0,
  "formulation": null,
  "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_course_selection():\n    \"\"\"\n    Solves the course selection problem to minimize the number of courses taken\n    while satisfying category and prerequisite requirements.\n    \"\"\"\n    try:\n        # --- Data ---\n        courses = ['Calc', 'OR', 'DS', 'MS', 'Sim', 'Prog', 'Fcst']\n        categories = ['Math', 'OpRes', 'CompSci']\n\n        # Requirements per category\n        category_requirements = {'Math': 2, 'OpRes': 2, 'CompSci': 2}\n\n        # Course-to-category mapping: course_category[course][category] = 1 if belongs, else 0 or not present\n        course_category_map = {\n            'Calc': {\n                'Math': 1\n            },\n            'OR': {\n                'OpRes': 1,\n                'Math': 1\n            },\n            'DS': {\n                'CompSci': 1,\n                'Math': 1\n            },\n            'MS': {\n                'Math': 1,\n                'OpRes': 1\n            },\n            'Sim': {\n                'CompSci': 1,\n                'OpRes': 1\n            },\n            'Prog': {\n                'CompSci': 1\n            },\n            'Fcst': {\n                'OpRes': 1,\n                'Math': 1\n            }\n        }\n\n        # Prerequisites: prereqs[course_requiring_prereq] = [list_of_prereqs]\n        prerequisites = {\n            'Sim': ['Prog'],\n            'DS': ['Prog'],\n            'MS': ['Calc'],\n            'Fcst': ['MS']\n        }\n\n        # --- Create Gurobi Model ---\n        model = gp.Model(\"CourseSelectionOptimization\")\n\n        # --- Decision Variables ---\n        # x[c]: 1 if course c is selected, 0 otherwise\n        x = model.addVars(courses, vtype=GRB.BINARY, name=\"x\")\n\n        # --- Objective Function: Minimize the total number of courses selected ---\n        model.setObjective(gp.quicksum(x[c] for c in courses), GRB.MINIMIZE)\n\n        # --- Constraints ---\n        # 1. Category Requirements\n        for cat in categories:\n            model.addConstr(gp.quicksum(\n                x[c] * course_category_map[c].get(cat, 0) for c in courses)\n                            >= category_requirements[cat],\n                            name=f\"Req_{cat}\")\n\n        # 2. Prerequisite Constraints\n        # If x[course_with_prereq] = 1, then x[prereq_course] must be 1.\n        # So, x[course_with_prereq] <= x[prereq_course]\n        for course, prereq_list in prerequisites.items():\n            for prereq_course in prereq_list:\n                if course in x and prereq_course in x:  # Ensure both courses are valid keys\n                    model.addConstr(\n                        x[course] <= x[prereq_course],\n                        name=f\"Prereq_{prereq_course}_for_{course}\")\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal course selection found.\")\n            print(f\"Minimum number of courses to take: {model.ObjVal:.0f}\")\n\n            print(\"\\nSelected Courses:\")\n            selected_courses_list = []\n            for c in courses:\n                if x[c].X > 0.5:  # If x[c] is 1\n                    selected_courses_list.append(c)\n                    print(f\"  - {c}\")\n\n            print(\"\\nVerification of Category Requirements:\")\n            for cat in categories:\n                courses_for_cat = 0\n                cat_courses_taken = []\n                for c_taken in selected_courses_list:\n                    if course_category_map[c_taken].get(cat, 0) == 1:\n                        courses_for_cat += 1\n                        cat_courses_taken.append(c_taken)\n                print(\n                    f\"  Category '{cat}': Required={category_requirements[cat]}, Taken={courses_for_cat} ({', '.join(cat_courses_taken)})\"\n                )\n\n            print(\"\\nVerification of Prerequisites:\")\n            all_prereqs_met = True\n            for course_taken in selected_courses_list:\n                if course_taken in prerequisites:\n                    for prereq_c in prerequisites[course_taken]:\n                        if prereq_c not in selected_courses_list:\n                            print(\n                                f\"  ERROR: Course '{course_taken}' taken, but its prerequisite '{prereq_c}' is NOT taken.\"\n                            )\n                            all_prereqs_met = False\n            if all_prereqs_met:\n                print(\n                    \"  All prerequisite conditions are met for the selected courses.\"\n                )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\n                \"Model is infeasible. The requirements cannot be met with the given courses and constraints.\"\n            )\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            # model.computeIIS()\n            # model.write(\"course_selection_iis.ilp\")\n            # print(\"IIS written to course_selection_iis.ilp.\")\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_course_selection()",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B057",
  "description": "Vicky and David have just bought a farm in the Yarra Valley, and they are considering using it to grow apples, pears, oranges, and lemons. The profit for growing one acre of apples is $2000, for one acre of pears is $1800, for one acre of oranges is $2200, and for one acre of lemons is $3000. To achieve maximum profit, how many acres of land should they use to grow each type of fruit? Vicky and David have just bought a farm in the Yarra Valley with a total area of 120 acres.\n\nThe land used to grow apples should be at least twice the land used to grow pears.\n\nThe land used to grow apples should be at least three times the land used to grow lemons.\n\nThe land used to grow oranges must be twice the land used to grow lemons.\n\nVicky and David are unwilling to grow more than two types of fruit.",
  "ground_truth": 240000.0,
  "formulation": null,
  "correct_program": "from gurobipy import Model, GRB, quicksum\n\n# Create a new model\nmodel = Model(\"Farm_Optimization\")\n\n# Define parameters\nM = 120  # Maximum possible acres\n\n# Decision variables: Acres planted\nx_A = model.addVar(name=\"Acres_Apples\", lb=0)\nx_P = model.addVar(name=\"Acres_Pears\", lb=0)\nx_O = model.addVar(name=\"Acres_Oranges\", lb=0)\nx_L = model.addVar(name=\"Acres_Lemons\", lb=0)\n\n# Binary variables: Whether to plant a certain type of fruit    \ny_A = model.addVar(vtype=GRB.BINARY, name=\"Use_Apples\")\ny_P = model.addVar(vtype=GRB.BINARY, name=\"Use_Pears\")\ny_O = model.addVar(vtype=GRB.BINARY, name=\"Use_Oranges\")\ny_L = model.addVar(vtype=GRB.BINARY, name=\"Use_Lemons\")\n\n# Set objective function\nmodel.setObjective(2000 * x_A + 1800 * x_P + 2200 * x_O + 3000 * x_L,\n                   GRB.MAXIMIZE)\n\n# Add constraints\nmodel.addConstr(x_A + x_P + x_O + x_L <= 120, \"Total_Area_Constraint\")  # Total area constraint\nmodel.addConstr(x_A >= 2 * x_P, \"Apples_vs_Pears\")  # Apples ≥ 2×Pears\nmodel.addConstr(x_A >= 3 * x_L, \"Apples_vs_Lemons\")  # Apples ≥ 3×Lemons\nmodel.addConstr(x_O == 2 * x_L, \"Oranges_vs_Lemons\")  # Oranges = 2×Lemons\nmodel.addConstr(y_A + y_P + y_O + y_L <= 2, \"Max_Two_Crops\")  # At most two types of fruits\n\n# Big-M constraints: Link area planted to whether a fruit is planted    \nmodel.addConstr(x_A <= M * y_A, \"Link_Apples\")\nmodel.addConstr(x_P <= M * y_P, \"Link_Pears\")\nmodel.addConstr(x_O <= M * y_O, \"Link_Oranges\")\nmodel.addConstr(x_L <= M * y_L, \"Link_Lemons\")\n\n# Solve the model\nmodel.optimize()\n\n# Output results\nif model.status == GRB.OPTIMAL:\n    print(\"Optimal solution found!\")\n    print(f\"Apples: {x_A.X:.2f} acres\")\n    print(f\"Pears: {x_P.X:.2f} acres\")\n    print(f\"Oranges: {x_O.X:.2f} acres\")\n    print(f\"Lemons: {x_L.X:.2f} acres\")\n    print(f\"Total profit: ${model.objVal:,.2f}\")\nelse:\n    print(\"No optimal solution found.\")",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B058",
  "description": "A candy factory uses raw materials A, B, and C to process three different brands of candies, A, B, and C. It is known that the content of A, B, and C in each brand of candy, the cost of raw materials, the monthly limit of each raw material, and the unit processing fee and selling price of the three brands of candies are shown in Table 1-7.\n\nTable 1-7\n\n| Item            | A               | B               | C               | Raw Material Cost (Yuan/kg) | Monthly Limit (kg) |\n|:----------------|:---------------|:---------------|:---------------|:-----------------------------|:-------------------|\n| A               | ≥ 60%          | ≥ 15%          |                | 2.00                        | 2000               |\n| B               |                |                |                | 1.50                        | 2500               |\n| C               | ≤ 20%          | ≤ 60%          | ≤ 50%          | 1.00                        | 1200               |\n| Processing Fee (Yuan/kg) | 0.50         | 0.40           | 0.30           |                             |                     |\n| Selling Price (Yuan/kg)   | 3.40         | 2.85           | 2.25           |                             |                     |\n\nHow many kilograms of each of the three brands of candies should the factory produce each month to maximize the profit?",
  "ground_truth": 6160.0,
  "formulation": null,
  "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_candy_production():\n    \"\"\"\n    Solves the candy factory production planning problem to maximize profit.\n    \"\"\"\n    try:\n        # --- Data ---\n        candy_brands = ['CandyA', 'CandyB', 'CandyC']\n        raw_materials = ['RawA', 'RawB', 'RawC']\n\n        # Selling prices (Yuan/kg)\n        selling_prices = {'CandyA': 3.40, 'CandyB': 2.85, 'CandyC': 2.25}\n\n        # Processing fees (Yuan/kg)\n        processing_fees = {'CandyA': 0.50, 'CandyB': 0.40, 'CandyC': 0.30}\n\n        # Raw material costs (Yuan/kg)\n        raw_material_costs = {'RawA': 2.00, 'RawB': 1.50, 'RawC': 1.00}\n\n        # Monthly limits of raw materials (kg)\n        raw_material_limits = {'RawA': 2000, 'RawB': 2500, 'RawC': 1200}\n\n        # --- Create Gurobi Model ---\n        model = gp.Model(\"CandyFactoryOptimization\")\n\n        # --- Decision Variables ---\n        # X[j]: total kilograms of candy brand j produced\n        X = model.addVars(candy_brands,\n                          name=\"X_prod\",\n                          lb=0.0,\n                          vtype=GRB.CONTINUOUS)\n\n        # R[i,j]: kilograms of raw material i used in candy brand j\n        R = model.addVars(raw_materials,\n                          candy_brands,\n                          name=\"R_raw_in_candy\",\n                          lb=0.0,\n                          vtype=GRB.CONTINUOUS)\n\n        # --- Objective Function: Maximize Total Profit ---\n        # Profit = (Sales Revenue - Processing Cost) - Raw Material Cost\n\n        revenue_minus_processing = gp.quicksum(\n            (selling_prices[j] - processing_fees[j]) * X[j]\n            for j in candy_brands)\n\n        total_raw_material_cost = gp.quicksum(raw_material_costs[i] * R[i, j]\n                                              for i in raw_materials\n                                              for j in candy_brands)\n\n        model.setObjective(revenue_minus_processing - total_raw_material_cost,\n                           GRB.MAXIMIZE)\n\n        # --- Constraints ---\n        # 1. Mass Balance for Each Candy Brand: Sum of raw materials = Total candy produced\n        for j in candy_brands:\n            model.addConstr(gp.quicksum(R[i, j]\n                                        for i in raw_materials) == X[j],\n                            name=f\"MassBalance_{j}\")\n\n        # 2. Raw Material Availability Limits\n        for i in raw_materials:\n            model.addConstr(gp.quicksum(R[i, j] for j in candy_brands)\n                            <= raw_material_limits[i],\n                            name=f\"Limit_{i}\")\n\n        # 3. Content Percentage Requirements\n        # Candy A\n        model.addConstr(R['RawA', 'CandyA'] >= 0.60 * X['CandyA'],\n                        name=\"Content_CandyA_RawA_min\")\n        model.addConstr(R['RawC', 'CandyA'] <= 0.20 * X['CandyA'],\n                        name=\"Content_CandyA_RawC_max\")\n\n        # Candy B\n        model.addConstr(R['RawA', 'CandyB'] >= 0.15 * X['CandyB'],\n                        name=\"Content_CandyB_RawA_min\")\n        model.addConstr(R['RawC', 'CandyB'] <= 0.60 * X['CandyB'],\n                        name=\"Content_CandyB_RawC_max\")\n\n        # Candy C\n        model.addConstr(R['RawC', 'CandyC'] <= 0.50 * X['CandyC'],\n                        name=\"Content_CandyC_RawC_max\")\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal production plan found.\")\n            print(f\"Maximum Total Profit: {model.ObjVal:.2f} Yuan\")\n\n            print(\"\\nOptimal Production Quantities (kg):\")\n            for j in candy_brands:\n                if X[j].X > 1e-6:\n                    print(f\"  {j}: {X[j].X:.2f} kg\")\n                    print(f\"    Composition:\")\n                    for i in raw_materials:\n                        if R[i, j].X > 1e-6:\n                            percentage = (R[i, j].X / X[j].X *\n                                          100) if X[j].X > 1e-6 else 0\n                            print(\n                                f\"      {i}: {R[i,j].X:.2f} kg ({percentage:.1f}%)\"\n                            )\n                else:\n                    print(f\"  {j}: 0.00 kg\")\n\n            print(\"\\nTotal Raw Material Usage (kg):\")\n            for i in raw_materials:\n                total_used = sum(R[i, j].X for j in candy_brands)\n                print(\n                    f\"  {i}: {total_used:.2f} / {raw_material_limits[i]} kg used\"\n                )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\n                \"Model is infeasible. Check constraints and data for contradictions.\"\n            )\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            # model.computeIIS()\n            # model.write(\"candy_factory_iis.ilp\")\n            # print(\"IIS written to candy_factory_iis.ilp.\")\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_candy_production()",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B059",
  "description": "A traveling salesman must visit 7 customers at 7 different locations, with the (symmetric) distance matrix as follows:\n\n|  | 1 | 2 | 3 | 4 | 5 | 6 | 7 |\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\n| 1 | - | 86 | 49 | 57 | 31 | 69 | 50 |\n| 2 |  | - | 68 | 79 | 93 | 24 | 5 |\n| 3 |  |  | - | 16 | 7 | 72 | 67 |\n| 4 |  |  |  | - | 90 | 69 | 1 |\n| 5 |  |  |  |  | - | 86 | 59 |\n| 6 |  |  |  |  |  | - | 81 |\n\nFormulate a mathematical program to determine the visiting order starting and ending at location 1 to minimize the travel distance, and solve it using COPTPY.",
  "ground_truth": 153.0,
  "formulation": null,
  "correct_program": "def solve_tsp(distance_matrix=None):\n    from gurobipy import Model, GRB, quicksum\n\n    # Default distance matrix based on the provided data\n    if distance_matrix is None:\n        distance_matrix = [[0, 86, 49, 57, 31, 69, 50],\n                           [86, 0, 68, 79, 93, 24, 5],\n                           [49, 68, 0, 16, 7, 72, 67],\n                           [57, 79, 16, 0, 90, 69, 1],\n                           [31, 93, 7, 90, 0, 86, 59],\n                           [69, 24, 72, 69, 86, 0, 81],\n                           [50, 5, 67, 1, 59, 81, 0]]\n\n    n = len(distance_matrix)\n    model = Model()\n\n    # Decision variables: x[i,j] binary\n    x = {}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                x[i, j] = model.addVar(vtype=GRB.BINARY, name=f\"x_{i}_{j}\")\n\n    # MTZ variables for subtour elimination\n    u = {}\n    for i in range(1, n):\n        u[i] = model.addVar(lb=2, ub=n, vtype=GRB.CONTINUOUS, name=f\"u_{i}\")\n\n    model.update()\n\n    # Objective: minimize total distance\n    model.setObjective(\n        quicksum(distance_matrix[i][j] * x[i, j] for i in range(n)\n                 for j in range(n) if i != j), GRB.MINIMIZE)\n\n    # Constraints:\n\n    # 1. From start location (0), exactly one outgoing edge\n    model.addConstr(quicksum(x[0, j] for j in range(1, n)) == 1,\n                    name=\"start_out\")\n\n    # 2. Each node (except start) has exactly one incoming edge\n    for j in range(1, n):\n        model.addConstr(quicksum(x[i, j] for i in range(n) if i != j) == 1,\n                        name=f\"node_in_{j}\")\n\n    # 3. Each node (except start) has exactly one outgoing edge\n    for i in range(1, n):\n        model.addConstr(quicksum(x[i, j] for j in range(n) if j != i) == 1,\n                        name=f\"node_out_{i}\")\n\n    # 4. Subtour elimination (MTZ)\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                model.addConstr(u[i] - u[j] + n * x[i, j] <= n - 1,\n                                name=f\"subtour_{i}_{j}\")\n\n    # Optimize\n    model.optimize()\n\n    # Check feasibility\n    if model.status == GRB.OPTIMAL:\n        return model.objVal\n    else:\n        return None\nif __name__ == \"__main__\":\n    result = solve_tsp()\n    if result is not None:\n        print(f\"Optimal total distance: {result}\")\n    else:\n        print(\"No feasible solution found.\")",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B060",
  "description": "A product can be processed on any one of the four devices: A, B, C, or D. The preparation completion costs when each device is enabled, the unit production cost for the product, and the maximum processing capacity of each device are shown in Table 5-7. If 2000 units of the product need to be produced, how can the total cost be minimized? Try to establish a mathematical model.\n\nTable 5-7\n| Device | Prep Completion Cost (Yuan) | Unit Production Cost (Yuan/Unit) | Maximum Processing Capacity (Units) |\n|--------|------------------------------|----------------------------------|------------------------------------|\n| A      | 1000                         | 20                               | 900                                |\n| B      | 920                          | 24                               | 1000                               |\n| C      | 800                          | 16                               | 1200                               |\n| D      | 700                          | 28                               | 1600                               |",
  "ground_truth": 37000.0,
  "formulation": null,
  "correct_program": "def optimize_production():\n    from gurobipy import Model, GRB\n\n    # Data from the problem\n    prep_costs = {'A': 1000, 'B': 920, 'C': 800, 'D': 700}\n    unit_costs = {'A': 20, 'B': 24, 'C': 16, 'D': 28}\n    capacities = {'A': 900, 'B': 1000, 'C': 1200, 'D': 1600}\n    total_units = 2000\n\n    # Initialize model\n    m = Model(\"Production_Optimization\")\n    m.setParam('OutputFlag', 0)  # Suppress output\n\n    # Decision variables\n    y = m.addVars(prep_costs.keys(), vtype=GRB.BINARY, name='y')\n    x = m.addVars(prep_costs.keys(), lb=0, vtype=GRB.CONTINUOUS, name='x')\n\n    # Objective function\n    m.setObjective(\n        sum(prep_costs[i] * y[i] + unit_costs[i] * x[i] for i in prep_costs),\n        GRB.MINIMIZE)\n\n    # Constraints\n    # Demand satisfaction\n    m.addConstr(sum(x[i] for i in prep_costs) == total_units, name='Demand')\n\n    # Capacity constraints linked with activation\n    for i in prep_costs:\n        m.addConstr(x[i] <= capacities[i] * y[i], name=f'Cap_{i}')\n\n    # Optimize\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        total_cost = m.objVal\n        return total_cost\n    else:\n        return None\nif __name__ == \"__main__\":\n    result = optimize_production()\n    if result is not None:\n        print(f\"Optimal total cost for production: {result}\")\n    else:\n        print(\"No feasible solution found.\")",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B061",
  "description": "The Zhang family is deciding to invest in several different restaurants. The annual revenue of Restaurant A is $15,000, Restaurant B is $40,000, Restaurant C is $30,000, and Restaurant D is $50,000. They need to decide whether to purchase each restaurant, with each restaurant being able to be purchased only once. Help them decide which restaurants to buy to maximize their annual income.\nThe cost of Restaurant A is 1.6 million, Restaurant B is 2.5 million, Restaurant C is 1.8 million, and Restaurant D is 3 million. The Zhang family's investment budget is 6 million.\n\nIf they purchase Restaurant D, then they cannot purchase Restaurant A.",
  "ground_truth": 90000.0,
  "formulation": null,
  "correct_program": "def optimize_restaurant_investment(revenue_A=15000,\n                                   revenue_B=40000,\n                                   revenue_C=30000,\n                                   revenue_D=50000,\n                                   cost_A=1.6,\n                                   cost_B=2.5,\n                                   cost_C=1.8,\n                                   cost_D=3.0,\n                                   budget=6):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"Restaurant Investment Optimization\")\n\n    # Decision variables: binary for each restaurant\n    y_A = model.addVar(vtype=GRB.BINARY, name=\"y_A\")\n    y_B = model.addVar(vtype=GRB.BINARY, name=\"y_B\")\n    y_C = model.addVar(vtype=GRB.BINARY, name=\"y_C\")\n    y_D = model.addVar(vtype=GRB.BINARY, name=\"y_D\")\n\n    # Set objective: maximize total revenue\n    model.setObjective(\n        revenue_A * y_A + revenue_B * y_B + revenue_C * y_C + revenue_D * y_D,\n        GRB.MAXIMIZE)\n\n    # Add budget constraint\n    model.addConstr(cost_A * y_A + cost_B * y_B + cost_C * y_C + cost_D * y_D\n                    <= budget,\n                    name=\"BudgetConstraint\")\n\n    # Add mutual exclusivity constraint\n    model.addConstr(y_A + y_D <= 1, name=\"MutualExclusion\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        return model.objVal\n    else:\n        return None\nif __name__ == \"__main__\":\n    result = optimize_restaurant_investment()\n    if result is not None:\n        print(f\"Optimal total revenue: {result}\")\n    else:\n        print(\"No feasible solution found.\")",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B062",
  "description": "A farmer needs to transport 1000 units of fresh produce from the farm to a nearby market. The farmer has three transportation options: a horse, a bicycle, and a handcart. Since both the bicycle and handcart are very physically demanding, the farmer wants to choose only one of these two transportation methods. The horse generates 80 units of pollution per trip, the bicycle generates 0 units of pollution, and the handcart generates 0 units of pollution. The total amount of pollution generated by all trips must not exceed 1000 units. At least 8 trips must be made using the horse. The horse, bicycle, and handcart can carry 55 units, 30 units, and 40 units of produce per trip respectively. The farmer needs to ensure that the total amount of transported produce is at least 1000 units.",
  "ground_truth": 640.0,
  "formulation": null,
  "correct_program": "def optimize_transportation():\n    from gurobipy import Model, GRB\n\n    # Parameters\n    total_produce = 1000\n    pollution_limit = 1000\n    min_horse_trips = 8\n    capacity_horse = 55\n    capacity_bicycle = 30\n    capacity_handcart = 40\n    pollution_horse = 80\n    M = 1000  # Large number for linking constraints\n\n    # Create model\n    m = Model(\"FarmerTransport\")\n\n    # Decision variables\n    x_H = m.addVar(vtype=GRB.INTEGER, lb=min_horse_trips, name=\"x_H\")\n    x_B = m.addVar(vtype=GRB.INTEGER, lb=0, name=\"x_B\")\n    x_C = m.addVar(vtype=GRB.INTEGER, lb=0, name=\"x_C\")\n    y_B = m.addVar(vtype=GRB.BINARY, name=\"y_B\")\n    y_C = m.addVar(vtype=GRB.BINARY, name=\"y_C\")\n\n    m.update()\n\n    # Objective: Minimize pollution from horse trips\n    m.setObjective(pollution_horse * x_H, GRB.MINIMIZE)\n\n    # Constraints\n    # Produce transportation\n    m.addConstr(\n        capacity_horse * x_H + capacity_bicycle * x_B + capacity_handcart * x_C\n        >= total_produce, \"ProduceTransport\")\n    # Pollution limit\n    m.addConstr(pollution_horse * x_H <= pollution_limit, \"PollutionLimit\")\n    # Mode selection\n    m.addConstr(y_B + y_C == 1, \"ModeSelection\")\n    # Linking trips to mode selection\n    m.addConstr(x_B <= M * y_B, \"LinkBicycle\")\n    m.addConstr(x_C <= M * y_C, \"LinkHandcart\")\n    # Minimum horse trips\n    m.addConstr(x_H >= min_horse_trips, \"MinHorseTrips\")\n\n    # Optimize\n    m.optimize()\n\n    # Check feasibility and return result\n    if m.status == GRB.OPTIMAL:\n        return m.objVal\n    else:\n        return None\nif __name__ == \"__main__\":\n    result = optimize_transportation()\n    if result is not None:\n        print(f\"Optimal total pollution: {result}\")\n    else:\n        print(\"No feasible solution found.\")",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B063",
  "description": "A company needs to decide whether to hire some of the five candidates to join their R&D team. The salary requirements for candidates F, G, H, I, and J are $12,000, $15,000, $18,000, $5,000, and $10,000 respectively. The company wants to minimize the total amount paid to candidates without exceeding the budget.\n\nThe company's budget is $40,000 and they wish to hire a maximum of 4 new employees.\n\nThe skill levels of the candidates are as follows:\nCandidate F: Level 2\nCandidate G: Level 3\nCandidate H: Level 4\nCandidate I: Level 1\nCandidate J: Level 2\n\nThe company needs to ensure that the total skill level of the hired employees is at least 8.\n\nThe project management experience years of each candidate are as follows:\nCandidate F: 1 year\nCandidate G: 2 years\nCandidate H: 2 years\nCandidate I: 5 years\nCandidate J: 4 years\n\nThey hope the total project management experience of the team is at least 8 years.\n\nDue to the similar technical background of candidates G and J, the company can choose at most one of them.",
  "ground_truth": 38000.0,
  "formulation": null,
  "correct_program": "def optimize_candidate_selection(salaries={\n    'F': 12000,\n    'G': 15000,\n    'H': 18000,\n    'I': 5000,\n    'J': 10000\n},\n                                 skills={\n                                     'F': 2,\n                                     'G': 3,\n                                     'H': 4,\n                                     'I': 1,\n                                     'J': 2\n                                 },\n                                 experiences={\n                                     'F': 1,\n                                     'G': 2,\n                                     'H': 2,\n                                     'I': 5,\n                                     'J': 4\n                                 },\n                                 budget=40000,\n                                 max_candidates=4,\n                                 min_skill=8,\n                                 min_experience=8):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Initialize model\n    model = gp.Model(\"Candidate_Selection\")\n\n    # Decision variables\n    candidates = ['F', 'G', 'H', 'I', 'J']\n    y = model.addVars(candidates, vtype=GRB.BINARY, name='hire')\n\n    # Objective: Minimize total salary\n    model.setObjective(gp.quicksum(salaries[c] * y[c] for c in candidates),\n                       GRB.MINIMIZE)\n\n    # Budget constraint\n    model.addConstr(gp.quicksum(salaries[c] * y[c] for c in candidates)\n                    <= budget,\n                    name='Budget')\n\n    # Team size constraint\n    model.addConstr(gp.quicksum(y[c] for c in candidates) <= max_candidates,\n                    name='MaxTeamSize')\n\n    # Skill level constraint\n    model.addConstr(gp.quicksum(skills[c] * y[c] for c in candidates)\n                    >= min_skill,\n                    name='SkillLevel')\n\n    # Experience constraint\n    model.addConstr(gp.quicksum(experiences[c] * y[c] for c in candidates)\n                    >= min_experience,\n                    name='Experience')\n\n    # Mutual exclusivity of G and J\n    model.addConstr(y['G'] + y['J'] <= 1, name='G_J_Exclusion')\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        total_salary = model.objVal\n        return total_salary\n    else:\n        return None\n    \nif __name__ == \"__main__\":\n    result = optimize_candidate_selection()\n    if result is not None:\n        print(f\"Optimal total salary: {result}\")\n    else:\n        print(\"No feasible solution found.\")",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B064",
  "description": "A company produces two types of products: microwave ovens and water heaters, which are manufactured in both workshops A and B. It is known that apart from the purchased parts, the production of one microwave oven requires 2 hours of processing in workshop A and 1 hour of assembly in workshop B. The production of one water heater requires 1 hour of processing in workshop A and 3 hours of assembly in workshop B. After production, both products need inspection, sales, and other procedures. The inspection and sales cost for each microwave oven is 30 yuan, and for each water heater is 50 yuan. Workshop A has 250 hours of available production time per month, with each hour costing 80 yuan; workshop B has 150 hours of available production time per month, with each hour costing 20 yuan. It is estimated that an average of 80 microwave ovens and 50 water heaters can be sold per month next year. Based on these actual conditions, the company has established the following monthly plan constraints:\n\n1. Inspection and sales costs should not exceed 5500 yuan per month;\n2. At least 80 microwave ovens should be sold per month;\n3. The production hours of both workshops A and B should be fully utilized;\n4. Overtime in workshop A should not exceed 20 hours;\n5. At least 50 water heaters should be sold per month.\n\nTry to determine the monthly production plan for the company.",
  "ground_truth": 30500.0,
  "formulation": null,
  "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nmodel = gp.Model(\"Manufacturing_Plan\")\n\n# Decision variables\n# x = number of microwave ovens to produce per month\n# y = number of water heaters to produce per month\n# oa = overtime hours in workshop A\nx = model.addVar(lb=0, vtype=GRB.INTEGER, name=\"microwave_ovens\")\ny = model.addVar(lb=0, vtype=GRB.INTEGER, name=\"water_heaters\")\noa = model.addVar(lb=0, ub=20, vtype=GRB.CONTINUOUS, name=\"overtime_A\")\nob = model.addVar(lb=0, vtype=GRB.CONTINUOUS, name=\"overtime_B\")\n\n# Parameters\n# Workshop hours required per product\nhours_A_microwave = 2  # hours in workshop A per microwave\nhours_B_microwave = 1  # hours in workshop B per microwave\nhours_A_heater = 1  # hours in workshop A per water heater\nhours_B_heater = 3  # hours in workshop B per water heater\n\n# Workshop capacities\ncapacity_A = 250  # regular hours in workshop A\ncapacity_B = 150  # hours in workshop B\n\n# Costs\ncost_per_hour_A = 80  # yuan per hour in workshop A\ncost_per_hour_B = 20  # yuan per hour in workshop B\ninspection_sales_microwave = 30  # yuan per microwave\ninspection_sales_heater = 50  # yuan per water heater\n\n# Sales estimates\nestimated_demand_microwave = 80  # microwave ovens per month\nestimated_demand_heater = 50  # water heaters per month\n\n# Constraints\n\n# 1. Inspection and sales costs constraint\nmodel.addConstr(\n    inspection_sales_microwave * x + inspection_sales_heater * y <= 5500,\n    \"inspection_sales_cost\")\n\n# 2. Minimum microwave oven sales requirement\nmodel.addConstr(x >= estimated_demand_microwave, \"min_microwave_sales\")\n\n# 3a. Workshop A hours must be fully utilized (including potential overtime)\nmodel.addConstr(hours_A_microwave * x + hours_A_heater * y == capacity_A + oa,\n                \"workshop_A_utilization\")\n\n# 3b. Workshop B hours must be fully utilized\nmodel.addConstr(hours_B_microwave * x + hours_B_heater * y == capacity_B + ob,\n                \"workshop_B_utilization\")\n\n# 4. Overtime constraint for workshop A (Already handled in variable definition with ub=20)\n\n# 5. Minimum water heater sales requirement\nmodel.addConstr(y >= estimated_demand_heater, \"min_heater_sales\")\n\n# Objective: Maximize profit\n# Revenue isn't specified, so we'll minimize costs instead\ntotal_cost = (\n    # Production costs\n    cost_per_hour_A * (capacity_A + oa) +  # Regular + overtime for workshop A\n    cost_per_hour_B * (capacity_B + ob) +  # Regular hours for workshop B\n    # Inspection and sales costs\n    inspection_sales_microwave * x + inspection_sales_heater * y)\n\nmodel.setObjective(total_cost, GRB.MINIMIZE)\n\n# Solve the model\nmodel.optimize()\n\n# Check if a solution was found\nif model.status == GRB.OPTIMAL:\n    print(\"\\n=== OPTIMAL MONTHLY PRODUCTION PLAN ===\")\n    print(f\"Microwave Ovens: {int(x.X)} units\")\n    print(f\"Water Heaters: {int(y.X)} units\")\n    print(f\"Overtime Hours in Workshop A: {oa.X:.2f} hours\")\n\n    # Calculate resource utilization\n    hours_used_A = hours_A_microwave * x.X + hours_A_heater * y.X\n    hours_used_B = hours_B_microwave * x.X + hours_B_heater * y.X\n\n    print(\"\\n=== RESOURCE UTILIZATION ===\")\n    print(\n        f\"Workshop A: {hours_used_A:.2f} hours used (including {oa.X:.2f} overtime hours)\"\n    )\n    print(f\"Workshop B: {hours_used_B:.2f} hours used (out of {capacity_B})\")\n\n    # Calculate costs\n    production_cost_A = cost_per_hour_A * hours_used_A\n    production_cost_B = cost_per_hour_B * hours_used_B\n    inspection_sales_cost = inspection_sales_microwave * x.X + inspection_sales_heater * y.X\n\n    print(\"\\n=== COST BREAKDOWN ===\")\n    print(f\"Workshop A Production Cost: {production_cost_A:.2f} yuan\")\n    print(f\"Workshop B Production Cost: {production_cost_B:.2f} yuan\")\n    print(f\"Inspection and Sales Cost: {inspection_sales_cost:.2f} yuan\")\n    print(f\"Total Cost: {model.objVal:.2f} yuan\")\n\n    # Check constraint satisfaction\n    print(\"\\n=== CONSTRAINT VERIFICATION ===\")\n    print(\n        f\"1. Inspection and Sales Cost: {inspection_sales_cost:.2f} yuan (Max: 5500 yuan)\"\n    )\n    print(\n        f\"2. Microwave Oven Production: {int(x.X)} units (Min: {estimated_demand_microwave} units)\"\n    )\n    print(\n        f\"3. Workshop A Utilization: {hours_used_A:.2f} hours (Regular: {capacity_A} hours, Overtime: {oa.X:.2f} hours)\"\n    )\n    print(\n        f\"   Workshop B Utilization: {hours_used_B:.2f} hours (Capacity: {capacity_B} hours)\"\n    )\n    print(f\"4. Workshop A Overtime: {oa.X:.2f} hours (Max: 20 hours)\")\n    print(\n        f\"5. Water Heater Production: {int(y.X)} units (Min: {estimated_demand_heater} units)\"\n    )\n\n    # Check for binding constraints\n    print(\"\\n=== BINDING CONSTRAINTS ===\")\n    for c in model.getConstrs():\n        if abs(c.slack) < 1e-6:\n            print(f\"- {c.ConstrName} is binding\")\n\nelif model.status == GRB.INFEASIBLE:\n    print(\n        \"The model is infeasible - there is no solution that satisfies all constraints.\"\n    )\n    # Compute and display the Irreducible Inconsistent Subsystem (IIS)\n    print(\"Computing IIS to find conflicting constraints...\")\n    model.computeIIS()\n    print(\"\\nThe following constraints are in conflict:\")\n    for c in model.getConstrs():\n        if c.IISConstr:\n            print(f\"- {c.ConstrName}\")\nelse:\n    print(\n        f\"Optimization did not complete normally. Status code: {model.status}\")",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B065",
  "description": "A toy company manufactures three types of tabletop golf toys, each requiring different manufacturing techniques. The high-end type requires 17 hours of manufacturing labor, 8 hours of inspection, and yields a profit of 300 yuan per unit. The mid-range type requires 10 hours of labor, 4 hours of inspection, and yields a profit of 200 yuan per unit. The low-end type requires 2 hours of labor, 2 hours of inspection, and yields a profit of 100 yuan per unit. Available labor hours are 1000, and available inspection hours are 500. Additionally, market forecasts indicate a demand of no more than 50 units for the high-end type, no more than 80 units for the mid-range type, and no more than 150 units for the low-end type. Determine the production plan for the company to maximize profit.",
  "ground_truth": 25000.0,
  "formulation": null,
  "correct_program": "def optimize_toy_production(labor_hours=1000,\n                            inspection_hours=500,\n                            demand_high=50,\n                            demand_mid=80,\n                            demand_low=150,\n                            profit_high=300,\n                            profit_mid=200,\n                            profit_low=100,\n                            labor_high=17,\n                            labor_mid=10,\n                            labor_low=2,\n                            inspect_high=8,\n                            inspect_mid=4,\n                            inspect_low=2):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"Toy_Production_Maximize_Profit\")\n\n    # Decision variables: number of units to produce for each type\n    x_H = model.addVar(vtype=GRB.INTEGER, name=\"HighEnd\", lb=0, ub=demand_high)\n    x_M = model.addVar(vtype=GRB.INTEGER, name=\"MidRange\", lb=0, ub=demand_mid)\n    x_L = model.addVar(vtype=GRB.INTEGER, name=\"LowEnd\", lb=0, ub=demand_low)\n\n    # Set objective: maximize total profit\n    model.setObjective(profit_high * x_H + profit_mid * x_M + profit_low * x_L,\n                       GRB.MAXIMIZE)\n\n    # Add labor hours constraint\n    model.addConstr(labor_high * x_H + labor_mid * x_M + labor_low * x_L\n                    <= labor_hours,\n                    name=\"LaborHours\")\n\n    # Add inspection hours constraint\n    model.addConstr(inspect_high * x_H + inspect_mid * x_M + inspect_low * x_L\n                    <= inspection_hours,\n                    name=\"InspectionHours\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the maximum profit value\n        return model.objVal\n    else:\n        # No feasible solution found\n        return None\nif __name__ == \"__main__\":\n    result = optimize_toy_production()\n    if result is not None:\n        print(f\"Optimal total profit: {result}\")\n    else:\n        print(\"No feasible solution found.\")",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B066",
  "description": "The market demand for products I and II is as follows: Product I requires 10,000 units per month from January to April, 30,000 units per month from May to September, and 100,000 units per month from October to December. Product II requires 15,000 units per month from March to September and 50,000 units per month during other months. The cost of producing these two products at a certain factory is as follows: Product I costs 5 yuan per unit to produce from January to May, and 4.50 yuan per unit from June to December; Product II costs 8 yuan per unit to produce from January to May, and 7 yuan per unit from June to December. The factory's combined production capacity for both products should not exceed 120,000 units per month. Product I has a volume of 0.2 cubic meters per unit, Product II has a volume of 0.4 cubic meters per unit, and the factory's warehouse capacity is 15,000 cubic meters. If the factory's warehouse space is insufficient, external warehouse space can be rented. Using the factory’s own warehouse costs 1 yuan per cubic meter per month, while renting an external warehouse increases this cost to 1.5 yuan per cubic meter per month. Given that the initial inventory of both products at the beginning of July is zero, how should production be scheduled from July to December to minimize the total production and inventory costs while meeting market demand?",
  "ground_truth": 3120000.0,
  "formulation": null,
  "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_production_inventory_planning():\n    \"\"\"\n    Solves a multi-period production and inventory planning problem\n    to minimize total production and inventory costs.\n    \"\"\"\n    try:\n        # --- Data ---\n        products = ['ProdI', 'ProdII']\n        # Months: July (0) to December (5)\n        months = list(range(6))\n        month_names = ['Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\n\n        # Demand (units/month) for ProdI, ProdII\n        demand_data = {\n            'ProdI': [30000, 30000, 30000, 100000, 100000, 100000],  # Jul-Dec\n            'ProdII': [15000, 15000, 15000, 50000, 50000,\n                       50000]  # Jul-Dec (Mar-Sep is 15k, other is 50k)\n        }\n\n        # Production cost (yuan/unit) for ProdI, ProdII\n        # ProdI: Jan-May 5, Jun-Dec 4.5\n        # ProdII: Jan-May 8, Jun-Dec 7\n        production_cost_data = {\n            'ProdI': [4.50] * 6,  # Jul-Dec\n            'ProdII': [7.00] * 6  # Jul-Dec\n        }\n\n        max_combined_production_capacity = 120000  # units/month\n\n        product_volume = {'ProdI': 0.2, 'ProdII': 0.4}  # m^3/unit\n\n        factory_warehouse_capacity = 15000  # m^3\n        factory_warehouse_cost = 1.0  # yuan/m^3/month\n        external_warehouse_cost = 1.5  # yuan/m^3/month\n\n        initial_inventory = {'ProdI': 0, 'ProdII': 0}  # units at start of July\n\n        # --- Create Gurobi Model ---\n        model = gp.Model(\"ProductionInventoryOptimization\")\n\n        # --- Decision Variables ---\n        # Produce[p,t]: units of product p produced in month t\n        produce_vars = model.addVars(products,\n                                     months,\n                                     name=\"Produce\",\n                                     lb=0.0,\n                                     vtype=GRB.INTEGER)\n\n        # InvFact[p,t]: units of product p in factory inventory at end of month t\n        inv_fact_vars = model.addVars(products,\n                                      months,\n                                      name=\"InvFact\",\n                                      lb=0.0,\n                                      vtype=GRB.INTEGER)\n\n        # InvExt[p,t]: units of product p in external inventory at end of month t\n        inv_ext_vars = model.addVars(products,\n                                     months,\n                                     name=\"InvExt\",\n                                     lb=0.0,\n                                     vtype=GRB.INTEGER)\n\n        # --- Objective Function: Minimize Total Costs ---\n        total_production_cost = gp.quicksum(\n            production_cost_data[p][t] * produce_vars[p, t] for p in products\n            for t in months)\n\n        total_factory_inv_cost = gp.quicksum(\n            factory_warehouse_cost * product_volume[p] * inv_fact_vars[p, t]\n            for p in products for t in months)\n\n        total_external_inv_cost = gp.quicksum(\n            external_warehouse_cost * product_volume[p] * inv_ext_vars[p, t]\n            for p in products for t in months)\n\n        model.setObjective(\n            total_production_cost + total_factory_inv_cost +\n            total_external_inv_cost, GRB.MINIMIZE)\n\n        # --- Constraints ---\n        for t in months:\n            # 1. Combined Production Capacity Constraint\n            model.addConstr(gp.quicksum(produce_vars[p, t] for p in products)\n                            <= max_combined_production_capacity,\n                            name=f\"ProdCap_Month{t}\")\n\n            # 2. Factory Warehouse Capacity Constraint\n            model.addConstr(gp.quicksum(product_volume[p] * inv_fact_vars[p, t]\n                                        for p in products)\n                            <= factory_warehouse_capacity,\n                            name=f\"FactWHCap_Month{t}\")\n\n            for p in products:\n                # 3. Inventory Balance Constraint\n                previous_total_inventory = initial_inventory[\n                    p] if t == 0 else (inv_fact_vars[p, t - 1] +\n                                       inv_ext_vars[p, t - 1])\n\n                model.addConstr(\n                    inv_fact_vars[p, t] +\n                    inv_ext_vars[p, t] == previous_total_inventory +\n                    produce_vars[p, t] - demand_data[p][t],\n                    name=f\"InvBalance_{p}_Month{t}\")\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal production and inventory plan found.\")\n            print(\n                f\"Minimum Total Cost (Production + Inventory): {model.ObjVal:.2f} Yuan\"\n            )\n\n            print(\"\\nMonthly Production Schedule (units):\")\n            print(f\"{'Month':<5} | {'Product I':<12} | {'Product II':<12}\")\n            print(\"-\" * 35)\n            for t in months:\n                print(\n                    f\"{month_names[t]:<5} | {produce_vars['ProdI',t].X:<12.2f} | {produce_vars['ProdII',t].X:<12.2f}\"\n                )\n\n            print(\"\\nEnd-of-Month Inventory Levels (units):\")\n            print(\n                f\"{'Month':<5} | {'ProdI Fact':<12} | {'ProdI Ext':<12} | {'ProdII Fact':<12} | {'ProdII Ext':<12} | {'Fact Vol':<10} | {'Ext Vol':<10}\"\n            )\n            print(\"-\" * 85)\n            for t in months:\n                vol_fact = product_volume['ProdI'] * inv_fact_vars[\n                    'ProdI', t].X + product_volume['ProdII'] * inv_fact_vars[\n                        'ProdII', t].X\n                vol_ext = product_volume['ProdI'] * inv_ext_vars[\n                    'ProdI', t].X + product_volume['ProdII'] * inv_ext_vars[\n                        'ProdII', t].X\n                print(\n                    f\"{month_names[t]:<5} | \"\n                    f\"{inv_fact_vars['ProdI',t].X:<12.2f} | {inv_ext_vars['ProdI',t].X:<12.2f} | \"\n                    f\"{inv_fact_vars['ProdII',t].X:<12.2f} | {inv_ext_vars['ProdII',t].X:<12.2f} | \"\n                    f\"{vol_fact:<10.2f} | {vol_ext:<10.2f}\")\n\n            print(\n                f\"\\nFactory Warehouse Capacity: {factory_warehouse_capacity} m^3\"\n            )\n\n            total_prod_cost_val = sum(production_cost_data[p][t] *\n                                      produce_vars[p, t].X for p in products\n                                      for t in months)\n            total_fact_inv_cost_val = sum(\n                factory_warehouse_cost * product_volume[p] *\n                inv_fact_vars[p, t].X for p in products for t in months)\n            total_ext_inv_cost_val = sum(\n                external_warehouse_cost * product_volume[p] *\n                inv_ext_vars[p, t].X for p in products for t in months)\n            print(f\"\\nCost Breakdown:\")\n            print(f\"  Total Production Cost: {total_prod_cost_val:.2f} Yuan\")\n            print(\n                f\"  Total Factory Inventory Cost: {total_fact_inv_cost_val:.2f} Yuan\"\n            )\n            print(\n                f\"  Total External Inventory Cost: {total_ext_inv_cost_val:.2f} Yuan\"\n            )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\n                \"Model is infeasible. Check constraints and data for contradictions.\"\n            )\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            # model.computeIIS()\n            # model.write(\"prod_inv_iis.ilp\")\n            # print(\"IIS written to prod_inv_iis.ilp.\")\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_production_inventory_planning()",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B067",
  "description": "There are two coal yards A and B, each receiving no less than 80 tons and 100 tons of coal per month, respectively. They are responsible for supplying coal to three residential areas, which need 55 tons, 75 tons, and 50 tons of coal per month, respectively. Coal yard A is located 10 kilometers, 5 kilometers, and 6 kilometers from these three residential areas. Coal yard B is located 4 kilometers, 8 kilometers, and 15 kilometers from these three residential areas. How should these two coal yards distribute coal to the three residential areas to minimize the ton-kilometers of transportation?",
  "ground_truth": 1030.0,
  "formulation": null,
  "correct_program": "def optimize_coal_distribution(supply_A=80,\n                               supply_B=100,\n                               demand_1=55,\n                               demand_2=75,\n                               demand_3=50):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"Coal_Distribution_Minimize_TonKilometers\")\n\n    # Decision variables: amount of coal shipped from each yard to each area\n    x_A1 = model.addVar(lb=0, name=\"x_A1\")\n    x_A2 = model.addVar(lb=0, name=\"x_A2\")\n    x_A3 = model.addVar(lb=0, name=\"x_A3\")\n    x_B1 = model.addVar(lb=0, name=\"x_B1\")\n    x_B2 = model.addVar(lb=0, name=\"x_B2\")\n    x_B3 = model.addVar(lb=0, name=\"x_B3\")\n\n    # Set objective: minimize total ton-kilometers\n    model.setObjective(\n        10 * x_A1 + 5 * x_A2 + 6 * x_A3 + 4 * x_B1 + 8 * x_B2 + 15 * x_B3,\n        GRB.MINIMIZE)\n\n    # Supply constraints\n    model.addConstr(x_A1 + x_A2 + x_A3 >= supply_A, \"Supply_A\")\n    model.addConstr(x_B1 + x_B2 + x_B3 >= supply_B, \"Supply_B\")\n\n    # Demand constraints\n    model.addConstr(x_A1 + x_B1 == demand_1, \"Demand_1\")\n    model.addConstr(x_A2 + x_B2 == demand_2, \"Demand_2\")\n    model.addConstr(x_A3 + x_B3 == demand_3, \"Demand_3\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        return model.objVal\n    else:\n        return None\nif __name__ == \"__main__\":\n    result = optimize_coal_distribution()\n    if result is not None:\n        print(f\"Optimal total ton-kilometers: {result}\")\n    else:\n        print(\"No feasible solution found.\")",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B068",
  "description": "A steel reinforcement workshop produces a batch of steel bars (with the same diameter), consisting of 90 pieces of 3 meters in length and 60 pieces of 4 meters in length. It is known that each piece of raw steel bar used is 10 meters in length. How can the raw material be cut most efficiently? Establish a linear programming model for this problem.",
  "ground_truth": 53.0,
  "formulation": null,
  "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_steel_bar_cutting():\n    \"\"\"\n    Solves the steel bar cutting stock problem to minimize the number of raw bars used.\n    \"\"\"\n    try:\n        # --- Data ---\n        # Demands for cut pieces\n        demand_3m = 90  # pieces\n        demand_4m = 60  # pieces\n\n        # Raw steel bar length (not directly used in this formulation with pre-defined patterns,\n        # but useful for understanding pattern generation)\n        # raw_bar_length = 10 # meters\n\n        # Cutting Patterns:\n        # Pattern: (yield_3m_pieces, yield_4m_pieces)\n        # Pattern A: 3 pieces of 3m, 0 pieces of 4m. Waste: 1m.\n        # Pattern B: 2 pieces of 3m, 1 piece of 4m. Waste: 0m.\n        # Pattern C: 0 pieces of 3m, 2 pieces of 4m. Waste: 2m.\n\n        patterns = {\n            'A': {\n                'yield_3m': 3,\n                'yield_4m': 0,\n                'waste': 1\n            },\n            'B': {\n                'yield_3m': 2,\n                'yield_4m': 1,\n                'waste': 0\n            },\n            'C': {\n                'yield_3m': 0,\n                'yield_4m': 2,\n                'waste': 2\n            }\n        }\n        pattern_ids = list(patterns.keys())\n\n        # --- Create Gurobi Model ---\n        model = gp.Model(\"SteelBarCuttingStock\")\n\n        # --- Decision Variables ---\n        # x[p_id]: number of raw steel bars cut using pattern p_id\n        x = model.addVars(pattern_ids, name=\"NumCuts\", vtype=GRB.INTEGER, lb=0)\n\n        # --- Objective Function: Minimize Total Number of Raw Bars Used ---\n        model.setObjective(gp.quicksum(x[p_id] for p_id in pattern_ids),\n                           GRB.MINIMIZE)\n\n        # Alternative objective: Minimize total waste\n        # total_waste = gp.quicksum(patterns[p_id]['waste'] * x[p_id] for p_id in pattern_ids)\n        # model.setObjective(total_waste, GRB.MINIMIZE)\n\n        # --- Constraints ---\n        # 1. Demand for 3-meter pieces\n        model.addConstr(gp.quicksum(patterns[p_id]['yield_3m'] * x[p_id]\n                                    for p_id in pattern_ids) >= demand_3m,\n                        name=\"Demand_3m\")\n\n        # 2. Demand for 4-meter pieces\n        model.addConstr(gp.quicksum(patterns[p_id]['yield_4m'] * x[p_id]\n                                    for p_id in pattern_ids) >= demand_4m,\n                        name=\"Demand_4m\")\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal cutting plan found.\")\n            print(\n                f\"Minimum number of raw steel bars to use: {model.ObjVal:.0f}\")\n\n            print(\"\\nNumber of times each pattern is used:\")\n            total_waste_calculated = 0\n            for p_id in pattern_ids:\n                if x[p_id].X > 0.5:  # If pattern is used\n                    print(\n                        f\"  Pattern {p_id} (Yields: {patterns[p_id]['yield_3m']} of 3m, {patterns[p_id]['yield_4m']} of 4m; Waste/bar: {patterns[p_id]['waste']}m): \"\n                        f\"{x[p_id].X:.0f} times\")\n                    total_waste_calculated += patterns[p_id]['waste'] * x[\n                        p_id].X\n\n            print(\n                f\"\\nCalculated Total Waste: {total_waste_calculated:.0f} meters (based on minimizing raw bars)\"\n            )\n\n            print(\"\\nVerification of Production:\")\n            produced_3m = sum(patterns[p_id]['yield_3m'] * x[p_id].X\n                              for p_id in pattern_ids)\n            produced_4m = sum(patterns[p_id]['yield_4m'] * x[p_id].X\n                              for p_id in pattern_ids)\n            print(\n                f\"  Total 3m pieces produced: {produced_3m:.0f} (Demand: {demand_3m})\"\n            )\n            print(\n                f\"  Total 4m pieces produced: {produced_4m:.0f} (Demand: {demand_60})\"\n            )  # Corrected to demand_4m\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\"Model is infeasible. Check patterns and demands.\")\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            # model.computeIIS()\n            # model.write(\"steel_cutting_iis.ilp\")\n            # print(\"IIS written to steel_cutting_iis.ilp.\")\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    # Correcting a typo in the verification print statement\n    demand_60 = 60  # This variable was used in print but not defined, should be demand_4m\n    solve_steel_bar_cutting()",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B069",
  "description": "The famous Traveling Salesman Problem (TSP) in operations research can be described as follows: A traveling salesman departs from a certain city, visits two other cities to sell merchandise, and must visit each city exactly once before returning to the original starting city. The distances between the cities are provided in the table below.\n| City |    1    |    2    |    3    |    4    |\n| ---- | ------ | ------ | ------ | ------ |\n| 1    | 0    | 10   | 20   | 12   |\n| 2    | 10   | 0    | 5    | 10   |\n| 3    | 20   | 5    | 0    | 8    |\n| 4    | 15   | 12   | 8    | 0    |\n\nWhat route should the salesman choose to travel in order to minimize the total distance? Try to formulate an integer programming model for this problem.",
  "ground_truth": 35.0,
  "formulation": null,
  "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_tsp_mtz():\n    \"\"\"\n    Solves the Traveling Salesman Problem (TSP) for 4 cities\n    using the Miller-Tucker-Zemlin (MTZ) formulation for subtour elimination.\n    The objective is to minimize the total travel distance.\n    \"\"\"\n    try:\n        # --- Data ---\n        # Number of cities\n        num_cities = 4\n        cities = range(num_cities)  # Indices 0, 1, 2, 3\n\n        # Distance matrix d[i][j] is distance from city i to city j.\n        # Mapping: City 1 -> 0, City 2 -> 1, City 3 -> 2, City 4 -> 3\n        # Original Table:\n        # | City |  1  |  2  |  3  |  4  |\n        # | ---- | --- | --- | --- | --- |\n        # | 1    | 0   | 10  | 20  | 12  |\n        # | 2    | 10  | 0   | 5   | 10  |\n        # | 3    | 20  | 5   | 0   | 8   |\n        # | 4    | 15  | 12  | 8   | 0   |\n\n        # Distances (costs) between cities. d[i][j] is cost from i to j.\n        # Using a dictionary for clarity with non-sequential/sparse connections if any.\n        # For a full matrix, a list of lists is also fine.\n        distances = {\n            (0, 1): 10,\n            (0, 2): 20,\n            (0, 3): 12,  # From City 1 (index 0)\n            (1, 0): 10,\n            (1, 2): 5,\n            (1, 3): 10,  # From City 2 (index 1)\n            (2, 0): 20,\n            (2, 1): 5,\n            (2, 3): 8,  # From City 3 (index 2)\n            (3, 0): 15,\n            (3, 1): 12,\n            (3, 2): 8  # From City 4 (index 3)\n        }\n        # Note: d[i,i] is implicitly infinity or such arcs are excluded.\n\n        # --- Create Gurobi Model ---\n        model = gp.Model(\"TSP_MTZ\")\n\n        # --- Decision Variables ---\n        # x[i,j]: 1 if salesman travels from city i to city j, 0 otherwise\n        x = model.addVars(cities, cities, vtype=GRB.BINARY, name=\"x\")\n\n        # u[i]: auxiliary variable for MTZ subtour elimination (position of city i in tour)\n        # u[0] will be fixed to 0 (or 1). Let's use 1 for positions 1 to N.\n        u = model.addVars(cities,\n                          vtype=GRB.CONTINUOUS,\n                          name=\"u\",\n                          lb=1.0,\n                          ub=num_cities)\n\n        # --- Preprocessing: Remove x[i,i] variables (travel from a city to itself) ---\n        for i in cities:\n            x[i, i].ub = 0\n\n        # --- Objective Function: Minimize Total Travel Distance ---\n        model.setObjective(\n            gp.quicksum(\n                distances.get((i, j), 0) * x[i, j] for i in cities\n                for j in cities if i != j), GRB.MINIMIZE)\n\n        # --- Constraints ---\n        # 1. Depart from each city exactly once\n        for i in cities:\n            model.addConstr(gp.quicksum(x[i, j] for j in cities\n                                        if j != i) == 1,\n                            name=f\"DepartOnce_{i}\")\n\n        # 2. Enter each city exactly once\n        for j in cities:\n            model.addConstr(gp.quicksum(x[i, j] for i in cities\n                                        if i != j) == 1,\n                            name=f\"EnterOnce_{j}\")\n\n        # 3. Subtour Elimination (MTZ constraints)\n        # Let city 0 be the \"depot\" for sequencing purposes.\n        model.addConstr(\n            u[0] == 1,\n            name=\"FixDepotOrder\")  # Fix position of depot city (index 0)\n\n        for i in cities:\n            if i == 0:\n                continue  # Skip depot for these u bounds if u[0] is fixed differently\n            model.addConstr(u[i] >= 2,\n                            name=f\"u_lower_bound_{i}\")  # Positions 2 to N\n            model.addConstr(u[i] <= num_cities, name=f\"u_upper_bound_{i}\")\n\n        for i in cities:\n            for j in cities:\n                if i == j or j == 0:  # Constraint is typically for non-depot j\n                    continue\n                # If x[i,j] = 1, then u[j] >= u[i] + 1\n                # u[i] - u[j] + num_cities * x[i,j] <= num_cities - 1\n                model.addConstr(u[i] - u[j] + num_cities * x[i, j]\n                                <= num_cities - 1,\n                                name=f\"MTZ_{i}_{j}\")\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal TSP route found.\")\n            print(f\"Minimum Total Distance: {model.ObjVal:.2f}\")\n\n            print(\"\\nOptimal Route (Original City Numbers):\")\n            # Reconstruct the path\n            current_city_idx = 0  # Start from city 0 (Original City 1)\n            route = [current_city_idx + 1]  # Store original city numbers\n\n            for _ in range(num_cities - 1):\n                found_next = False\n                for j in cities:\n                    if j != current_city_idx and x[current_city_idx,\n                                                   j].X > 0.5:\n                        route.append(j + 1)\n                        current_city_idx = j\n                        found_next = True\n                        break\n                if not found_next:\n                    print(\"Error: Could not reconstruct full route.\")\n                    break\n\n            if len(\n                    route\n            ) == num_cities:  # and current_city_idx is now the last city before returning to start\n                # Check if it returns to start\n                if x[current_city_idx, 0].X > 0.5:\n                    route.append(route[0])  # Add starting city to show cycle\n                    print(\" -> \".join(map(str, route)))\n                else:\n                    print(\n                        \"Error: Route does not return to start or is incomplete.\"\n                    )\n                    print(\"Partial route:\", \" -> \".join(map(str, route)))\n            else:\n                print(\"Error: Route reconstruction failed or incomplete.\")\n                print(\"Partial route:\", \" -> \".join(map(str, route)))\n\n            print(\"\\nSequence variables u_i (Original City Numbers):\")\n            for i in cities:\n                print(f\"  City {i+1}: u = {u[i].X:.1f}\")\n\n            print(\"\\nArcs used (Original City Numbers):\")\n            for i in cities:\n                for j in cities:\n                    if i != j and x[i, j].X > 0.5:\n                        print(\n                            f\"  {i+1} -> {j+1} (Distance: {distances.get((i,j),0)})\"\n                        )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\"Model is infeasible. Check constraints and data.\")\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            # model.computeIIS()\n            # model.write(\"tsp_mtz_iis.ilp\")\n            # print(\"IIS written to tsp_mtz_iis.ilp.\")\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_tsp_mtz()",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B071",
  "description": "The Li family plans to invest their retirement fund in commercial real estate. The annual income from Property 1 is $12,500, Property 2 is $35,000, Property 3 is $23,000, and Property 4 is $100,000. The decision to be made is whether to buy each property or not, rather than how many to buy, as there is only one of each property available. Help them decide which properties to purchase to maximize their annual income.\n\nThe cost of Property 1 is $1.5 million, Property 2 is $2.1 million, Property 3 is $2.3 million, and Property 4 is $4.2 million. The Li family's budget is $7 million.\n\nIf they purchase Property 4, they cannot purchase Property 3.",
  "ground_truth": 135000.0,
  "formulation": null,
  "correct_program": "def optimize_property_selection(income_property1=12500,\n                                income_property2=35000,\n                                income_property3=23000,\n                                income_property4=100000,\n                                cost_property1=1.5,\n                                cost_property2=2.1,\n                                cost_property3=2.3,\n                                cost_property4=4.2,\n                                budget=7):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"Property_Selection_MaxIncome\")\n\n    # Decision variables: binary for each property\n    y1 = model.addVar(vtype=GRB.BINARY, name=\"Property1\")\n    y2 = model.addVar(vtype=GRB.BINARY, name=\"Property2\")\n    y3 = model.addVar(vtype=GRB.BINARY, name=\"Property3\")\n    y4 = model.addVar(vtype=GRB.BINARY, name=\"Property4\")\n\n    # Set objective: maximize total income\n    model.setObjective(\n        income_property1 * y1 + income_property2 * y2 + income_property3 * y3 +\n        income_property4 * y4, GRB.MAXIMIZE)\n\n    # Add budget constraint\n    model.addConstr(cost_property1 * y1 + cost_property2 * y2 +\n                    cost_property3 * y3 + cost_property4 * y4 <= budget,\n                    name=\"BudgetConstraint\")\n\n    # Add property exclusivity constraint\n    model.addConstr(y4 + y3 <= 1, name=\"Property3_Property4_Exclusion\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the maximum total income\n        return model.objVal\n    else:\n        # No feasible solution found\n        return None\nif __name__ == \"__main__\":\n    result = optimize_property_selection()\n    if result is not None:\n        print(f\"Optimal total income: {result}\")\n    else:\n        print(\"No feasible solution found.\")",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B072",
  "description": "The Li family has 5 children: Alice, Bob, Charlie, Diana, and Ella. The cost to take Alice is $1000, Bob is $900, Charlie is $600, Diana is $500, and Ella is $700. Which children should the couple take to minimize the total cost of taking the children?\n\nThey can take up to 3 children on the upcoming trip.\n\nBob is the youngest, so the Li family will definitely take him.\n\nIf the couple takes Alice, they will not take Diana because Alice does not get along with her.\n\nIf the couple takes Bob, they will not take Charlie because Bob does not get along with him.\n\nIf they take Charlie, they must also take Diana.\n\nIf they take Diana, they must also take Ella.\n\nDespite the cost, the Li family has decided to take at least two children.",
  "ground_truth": 1600.0,
  "formulation": null,
  "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_child_selection():\n    \"\"\"\n    Solves the Li family child selection problem to minimize cost\n    subject to various constraints.\n    \"\"\"\n    try:\n        # --- Data ---\n        children = ['Alice', 'Bob', 'Charlie', 'Diana', 'Ella']\n        costs = {\n            'Alice': 1000,\n            'Bob': 900,\n            'Charlie': 600,\n            'Diana': 500,\n            'Ella': 700\n        }\n\n        max_children_allowed = 3\n        min_children_required = 2\n\n        # --- Create Gurobi Model ---\n        model = gp.Model(\"ChildSelection\")\n\n        # --- Decision Variables ---\n        # x[c]: 1 if child c is taken, 0 otherwise\n        x = model.addVars(children, vtype=GRB.BINARY, name=\"TakeChild\")\n\n        # --- Objective Function: Minimize Total Cost ---\n        model.setObjective(gp.quicksum(costs[c] * x[c] for c in children),\n                           GRB.MINIMIZE)\n\n        # --- Constraints ---\n        # 1. Max Children: Take up to 3 children\n        model.addConstr(gp.quicksum(x[c] for c in children)\n                        <= max_children_allowed,\n                        name=\"MaxChildren\")\n\n        # 2. Must Take Bob\n        model.addConstr(x['Bob'] == 1, name=\"MustTakeBob\")\n\n        # 3. Alice vs Diana: If Alice is taken, Diana is not (x_A + x_D <= 1)\n        model.addConstr(x['Alice'] + x['Diana'] <= 1, name=\"Alice_vs_Diana\")\n\n        # 4. Bob vs Charlie: If Bob is taken, Charlie is not.\n        # Since Bob must be taken (Constraint 2), this implies Charlie cannot be taken.\n        model.addConstr(x['Charlie'] == 0, name=\"NoCharlie_due_to_Bob\")\n        # Original constraint: x['Charlie'] <= (1 - x['Bob']). Since x['Bob'] = 1, this becomes x['Charlie'] <= 0.\n\n        # 5. Charlie implies Diana: If Charlie is taken, Diana must be taken (x_C <= x_D)\n        # This constraint becomes redundant due to Constraint 4 (x_C = 0), but included for completeness.\n        model.addConstr(x['Charlie'] <= x['Diana'],\n                        name=\"Charlie_implies_Diana\")\n\n        # 6. Diana implies Ella: If Diana is taken, Ella must be taken (x_D <= x_E)\n        model.addConstr(x['Diana'] <= x['Ella'], name=\"Diana_implies_Ella\")\n\n        # 7. Min Children: Take at least two children\n        model.addConstr(gp.quicksum(x[c] for c in children)\n                        >= min_children_required,\n                        name=\"MinChildren\")\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal selection found.\")\n            print(f\"Minimum Total Cost: ${model.ObjVal:.2f}\")\n\n            print(\"\\nChildren to take:\")\n            selected_children = []\n            for c in children:\n                if x[c].X > 0.5:  # Check if x[c] is 1\n                    selected_children.append(c)\n                    print(f\"  - {c} (Cost: ${costs[c]})\")\n            print(\n                f\"\\nTotal number of children taken: {len(selected_children)}\")\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\n                \"Model is infeasible. The constraints cannot be satisfied simultaneously.\"\n            )\n            print(\"Please review the constraints:\")\n            print(f\" - Max Children <= {max_children_allowed}\")\n            print(f\" - Min Children >= {min_children_required}\")\n            print(f\" - Must take Bob (Cost: ${costs['Bob']})\")\n            print(f\" - Cannot take Charlie (due to Bob)\")\n            print(f\" - If Alice taken, Diana not taken\")\n            print(f\" - If Diana taken, Ella must be taken\")\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            model.computeIIS()\n            model.write(\"child_selection_iis.ilp\")\n            print(\"IIS written to child_selection_iis.ilp.\")\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_child_selection()",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B073",
  "description": "A project includes the following 7 activities, with their durations (in days) as follows: $A(4), B(3), C(5), D(2), E(10), F(10), G(1)$. The precedence relationships are also given as: $A \\rightarrow G, D ; E, G \\rightarrow F; D, F \\rightarrow C ; F \\rightarrow B$. The cost of work per day is 1000 Euros; additionally, a special machine must be rented from the start of activity $A$ to the end of activity $B$, costing 5000 Euros per day. Formulate this as a linear programming problem and solve it using COPTPY.",
  "ground_truth": 115000.0,
  "formulation": null,
  "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_project_scheduling_cost_minimization():\n    \"\"\"\n    Solves the project scheduling problem to minimize total cost,\n    including work costs and special machine rental costs.\n    \"\"\"\n    try:\n        # --- Data ---\n        activities = ['A', 'B', 'C', 'D', 'E', 'F', 'G']\n\n        durations = {\n            'A': 4,\n            'B': 3,\n            'C': 5,\n            'D': 2,\n            'E': 10,\n            'F': 10,\n            'G': 1\n        }  # days\n\n        cost_work_per_day = 1000  # Euros/day\n        cost_machine_per_day = 5000  # Euros/day\n\n        # Precedence relationships: predecessor -> successor(s)\n        # A -> G, D\n        # E, G -> F (meaning F starts after both E and G are complete)\n        # D, F -> C\n        # F -> B\n\n        # --- Create Gurobi Model ---\n        model = gp.Model(\"ProjectSchedulingCostMinimization\")\n\n        # --- Decision Variables ---\n        # S[act]: Start time of activity act\n        S = model.addVars(activities,\n                          name=\"StartTime\",\n                          lb=0.0,\n                          vtype=GRB.INTEGER)\n\n        # Makespan: Total project duration\n        Makespan = model.addVar(name=\"Makespan\", lb=0.0, vtype=GRB.INTEGER)\n\n        # MachineRentalDuration: Duration for which the special machine is rented\n        MachineRentalDuration = model.addVar(name=\"MachineRentalDuration\",\n                                             lb=0.0,\n                                             vtype=GRB.INTEGER)\n\n        # --- Objective Function: Minimize Total Cost ---\n        # TotalCost = (CostWorkPerDay * Makespan) + (CostMachinePerDay * MachineRentalDuration)\n        objective = cost_work_per_day * Makespan + cost_machine_per_day * MachineRentalDuration\n        model.setObjective(objective, GRB.MINIMIZE)\n\n        # --- Constraints ---\n        # 1. Precedence Constraints\n        # Completion time of activity X is S[X] + durations[X]\n\n        # A -> G\n        model.addConstr(S['G'] >= S['A'] + durations['A'], name=\"Prec_A_G\")\n        # A -> D\n        model.addConstr(S['D'] >= S['A'] + durations['A'], name=\"Prec_A_D\")\n\n        # E -> F\n        model.addConstr(S['F'] >= S['E'] + durations['E'], name=\"Prec_E_F\")\n        # G -> F\n        model.addConstr(S['F'] >= S['G'] + durations['G'], name=\"Prec_G_F\")\n\n        # D -> C\n        model.addConstr(S['C'] >= S['D'] + durations['D'], name=\"Prec_D_C\")\n        # F -> C\n        model.addConstr(S['C'] >= S['F'] + durations['F'], name=\"Prec_F_C\")\n\n        # F -> B\n        model.addConstr(S['B'] >= S['F'] + durations['F'], name=\"Prec_F_B\")\n\n        # 2. Makespan Definition\n        # Makespan >= Completion time of all final activities (B and C)\n        model.addConstr(Makespan >= S['B'] + durations['B'],\n                        name=\"Makespan_vs_B\")\n        model.addConstr(Makespan >= S['C'] + durations['C'],\n                        name=\"Makespan_vs_C\")\n        # Also ensure makespan is greater than or equal to completion of any activity\n        for act in activities:\n            model.addConstr(Makespan >= S[act] + durations[act],\n                            name=f\"Makespan_vs_{act}\")\n\n        # 3. Machine Rental Duration Definition\n        # Machine rented from start of A (S['A']) to end of B (S['B'] + durations['B'])\n        # MachineRentalDuration >= (Completion Time of B) - (Start Time of A)\n        model.addConstr(MachineRentalDuration\n                        >= (S['B'] + durations['B']) - S['A'],\n                        name=\"MachineRentalDurationDef\")\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal project schedule found.\")\n            print(f\"Minimum Total Project Cost: {model.ObjVal:.2f} Euros\")\n            print(f\"  Calculated Makespan: {Makespan.X:.2f} days\")\n            print(\n                f\"  Calculated Machine Rental Duration: {MachineRentalDuration.X:.2f} days\"\n            )\n\n            print(\"\\nActivity Schedule (Start Times):\")\n            completion_times = {}\n            for act in activities:\n                completion_times[act] = S[act].X + durations[act]\n                print(\n                    f\"  Activity {act}: Start = {S[act].X:.2f} days, Duration = {durations[act]}, End = {completion_times[act]:.2f} days\"\n                )\n\n            print(\"\\nCost Breakdown:\")\n            work_cost = cost_work_per_day * Makespan.X\n            machine_cost = cost_machine_per_day * MachineRentalDuration.X\n            print(\n                f\"  Cost of Work (Makespan * {cost_work_per_day}): {work_cost:.2f} Euros\"\n            )\n            print(\n                f\"  Cost of Machine Rental (RentalDuration * {cost_machine_per_day}): {machine_cost:.2f} Euros\"\n            )\n\n            # Verify machine rental calculation\n            start_A = S['A'].X\n            end_B = S['B'].X + durations['B']\n            print(\n                f\"  Machine Rental Period: From start of A ({start_A:.2f}) to end of B ({end_B:.2f})\"\n            )\n            print(\n                f\"  Calculated duration for rental if positive: {(end_B - start_A):.2f} days\"\n            )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\n                \"Model is infeasible. Check precedence constraints or activity durations.\"\n            )\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            # model.computeIIS()\n            # model.write(\"project_scheduling_iis.ilp\")\n            # print(\"IIS written to project_scheduling_iis.ilp for debugging.\")\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n            if model.SolCount == 0:\n                print(\"No feasible solution found.\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_project_scheduling_cost_minimization()",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B074",
  "description": "There are $\\mathrm{A}$ and $\\mathrm{B}$ two products, both requiring two successive chemical reaction processes. Each unit of product $\\mathrm{A}$ needs 2 hours for the first process and 3 hours for the second process. Each unit of product $\\mathrm{B}$ needs 3 hours for the first process and 4 hours for the second process. Available time for the first process is 16 hours, and available time for the second process is 24 hours.\n\nFor each unit of product $\\mathrm{B}$ produced, 2 units of by-product $\\mathrm{C}$ are generated simultaneously, requiring no additional cost. By-product $\\mathrm{C}$ can be sold up to 5 units, and the rest must be disposed of at a cost of 2 yuan per unit.\n\nEach unit of product $\\mathrm{A}$ sold yields a profit of 4 yuan, each unit of product $\\mathrm{B}$ yields a profit of 10 yuan, and each unit of by-product $\\mathrm{C}$ sold yields a profit of 3 yuan.\n\nIn order to maximize total profit, establish the linear programming model for this problem.",
  "ground_truth": 57.0,
  "formulation": null,
  "correct_program": "def optimize_production():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"Production_Optimization\")\n\n    # Decision variables\n    x_A = m.addVar(name=\"x_A\", lb=0)  # Units of product A\n    x_B = m.addVar(name=\"x_B\", lb=0)  # Units of product B\n    s_C = m.addVar(name=\"s_C\", lb=0, ub=5)  # Units of by-product C sold\n    d = m.addVar(name=\"d\", lb=0)  # Units of C disposed\n\n    # Set objective: maximize profit\n    # profit = 4*x_A + 10*x_B + 3*s_C - 2*d\n    m.setObjective(4 * x_A + 10 * x_B + 3 * s_C - 2 * d, GRB.MAXIMIZE)\n\n    # Add constraints\n    # Time constraints\n    m.addConstr(2 * x_A + 3 * x_B <= 16, \"Time_Process1\")\n    m.addConstr(3 * x_A + 4 * x_B <= 24, \"Time_Process2\")\n    # By-product C sale limit\n    m.addConstr(s_C <= 5, \"Max_C_Sale\")\n    # C sold cannot exceed generated\n    m.addConstr(s_C <= 2 * x_B, \"C_Sale_Limit\")\n    # Disposal constraint\n    m.addConstr(2 * x_B - s_C <= d, \"Disposal_Constraint\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal profit value\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\nif __name__ == \"__main__\":\n    result = optimize_production()\n    if result is not None:\n        print(f\"Optimal profit: {result}\")\n    else:\n        print(\"No feasible solution found.\")",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B075",
  "description": "A timber storage and transport company has a large warehouse for storing and transporting timber for sale. Due to seasonal price fluctuations, the company purchases timber at the beginning of each quarter, with part of it being sold within the quarter and part being stored for future sales. It is known that the maximum storage capacity of the company’s warehouse is 200,000 m³, and the storage cost is $(a+b u)$ yuan/m³, where $a=70$, $b=100$, and $u$ is the storage time (in quarters). The purchase and sale prices for each quarter and the estimated maximum sales volumes are shown in Table 1-18.\n\nTable 1-18\n| Quarter | Purchase Price (10,000 yuan/10,000 m²) | Sale Price (10,000 yuan/10,000 m²) | Estimated Maximum Sales Volume (10,000 m³) |\n|---------|----------------------------------------|------------------------------------|---------------------------------------------|\n| Winter  | 410                                    | 425                                | 100                                         |\n| Spring  | 430                                    | 440                                | 140                                         |\n| Summer  | 460                                    | 465                                | 200                                         |\n| Autumn  | 450                                    | 455                                | 160                                         |\n\nSince timber is not suitable for long-term storage, all inventory should be sold by the end of autumn. Try to establish a linear programming model for this problem to maximize the company's annual profit.",
  "ground_truth": 4700.0,
  "formulation": null,
  "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_timber_storage():\n    \"\"\"\n    Solves the timber storage and transport problem to maximize annual profit.\n    \"\"\"\n    try:\n        # --- Data ---\n        # Quarters: Winter (0), Spring (1), Summer (2), Autumn (3)\n        quarters = list(range(4))\n        quarter_names = ['Winter', 'Spring', 'Summer', 'Autumn']\n\n        # Prices and Sales Limits (Units: 10k yuan for price, 10k m^3 for volume)\n        purchase_prices = [410, 430, 460, 450]  # P_t\n        sale_prices = [425, 440, 465, 455]  # S_t\n        max_sales_volume = [100, 140, 200, 160]  # MaxSales_t\n\n        # Warehouse Capacity (Units: 10k m^3)\n        warehouse_capacity = 20\n\n        # Storage Cost (Units: 10k yuan per 10k m^3 per quarter)\n        # Calculated from (a+bu) yuan/m^3 with a=70, b=100, assuming u=1 for cost per quarter\n        storage_cost_per_unit_volume = 170  # H\n\n        # Initial Inventory (Units: 10k m^3)\n        initial_inventory = 0.0\n\n        # --- Create Gurobi Model ---\n        model = gp.Model(\"TimberStorageOptimization\")\n\n        # --- Decision Variables ---\n        # Buy[t]: Volume purchased at the beginning of quarter t\n        buy_vars = model.addVars(quarters,\n                                 name=\"Buy\",\n                                 lb=0.0,\n                                 vtype=GRB.CONTINUOUS)\n\n        # Sell[t]: Volume sold during quarter t\n        sell_vars = model.addVars(quarters,\n                                  name=\"Sell\",\n                                  lb=0.0,\n                                  vtype=GRB.CONTINUOUS)\n\n        # Inv[t]: Volume stored at the end of quarter t\n        inventory_vars = model.addVars(quarters,\n                                       name=\"Inventory\",\n                                       lb=0.0,\n                                       vtype=GRB.CONTINUOUS)\n\n        # --- Objective Function: Maximize Total Profit ---\n        # Profit = Sales Revenue - Purchase Cost - Holding Cost\n        total_sales_revenue = gp.quicksum(sale_prices[t] * sell_vars[t]\n                                          for t in quarters)\n        total_purchase_cost = gp.quicksum(purchase_prices[t] * buy_vars[t]\n                                          for t in quarters)\n        total_holding_cost = gp.quicksum(\n            storage_cost_per_unit_volume * inventory_vars[t] for t in quarters)\n\n        model.setObjective(\n            total_sales_revenue - total_purchase_cost - total_holding_cost,\n            GRB.MAXIMIZE)\n\n        # --- Constraints ---\n        for t in quarters:\n            # Inventory at the start of the current quarter t\n            prev_inventory = initial_inventory if t == 0 else inventory_vars[t\n                                                                             -\n                                                                             1]\n\n            # 1. Inventory Balance Constraint\n            # Inv[t] = Inv[t-1] + Buy[t] - Sell[t]\n            model.addConstr(inventory_vars[t] == prev_inventory + buy_vars[t] -\n                            sell_vars[t],\n                            name=f\"InventoryBalance_{quarter_names[t]}\")\n\n            # 2. Warehouse Capacity Constraint\n            # Inv[t] <= warehouse_capacity\n            model.addConstr(inventory_vars[t] <= warehouse_capacity,\n                            name=f\"WarehouseCapacity_{quarter_names[t]}\")\n\n            # 3. Sales Limit Constraint\n            # Sell[t] <= MaxSales[t]\n            model.addConstr(sell_vars[t] <= max_sales_volume[t],\n                            name=f\"MaxSales_{quarter_names[t]}\")\n\n            # 4. Availability for Sale Constraint\n            # Sell[t] <= Inv[t-1] + Buy[t]\n            model.addConstr(sell_vars[t] <= prev_inventory + buy_vars[t],\n                            name=f\"SalesAvailability_{quarter_names[t]}\")\n\n        # 5. End Condition: All inventory must be sold by the end of Autumn (t=3)\n        model.addConstr(inventory_vars[quarters[-1]] == 0,\n                        name=\"EndInventoryZero\")\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal storage and transport plan found.\")\n            print(f\"Maximum Annual Profit: {model.ObjVal * 10000:.2f} Yuan\"\n                  )  # Convert back to Yuan\n\n            print(\"\\nQuarterly Plan Details (Volumes in 10,000 m³):\")\n            header = f\"{'Quarter':<8} | {'Inv Start':<10} | {'Buy Qty':<10} | {'Sell Qty':<10} | {'Inv End':<10} | {'Holding Cost':<15}\"\n            print(header)\n            print(\"-\" * len(header))\n\n            current_inv = initial_inventory\n            for t in quarters:\n                holding_cost_t = storage_cost_per_unit_volume * inventory_vars[\n                    t].X\n                print(\n                    f\"{quarter_names[t]:<8} | {current_inv:<10.2f} | {buy_vars[t].X:<10.2f} | \"\n                    f\"{sell_vars[t].X:<10.2f} | {inventory_vars[t].X:<10.2f} | \"\n                    f\"{holding_cost_t * 10000:<15.2f}\"\n                )  # Convert cost back to Yuan\n                current_inv = inventory_vars[t].X\n            print(\"-\" * len(header))\n\n            print(\n                f\"\\nInitial Inventory (Start of Winter): {initial_inventory:.2f} (10k m³)\"\n            )\n            print(\n                f\"Final Inventory (End of Autumn): {inventory_vars[quarters[-1]].X:.2f} (10k m³)\"\n            )\n\n            # Cost breakdown\n            sales_rev_val = sum(sale_prices[t] * sell_vars[t].X\n                                for t in quarters) * 10000\n            purchase_cost_val = sum(purchase_prices[t] * buy_vars[t].X\n                                    for t in quarters) * 10000\n            holding_cost_val = sum(\n                storage_cost_per_unit_volume * inventory_vars[t].X\n                for t in quarters) * 10000\n            print(\"\\nFinancial Summary (Yuan):\")\n            print(f\"  Total Sales Revenue: {sales_rev_val:.2f}\")\n            print(f\"  Total Purchase Cost: {purchase_cost_val:.2f}\")\n            print(f\"  Total Holding Cost: {holding_cost_val:.2f}\")\n            print(\n                f\"  Calculated Profit: {(sales_rev_val - purchase_cost_val - holding_cost_val):.2f}\"\n            )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\n                \"Model is infeasible. Check constraints and data for contradictions.\"\n            )\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            # model.computeIIS()\n            # model.write(\"timber_storage_iis.ilp\")\n            # print(\"IIS written to timber_storage_iis.ilp.\")\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_timber_storage()",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B076",
  "description": "There are 10 different parts, and they can all be processed on machine \\( A \\), machine \\( B \\), or machine \\( C \\). The unit processing costs are shown in Table 5-6. Additionally, as long as any part is processed on the aforementioned machines, a one-time setup cost will be incurred regardless of whether one or multiple types of parts are processed, with the respective costs being \\( d_A = 100 \\), \\( d_B = 135 \\), and \\( d_C = 200 \\) yuan. If the requirements are:\n\n1. One piece of each of the aforementioned 10 types of parts needs to be processed;\n2. If the 1st part is processed on machine \\( A \\), then the 2nd part must be processed on machine \\( B \\) or \\( C \\); conversely, if the 1st part is processed on machine \\( B \\) or \\( C \\), then the 2nd part must be processed on machine \\( A \\);\n3. Parts 3, 4, and 5 must be processed on machines A, B, and C respectively;\n4. The number of parts processed on machine \\( C \\) should not exceed 3 types.\n\nTry to establish an integer programming mathematical model for this problem with the objective of minimizing the total cost.\n\nTable 5-6\n| Machine/Part | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  |\n|--------------|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|\n| A            | $10$ | $20$ | $30$ | $40$ | $50$ | $60$ | $70$ | $80$ | $90$ | $100$ |\n| B            | $15$ | $25$ | $35$ | $45$ | $55$ | $65$ | $75$ | $85$ | $95$ | $105$ |\n| C            | $20$ | $30$ | $40$ | $50$ | $60$ | $70$ | $80$ | $90$ | $100$ | $110$ |",
  "ground_truth": 1005.0,
  "formulation": null,
  "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_machine_assignment():\n    \"\"\"\n    Solves the machine assignment problem with fixed setup costs and constraints\n    to minimize the total cost.\n    \"\"\"\n    try:\n        # --- Data ---\n        parts = list(range(1, 11))  # Parts 1 to 10\n        machines = ['A', 'B', 'C']\n\n        # Processing costs c[part][machine]\n        # Note: Using part index p-1 for 0-based list access\n        processing_costs_data = [\n            # A   B    C   (Machine)\n            [10, 15, 20],  # Part 1\n            [20, 25, 30],  # Part 2\n            [30, 35, 40],  # Part 3\n            [40, 45, 50],  # Part 4\n            [50, 55, 60],  # Part 5\n            [60, 65, 70],  # Part 6\n            [70, 75, 80],  # Part 7\n            [80, 85, 90],  # Part 8\n            [90, 95, 100],  # Part 9\n            [100, 105, 110]  # Part 10\n        ]\n\n        # Create cost dictionary c[p,m] for easier access\n        proc_costs = {}\n        for p_idx, p in enumerate(parts):\n            for m_idx, m in enumerate(machines):\n                proc_costs[p, m] = processing_costs_data[p_idx][m_idx]\n\n        # Fixed setup costs d[m]\n        setup_costs = {'A': 100, 'B': 135, 'C': 200}\n\n        # --- Create Gurobi Model ---\n        model = gp.Model(\"MachineAssignmentFixedCost\")\n\n        # --- Decision Variables ---\n        # x[p,m]: 1 if part p is processed on machine m, 0 otherwise\n        x = model.addVars(parts, machines, vtype=GRB.BINARY, name=\"x_assign\")\n\n        # y[m]: 1 if machine m is used (setup cost incurred), 0 otherwise\n        y = model.addVars(machines, vtype=GRB.BINARY, name=\"y_setup\")\n\n        # --- Objective Function: Minimize Total Cost ---\n        total_processing_cost = gp.quicksum(proc_costs[p, m] * x[p, m]\n                                            for p in parts for m in machines)\n        total_setup_cost = gp.quicksum(setup_costs[m] * y[m] for m in machines)\n\n        model.setObjective(total_processing_cost + total_setup_cost,\n                           GRB.MINIMIZE)\n\n        # --- Constraints ---\n        # 1. Process Each Part: Each part p processed on exactly one machine m\n        for p in parts:\n            model.addConstr(gp.quicksum(x[p, m] for m in machines) == 1,\n                            name=f\"ProcessPart_{p}\")\n\n        # 2. Conditional Assignment (Part 1 and Part 2)\n        # If x[1,'A'] = 1, then x[2,'B'] + x[2,'C'] = 1\n        model.addConstr(x[1, 'A'] <= x[2, 'B'] + x[2, 'C'],\n                        name=\"Cond_1A_implies_2BC\")\n        # If x[1,'B'] + x[1,'C'] = 1, then x[2,'A'] = 1\n        model.addConstr(x[1, 'B'] + x[1, 'C'] <= x[2, 'A'],\n                        name=\"Cond_1BC_implies_2A\")\n\n        # 3. Fixed Assignments (Parts 3, 4, 5)\n        model.addConstr(x[3, 'A'] == 1, name=\"Fixed_Part3_MachineA\")\n        model.addConstr(x[4, 'B'] == 1, name=\"Fixed_Part4_MachineB\")\n        model.addConstr(x[5, 'C'] == 1, name=\"Fixed_Part5_MachineC\")\n\n        # 4. Machine C Capacity Limit: No more than 3 parts on machine C\n        model.addConstr(gp.quicksum(x[p, 'C'] for p in parts) <= 3,\n                        name=\"Limit_MachineC\")\n\n        # 5. Linking Setup Cost: If any x[p,m] = 1, then y[m] must be 1\n        for m in machines:\n            for p in parts:\n                model.addConstr(x[p, m] <= y[m], name=f\"LinkSetup_{p}_{m}\")\n\n        # Alternative tighter linking constraint (optional, usually the one above is sufficient)\n        # for m in machines:\n        #     model.addConstr(gp.quicksum(x[p,m] for p in parts) <= len(parts) * y[m],\n        #                     name=f\"LinkSetupAggregate_{m}\")\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal assignment found.\")\n            print(\n                f\"Minimum Total Cost (Processing + Setup): {model.ObjVal:.2f} Yuan\"\n            )\n\n            print(\"\\nMachine Setup Status:\")\n            for m in machines:\n                if y[m].X > 0.5:\n                    print(\n                        f\"  Machine {m}: Used (Setup Cost: {setup_costs[m]})\")\n                else:\n                    print(f\"  Machine {m}: Not Used\")\n\n            print(\"\\nPart Assignments (Part -> Machine):\")\n            assignments = {}\n            parts_on_machine = {m: [] for m in machines}\n            for p in parts:\n                for m in machines:\n                    if x[p, m].X > 0.5:  # Check if x[p,m] is 1\n                        print(\n                            f\"  Part {p} -> Machine {m} (Processing Cost: {proc_costs[p,m]})\"\n                        )\n                        assignments[p] = m\n                        parts_on_machine[m].append(p)\n                        break  # Move to next part once assigned\n\n            print(\"\\nParts processed on each machine:\")\n            for m in machines:\n                print(\n                    f\"  Machine {m}: {sorted(parts_on_machine[m])} (Count: {len(parts_on_machine[m])})\"\n                )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\n                \"Model is infeasible. Check constraints and data for contradictions.\"\n            )\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            model.computeIIS()\n            model.write(\"machine_assignment_iis.ilp\")\n            print(\n                \"IIS written to machine_assignment_iis.ilp. Review this file to find conflicting constraints.\"\n            )\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n            if model.SolCount == 0:\n                print(\"No feasible solution found.\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_machine_assignment()",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B078",
  "description": "A furniture factory needs to decide how many tables, chairs, and bookshelves to produce in order to maximize its profit. The factory can sell each table for $200, each chair for $50, and each bookshelf for $150. The manufacturing costs for each table, chair, and bookshelf are $120, $20, and $90 respectively. The profit is the difference between the selling price and the manufacturing cost. Each table, chair, and bookshelf occupy 5, 2, and 3 square meters of warehouse space respectively. Due to limited warehouse space, the total space cannot exceed 500 square meters. In addition, due to market demand, the factory needs to produce at least 10 tables and 20 bookshelves. Finally, the total number of items produced by the factory cannot exceed 200.",
  "ground_truth": 9800.0,
  "formulation": null,
  "correct_program": "def optimize_furniture_factory():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"Furniture_Production\")\n\n    # Decision variables\n    T = m.addVar(vtype=GRB.INTEGER, name=\"Tables\", lb=10)  # at least 10 tables\n    C = m.addVar(vtype=GRB.INTEGER, name=\"Chairs\", lb=0)\n    B = m.addVar(vtype=GRB.INTEGER, name=\"Bookshelves\",\n                 lb=20)  # at least 20 bookshelves\n\n    # Set the objective: maximize profit\n    profit = 80 * T + 30 * C + 60 * B\n    m.setObjective(profit, GRB.MAXIMIZE)\n\n    # Add constraints\n    # Warehouse space constraint\n    m.addConstr(5 * T + 2 * C + 3 * B <= 500, \"Space\")\n    # Total production limit\n    m.addConstr(T + C + B <= 200, \"TotalItems\")\n    # Demand constraints are already enforced via variable lower bounds\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        return m.objVal\n    else:\n        return None\nif __name__ == \"__main__\":\n    result = optimize_furniture_factory()\n    if result is not None:\n        print(f\"Optimal profit: {result}\")\n    else:\n        print(\"No feasible solution found.\")",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B080",
  "description": "On Danzig Street, vehicles can park on both sides of the street. Mr. Edmonds, who lives at No. 1, is organizing a party with about 30 participants, and they will arrive in 15 cars. The length of the i-th car is λ_i, in meters, as follows:\n\n| i  | 1  | 2   | 3  | 4   | 5   | 6   | 7   | 8   | 9   | 10  | 11  | 12  | 13  | 14  | 15  |\n|----|----|-----|----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|\n| λ_i | 4  | 4.5 | 5  | 4.1 | 2.4 | 5.2 | 3.7 | 3.5 | 3.2 | 4.5 | 2.3 | 3.3 | 3.8 | 4.6 | 3   |\n\nIn order to avoid disturbing the neighbors, Mr. Edmonds wants to arrange parking on both sides of the street so that the total length of the street occupied by his friends' vehicles is minimized. Please provide a mathematical programming formulation and solve this problem using AMPL.\nHow does the program change if the cars on one side of the street cannot occupy more than 30 meters?",
  "ground_truth": 28.6,
  "formulation": null,
  "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_car_parking(max_length_per_side=None):\n    \"\"\"\n    Solves the car parking assignment problem to minimize the maximum length\n    occupied on either side of the street.\n\n    Args:\n        max_length_per_side (float, optional): Maximum allowed length on one side. \n                                                If None, no limit is applied. Defaults to None.\n    \"\"\"\n    try:\n        # --- Data ---\n        car_lengths = {\n            1: 4.0,\n            2: 4.5,\n            3: 5.0,\n            4: 4.1,\n            5: 2.4,\n            6: 5.2,\n            7: 3.7,\n            8: 3.5,\n            9: 3.2,\n            10: 4.5,\n            11: 2.3,\n            12: 3.3,\n            13: 3.8,\n            14: 4.6,\n            15: 3.0\n        }\n        cars = list(car_lengths.keys())\n        sides = [1, 2]\n\n        total_car_length = sum(car_lengths.values())\n        print(f\"Total length of all cars: {total_car_length:.2f} meters\")\n\n        # --- Create Gurobi Model ---\n        model_name = \"CarParkingAssignment\"\n        if max_length_per_side is not None:\n            model_name += f\"_Max{max_length_per_side}\"\n        model = gp.Model(model_name)\n\n        # --- Decision Variables ---\n        # x[i,s]: 1 if car i is parked on side s, 0 otherwise\n        x = model.addVars(cars, sides, vtype=GRB.BINARY, name=\"x_assign\")\n\n        # L_max: Maximum length occupied on either side\n        L_max = model.addVar(name=\"L_max\", lb=0.0, vtype=GRB.CONTINUOUS)\n\n        # --- Objective Function: Minimize L_max ---\n        model.setObjective(L_max, GRB.MINIMIZE)\n\n        # --- Constraints ---\n        # 1. Assignment Constraint: Each car assigned to exactly one side\n        for i in cars:\n            model.addConstr(gp.quicksum(x[i, s] for s in sides) == 1,\n                            name=f\"AssignCar_{i}\")\n\n        # 2. Maximum Length Definition: L_max >= length on each side\n        for s in sides:\n            length_on_side_s = gp.quicksum(car_lengths[i] * x[i, s]\n                                           for i in cars)\n            model.addConstr(L_max >= length_on_side_s, name=f\"MaxLen_Side_{s}\")\n\n        # 3. (Optional) Side Length Limit Constraint\n        if max_length_per_side is not None:\n            print(\n                f\"\\nAdding constraint: Max length per side <= {max_length_per_side} meters\"\n            )\n            for s in sides:\n                length_on_side_s = gp.quicksum(car_lengths[i] * x[i, s]\n                                               for i in cars)\n                model.addConstr(length_on_side_s <= max_length_per_side,\n                                name=f\"SideLimit_{s}\")\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"\\nOptimal parking assignment found.\")\n            print(\n                f\"Minimum Maximum Length Occupied (L_max): {model.ObjVal:.2f} meters\"\n            )\n\n            print(\"\\nParking Plan (Car -> Side):\")\n            assignment = {s: [] for s in sides}\n            length_used = {s: 0.0 for s in sides}\n\n            for i in cars:\n                for s in sides:\n                    if x[i, s].X > 0.5:  # Check if x[i,s] is 1\n                        assignment[s].append(i)\n                        length_used[s] += car_lengths[i]\n                        break  # Move to next car\n\n            for s in sides:\n                print(f\"  Side {s}: Cars {sorted(assignment[s])}\")\n                print(f\"    -> Total Length: {length_used[s]:.2f} meters\")\n                if max_length_per_side is not None:\n                    print(f\"       (Limit: <= {max_length_per_side})\")\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\n                \"\\nModel is infeasible. It's impossible to park the cars satisfying all constraints.\"\n            )\n            if max_length_per_side is not None:\n                print(\n                    f\"  This might be due to the {max_length_per_side}m limit per side.\"\n                )\n                print(\n                    f\"  Total car length is {total_car_length:.2f}m, requiring at least {total_car_length/2:.2f}m per side on average.\"\n                )\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            model.computeIIS()\n            model.write(\"car_parking_iis.ilp\")\n            print(\"  IIS written to car_parking_iis.ilp for debugging.\")\n        else:\n            print(f\"\\nOptimization stopped with status: {model.status}\")\n            if model.SolCount == 0:\n                print(\"No feasible solution found.\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\n# --- Solve the problems ---\nprint(\"--- Scenario 1: Minimize Maximum Length (No Side Limit) ---\")\nsolve_car_parking()\n\nprint(\"\\n=========================================================\\n\")\n\nprint(\"--- Scenario 2: Minimize Maximum Length (Max 30m per Side) ---\")\nsolve_car_parking(max_length_per_side=30.0)",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B081",
  "description": "Changjiang Comprehensive Shopping Mall has 5000 m² of space for lease and plans to attract the following 5 types of stores as tenants. The table below shows the area occupied by each type of store for one shop, the minimum and maximum number of shops for each type within the mall, and the expected annual profit (in ten thousand yuan) per store for different numbers of stores. Each store pays 20% of its annual profit as rent to the mall. Question: How many of each type of store should the mall lease to maximize total rental income?\n\nTable 5-12\n\n| Code | Store Type | Area per Shop / m² | Min | Max | 1 Store | 2 Stores | 3 Stores |\n|------|------------|--------------------|-----|-----|---------|----------|----------|\n| 1    | Jewelry    | 250                | 1   | 3   | 9       | 8        | 7        |\n| 2    | Shoes & Hats | 350              | 1   | 2   | 10      | 9        | -        |\n| 3    | General Merchandise | 800      | 1   | 3   | 27      | 21       | 20       |\n| 4    | Bookstore  | 400                | 0   | 2   | 16      | 10       | -        |\n| 5    | Catering   | 500                | 1   | 3   | 17      | 15       | 12       |",
  "ground_truth": 28.0,
  "formulation": null,
  "correct_program": "def optimize_mall_leasing():\n    from gurobipy import Model, GRB\n\n    # Data\n    area_per_store = [250, 350, 800, 400, 500]\n    min_stores = [1, 1, 1, 0, 1]\n    max_stores = [3, 2, 3, 2, 3]\n    # Profit levels for each store type at 1, 2, 3 stores\n    profit_levels = [\n        [9, 8, 7],  # Jewelry\n        [10, 9, None],  # Shoes & Hats (only up to 2 stores)\n        [27, 21, 20],  # General Merchandise\n        [16, 10, None],  # Bookstore\n        [17, 15, 12]  # Catering\n    ]\n\n    # Initialize model\n    model = Model(\"Mall Leasing Optimization\")\n\n    # Decision variables: number of stores for each type\n    x = []\n    for i in range(5):\n        lb = min_stores[i]\n        ub = max_stores[i]\n        var = model.addVar(vtype=GRB.INTEGER, name=f\"x_{i+1}\", lb=lb, ub=ub)\n        x.append(var)\n\n    model.update()\n\n    # Area constraint\n    model.addConstr(sum(area_per_store[i] * x[i] for i in range(5)) <= 5000,\n                    name=\"area_constraint\")\n\n    # For each store type, define profit per store based on x_i\n    profit_per_store = []\n\n    for i in range(5):\n        # For store types with min=0 (store type 4), handle separately\n        if min_stores[i] == 0:\n            # For store type 4 (Bookstore), max=2\n            # Create binary indicators for 1 and 2 stores\n            b_1 = model.addVar(vtype=GRB.BINARY, name=f\"b_{i+1}_1\")\n            b_2 = model.addVar(vtype=GRB.BINARY, name=f\"b_{i+1}_2\")\n            model.update()\n\n            # Link x_i to indicators\n            # x_i = 1*b_1 + 2*b_2\n            model.addConstr(x[i] == b_1 + 2 * b_2, name=f\"link_x_b_{i+1}\")\n\n            # Exactly one indicator active if x_i > 0\n            model.addConstr(b_1 + b_2 <= 1, name=f\"one_indicator_{i+1}\")\n\n            # For x_i=0, both indicators are zero (no store)\n            # For x_i=1 or 2, one indicator is 1\n            # No need for additional constraints as above suffice\n\n            # Define profit per store based on indicators\n            profit_expr = 0\n            if profit_levels[i][0] is not None:\n                profit_expr += profit_levels[i][0] * b_1\n            if profit_levels[i][1] is not None:\n                profit_expr += profit_levels[i][1] * b_2\n            # For 0 stores, profit per store is 0\n            profit_per_store.append(profit_expr)\n\n        else:\n            # For store types with min >=1\n            # Create binary indicators for counts 1, 2, 3\n            indicators = []\n            for count in range(1, 4):\n                if count <= max_stores[i]:\n                    b = model.addVar(vtype=GRB.BINARY, name=f\"b_{i+1}_{count}\")\n                    indicators.append((count, b))\n            model.update()\n\n            # Link x_i to indicators\n            model.addConstr(x[i] == sum(count * b for count, b in indicators),\n                            name=f\"link_x_b_{i+1}\")\n\n            # Exactly one indicator active\n            model.addConstr(sum(b for _, b in indicators) == 1,\n                            name=f\"one_indicator_{i+1}\")\n\n            # Define profit per store based on indicator variables\n            profit_expr = 0\n            for count, b in indicators:\n                profit_value = profit_levels[i][count - 1]\n                profit_expr += profit_value * b\n            profit_per_store.append(profit_expr)\n\n    # Objective: maximize total rent income\n    total_income = 0\n    for i in range(5):\n        total_income += 0.2 * profit_per_store[i] * x[i]\n\n    model.setObjective(total_income, GRB.MAXIMIZE)\n\n    # Optimize\n    model.optimize()\n\n    # Check solution status\n    if model.status == GRB.OPTIMAL:\n        return model.objVal\n    else:\n        return None\n\nprint(optimize_mall_leasing())",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B082",
  "description": "A certain restaurant operates around the clock, and the number of waiters needed in 24 hours is shown in Table 1.1.\n\nTable 1.1\n\n| Time        | Minimum Number of Waiters Needed | Time        | Minimum Number of Waiters Needed |\n|:-----------:|:-------------------------------:|:-----------:|:-------------------------------:|\n| $2 \\sim 6$  | 4                                | $14 \\sim 18$| 7                                |\n| $6 \\sim 10$ | 8                                | $18 \\sim 22$| 12                               |\n| $10 \\sim 14$| 10                               | $22 \\sim 2$ | 4                                |\n\nEach waiter works continuously for 8 hours a day. The goal is to find the minimum number of waiters that meet the above conditions and represent this problem as a linear programming model.",
  "ground_truth": 26.0,
  "formulation": null,
  "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_restaurant_staffing():\n    \"\"\"\n    Solves the restaurant waiter staffing problem to minimize the total number of\n    waiters needed, subject to demand coverage constraints.\n    \"\"\"\n    try:\n        # Create a new model\n        model = gp.Model(\"RestaurantStaffing\")\n\n        # --- Data ---\n        # Demands for each 4-hour period, ordered chronologically\n        # Period 0: 2:00-6:00\n        # Period 1: 6:00-10:00\n        # Period 2: 10:00-14:00\n        # Period 3: 14:00-18:00\n        # Period 4: 18:00-22:00\n        # Period 5: 22:00-2:00 (next day)\n        demands = {\n            0: 4,  # 2:00 - 6:00\n            1: 8,  # 6:00 - 10:00\n            2: 10,  # 10:00 - 14:00\n            3: 7,  # 14:00 - 18:00\n            4: 12,  # 18:00 - 22:00\n            5: 4  # 22:00 - 2:00 (next day)\n        }\n        num_periods = len(demands)  # Should be 6\n\n        # Shift start times descriptions for output\n        shift_start_times_desc = [\n            \"2:00\", \"6:00\", \"10:00\", \"14:00\", \"18:00\", \"22:00\"\n        ]\n        period_desc = [\n            \"2:00-6:00\", \"6:00-10:00\", \"10:00-14:00\", \"14:00-18:00\",\n            \"18:00-22:00\", \"22:00-2:00\"\n        ]\n\n        # --- Decision Variables ---\n        # x[t]: number of waiters starting their 8-hour shift at the beginning of period t\n        x = model.addVars(num_periods,\n                          vtype=GRB.INTEGER,\n                          name=\"x_waiters\",\n                          lb=0)\n\n        # --- Objective Function ---\n        # Minimize the total number of waiters hired\n        model.setObjective(gp.quicksum(x[t] for t in range(num_periods)),\n                           GRB.MINIMIZE)\n\n        # --- Constraints ---\n        # Demand coverage for each period.\n        # Each waiter works for 8 hours, covering two 4-hour periods.\n\n        # Period 0 (2:00-6:00): Covered by staff starting at 22:00 (x[5]) and 2:00 (x[0])\n        model.addConstr(x[5] + x[0] >= demands[0], \"Demand_P0\")\n\n        # Period 1 (6:00-10:00): Covered by staff starting at 2:00 (x[0]) and 6:00 (x[1])\n        model.addConstr(x[0] + x[1] >= demands[1], \"Demand_P1\")\n\n        # Period 2 (10:00-14:00): Covered by staff starting at 6:00 (x[1]) and 10:00 (x[2])\n        model.addConstr(x[1] + x[2] >= demands[2], \"Demand_P2\")\n\n        # Period 3 (14:00-18:00): Covered by staff starting at 10:00 (x[2]) and 14:00 (x[3])\n        model.addConstr(x[2] + x[3] >= demands[3], \"Demand_P3\")\n\n        # Period 4 (18:00-22:00): Covered by staff starting at 14:00 (x[3]) and 18:00 (x[4])\n        model.addConstr(x[3] + x[4] >= demands[4], \"Demand_P4\")\n\n        # Period 5 (22:00-2:00): Covered by staff starting at 18:00 (x[4]) and 22:00 (x[5])\n        model.addConstr(x[4] + x[5] >= demands[5], \"Demand_P5\")\n\n        # Suppress Gurobi output to console\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal staffing plan found.\")\n            print(f\"Minimum total waiters needed: {model.ObjVal:.0f}\")\n\n            print(\"\\nNumber of Waiters Starting Each Shift:\")\n            print(f\"{'Start Time':<12} | {'Number of Waiters':<15}\")\n            print(\"-\" * 30)\n            for t in range(num_periods):\n                print(f\"{shift_start_times_desc[t]:<12} | {x[t].X:<15.0f}\")\n\n            print(\"\\nVerification of Coverage per Period:\")\n            coverage = [0] * num_periods\n            coverage[0] = x[5].X + x[0].X\n            coverage[1] = x[0].X + x[1].X\n            coverage[2] = x[1].X + x[2].X\n            coverage[3] = x[2].X + x[3].X\n            coverage[4] = x[3].X + x[4].X\n            coverage[5] = x[4].X + x[5].X\n\n            for p_idx in range(num_periods):\n                print(\n                    f\"  Period {period_desc[p_idx]} (Demand: {demands[p_idx]}): Covered by {coverage[p_idx]:.0f} waiters\"\n                )\n\n        else:\n            print(\"No optimal solution found. Status code:\", model.status)\n\n    except gp.GurobiError as e:\n        print(f\"Error code {e.errno}: {e}\")\n    except AttributeError:\n        print(\n            \"Encountered an attribute error, Gurobi might not be installed or licensed correctly.\"\n        )\n\n\nif __name__ == '__main__':\n    solve_restaurant_staffing()",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B083",
  "description": "A company hopes to recruit new employees for its team. The salary requirements for candidates A, B, C, D, and E are $8100, $20000, $21000, $3000, and $8000 respectively. They need to decide whether to hire each candidate. The team wants to minimize the total amount paid to the candidates.\n\nThey hope to hire a maximum of 3 new employees.\n\nThe team has a limited budget of $35,000. They need to ensure that the total payment to the selected candidates does not exceed the budget.\n\nThe qualifications of the five candidates are as follows:\nCandidate A: Bachelor's degree;\nCandidate B: Master's degree;\nCandidate C: Doctoral degree;\nCandidate D: No degree;\nCandidate E: No degree.\nThey will select at least one candidate with a Master's or Doctoral degree.\n\nThe work experience of the five candidates is as follows:\nCandidate A: 3 years of work experience;\nCandidate B: 10 years of work experience;\nCandidate C: 4 years of work experience;\nCandidate D: 3 years of work experience;\nCandidate E: 7 years of work experience.\nThey hope the total work experience of the selected candidates is no less than 12 years.\n\nDue to the equivalent professional skills of candidates A and E, the company will choose at most one from the two.\n\nThey will hire at least 2 new employees.",
  "ground_truth": 23000.0,
  "formulation": null,
  "correct_program": "def optimize_candidate_selection():\n    from gurobipy import Model, GRB\n\n    # Candidate data\n    salaries = {'A': 8100, 'B': 20000, 'C': 21000, 'D': 3000, 'E': 8000}\n    # Initialize model\n    m = Model(\"Candidate_Selection\")\n    m.setParam('OutputFlag', 0)  # Suppress output\n\n    # Decision variables\n    y_A = m.addVar(vtype=GRB.BINARY, name='A')\n    y_B = m.addVar(vtype=GRB.BINARY, name='B')\n    y_C = m.addVar(vtype=GRB.BINARY, name='C')\n    y_D = m.addVar(vtype=GRB.BINARY, name='D')\n    y_E = m.addVar(vtype=GRB.BINARY, name='E')\n\n    # Update model to integrate variables\n    m.update()\n\n    # Objective: Minimize total salary\n    m.setObjective(\n        salaries['A'] * y_A + salaries['B'] * y_B + salaries['C'] * y_C +\n        salaries['D'] * y_D + salaries['E'] * y_E, GRB.MINIMIZE)\n\n    # Constraints\n    # Max 3 hires\n    m.addConstr(y_A + y_B + y_C + y_D + y_E <= 3, \"max_hires\")\n    # At least 2 hires\n    m.addConstr(y_A + y_B + y_C + y_D + y_E >= 2, \"min_hires\")\n    # Budget constraint\n    m.addConstr(\n        salaries['A'] * y_A + salaries['B'] * y_B + salaries['C'] * y_C +\n        salaries['D'] * y_D + salaries['E'] * y_E <= 35000, \"budget\")\n    # Qualification constraint: at least one with Master's or Doctoral degree\n    m.addConstr(y_B + y_C >= 1, \"qualification\")\n    # Experience constraint\n    m.addConstr(3 * y_A + 10 * y_B + 4 * y_C + 3 * y_D + 7 * y_E >= 12,\n                \"experience\")\n    # Skill equivalence constraint: at most one of A and E\n    m.addConstr(y_A + y_E <= 1, \"skill_equivalence\")\n\n    # Optimize\n    m.optimize()\n\n    # Check feasibility and return result\n    if m.status == GRB.OPTIMAL:\n        return m.objVal\n    else:\n        return None\nif __name__ == \"__main__\":\n    result = optimize_candidate_selection()\n    if result is not None:\n        print(f\"Optimal total salary: {result}\")\n    else:\n        print(\"No feasible solution found.\")",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B084",
  "description": "A company is producing two products (X and Y). The resources required for the production of X and Y are divided into two parts: machine time for automated processing and craftsman time for manual finishing. The table below shows the number of minutes required for each product:\n\n| Item | Machine Time (minutes) | Craftsman Time (minutes) |\n| :---: | :---: | :---: |\n| X | 13 | 20 |\n| Y | 19 | 29 |\n\nThe company has 40 hours of machine time available in the next working week, but only 35 hours of craftsman time. The cost of machine time is £10 per hour, and the cost of craftsman time is £2 per hour. Idle time for machines and craftsmen incurs no cost. For each product produced (all products produced will be sold), the revenue for product X is £20, and the revenue for product Y is £30. The company has a specific contract that requires 10 units of product X to be produced for a customer each week. Formulate a model for this problem.",
  "ground_truth": 1861.466666667,
  "formulation": null,
  "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_production_profit_maximization():\n    \"\"\"\n    Solves the production planning problem to maximize weekly profit\n    for products X and Y, subject to time and contract constraints.\n    \"\"\"\n    try:\n        # --- Parameters ---\n        products = ['X', 'Y']\n\n        # Time requirements (minutes/unit)\n        machine_time_req = {'X': 13, 'Y': 19}\n        craftsman_time_req = {'X': 20, 'Y': 29}\n\n        # Time availability (minutes/week)\n        avail_machine_time = 40 * 60  # 2400 minutes\n        avail_craftsman_time = 35 * 60  # 2100 minutes\n\n        # Costs (per minute)\n        cost_machine_per_min = 10 / 60\n        cost_craftsman_per_min = 2 / 60\n\n        # Revenue (per unit)\n        revenue = {'X': 20, 'Y': 30}\n\n        # Contract requirement\n        min_production_X = 10\n\n        # Calculate profit per unit\n        profit_per_unit = {}\n        for p in products:\n            cost_machine = machine_time_req[p] * cost_machine_per_min\n            cost_craftsman = craftsman_time_req[p] * cost_craftsman_per_min\n            profit_per_unit[p] = revenue[p] - cost_machine - cost_craftsman\n            # print(f\"Profit per unit {p}: {profit_per_unit[p]:.4f}\") # For verification\n\n        # --- Create Gurobi Model ---\n        model = gp.Model(\"ProductionProfitMaximization\")\n\n        # --- Decision Variables ---\n        # N[p]: Number of units of product p produced per week\n        N = model.addVars(products, name=\"Produce\", vtype=GRB.INTEGER, lb=0)\n\n        # --- Objective Function: Maximize Total Profit ---\n        # Profit = Sum(Profit_per_unit[p] * N[p])\n        model.setObjective(\n            gp.quicksum(profit_per_unit[p] * N[p] for p in products),\n            GRB.MAXIMIZE)\n\n        # --- Constraints ---\n        # 1. Machine Time Constraint\n        model.addConstr(gp.quicksum(machine_time_req[p] * N[p]\n                                    for p in products) <= avail_machine_time,\n                        name=\"MachineTimeLimit\")\n\n        # 2. Craftsman Time Constraint\n        model.addConstr(gp.quicksum(craftsman_time_req[p] * N[p]\n                                    for p in products) <= avail_craftsman_time,\n                        name=\"CraftsmanTimeLimit\")\n\n        # 3. Contract Requirement for Product X\n        model.addConstr(N['X'] >= min_production_X, name=\"ContractX\")\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal production plan found.\")\n            print(f\"Maximum Weekly Profit: £{model.ObjVal:.2f}\")\n\n            print(\"\\nOptimal Production Quantities (units per week):\")\n            for p in products:\n                print(f\"  Product {p}: {N[p].X:.0f} units\")\n\n            print(\"\\nResource Utilization:\")\n            machine_time_used = sum(machine_time_req[p] * N[p].X\n                                    for p in products)\n            craftsman_time_used = sum(craftsman_time_req[p] * N[p].X\n                                      for p in products)\n            print(\n                f\"  Machine Time Used: {machine_time_used:.2f} / {avail_machine_time} minutes \"\n                f\"({(machine_time_used/avail_machine_time*100) if avail_machine_time > 0 else 0:.1f}%)\"\n            )\n            print(\n                f\"  Craftsman Time Used: {craftsman_time_used:.2f} / {avail_craftsman_time} minutes \"\n                f\"({(craftsman_time_used/avail_craftsman_time*100) if avail_craftsman_time > 0 else 0:.1f}%)\"\n            )\n\n            print(\"\\nContract Fulfillment:\")\n            print(\n                f\"  Product X Produced: {N['X'].X:.0f} (Min Required: {min_production_X})\"\n            )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\"Model is infeasible. Check constraints and requirements.\")\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            # model.computeIIS()\n            # model.write(\"production_profit_iis.ilp\")\n            # print(\"IIS written to production_profit_iis.ilp.\")\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n            if model.SolCount == 0:\n                print(\"No feasible solution found.\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_production_profit_maximization()",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B085",
  "description": "Healthy Pet Foods Company produces two types of dog food: Meaties and Yummies. Each pack of Meaties contains 2 pounds of grains and 3 pounds of meat; each pack of Yummies contains 3 pounds of grains and 1.5 pounds of meat. The company believes it can sell any quantity of dog food that it can produce. Meaties sell for $2.80 per pack, and Yummies sell for $2.00 per pack. The company's production is subject to several constraints. First, a maximum of 400,000 pounds of grains can be purchased each month at a price of $0.20 per pound of grains. A maximum of 300,000 pounds of meat can be purchased each month at a price of $0.50 per pound of meat. Additionally, a special machine is required to produce Meaties, with a monthly capacity of 90,000 packs. The variable costs for mixing and packaging dog food are $0.25 per pack (Meaties) and $0.20 per pack (Yummies). Detailed information is provided in Table B-1.\n\n**Table B-1 Healthy Pet Foods Data**\n\n|                    | Meaties      | Yummies    |\n|--------------------|--------------|------------|\n| Price per pack     | $2.80        | $2.00      |\n| Raw materials      |              |            |\n| - Grains           | 2.0 lbs      | 3.0 lbs    |\n| - Meat             | 3.0 lbs      | 1.5 lbs    |\n| Variable cost      | $0.25/pack   | $0.20/pack |\n| Resources          |              |            |\n| Meaties capacity   | 90,000 packs/month |       |\n| Monthly available grains | 400,000 lbs |      |\n| Monthly available meat | 300,000 lbs |        |\n\nAssume you are the manager of the dog food department at Healthy Pet Foods Company. Your salary is based on the department's profit, so you will try to maximize profit. How should you operate the department to maximize both the profit and your salary?",
  "ground_truth": 77500.0,
  "formulation": null,
  "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_healthy_pet_foods():\n    \"\"\"\n    Solves the production planning problem for Healthy Pet Foods\n    to maximize monthly profit.\n    \"\"\"\n    try:\n        # --- Parameters ---\n        products = ['Meaties', 'Yummies']\n\n        # Selling Price ($/pack)\n        selling_price = {'Meaties': 2.80, 'Yummies': 2.00}\n\n        # Raw Material Requirements (lbs/pack)\n        grains_req = {'Meaties': 2.0, 'Yummies': 3.0}\n        meat_req = {'Meaties': 3.0, 'Yummies': 1.5}\n\n        # Variable Costs ($/pack) - Mixing and Packaging\n        variable_cost = {'Meaties': 0.25, 'Yummies': 0.20}\n\n        # Raw Material Costs ($/lb)\n        cost_grains = 0.20\n        cost_meat = 0.50\n\n        # Resource Availability (per month)\n        max_grains = 400000  # lbs\n        max_meat = 300000  # lbs\n        max_meaties_capacity = 90000  # packs\n\n        # --- Calculate Profit per Pack ---\n        # Profit = Selling Price - Grain Cost - Meat Cost - Variable Cost\n        profit_per_pack = {}\n        for p in products:\n            cost_of_grains = grains_req[p] * cost_grains\n            cost_of_meat = meat_req[p] * cost_meat\n            profit_per_pack[p] = selling_price[\n                p] - cost_of_grains - cost_of_meat - variable_cost[p]\n            # print(f\"Calculated profit for {p}: ${profit_per_pack[p]:.2f}\") # For verification\n\n        # --- Create Gurobi Model ---\n        model = gp.Model(\"HealthyPetFoodsProfit\")\n\n        # --- Decision Variables ---\n        # Produce[p]: Number of packs of product p produced per month\n        Produce = model.addVars(products,\n                                name=\"Produce\",\n                                vtype=GRB.CONTINUOUS,\n                                lb=0)\n\n        # --- Objective Function: Maximize Total Profit ---\n        model.setObjective(\n            gp.quicksum(profit_per_pack[p] * Produce[p] for p in products),\n            GRB.MAXIMIZE)\n\n        # --- Constraints ---\n        # 1. Grain Availability Constraint\n        model.addConstr(gp.quicksum(grains_req[p] * Produce[p]\n                                    for p in products) <= max_grains,\n                        name=\"GrainLimit\")\n\n        # 2. Meat Availability Constraint\n        model.addConstr(gp.quicksum(meat_req[p] * Produce[p] for p in products)\n                        <= max_meat,\n                        name=\"MeatLimit\")\n\n        # 3. Meaties Production Capacity Constraint\n        model.addConstr(Produce['Meaties'] <= max_meaties_capacity,\n                        name=\"MeatiesCapacity\")\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal production plan found.\")\n            print(f\"Maximum Monthly Profit: ${model.ObjVal:.2f}\")\n\n            print(\"\\nOptimal Production Quantities (packs per month):\")\n            for p in products:\n                print(f\"  {p}: {Produce[p].X:.2f} packs\")\n\n            print(\"\\nResource Utilization:\")\n            grains_used = sum(grains_req[p] * Produce[p].X for p in products)\n            meat_used = sum(meat_req[p] * Produce[p].X for p in products)\n            meaties_produced = Produce['Meaties'].X\n\n            print(\n                f\"  Grains Used: {grains_used:.2f} / {max_grains} lbs \"\n                f\"({(grains_used/max_grains*100) if max_grains > 0 else 0:.1f}%)\"\n            )\n            print(f\"  Meat Used: {meat_used:.2f} / {max_meat} lbs \"\n                  f\"({(meat_used/max_meat*100) if max_meat > 0 else 0:.1f}%)\")\n            print(\n                f\"  Meaties Production: {meaties_produced:.2f} / {max_meaties_capacity} packs \"\n                f\"({(meaties_produced/max_meaties_capacity*100) if max_meaties_capacity > 0 else 0:.1f}%)\"\n            )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\"Model is infeasible. Check constraints and data.\")\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            # model.computeIIS()\n            # model.write(\"healthy_pet_foods_iis.ilp\")\n            # print(\"IIS written to healthy_pet_foods_iis.ilp.\")\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n            if model.SolCount == 0:\n                print(\"No feasible solution found.\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_healthy_pet_foods()",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B086",
  "description": "A transportation company has two types of trucks, Type A and Type B. Type A trucks have 20 cubic meters of refrigerated capacity and 40 cubic meters of non-refrigerated capacity. In contrast, Type B trucks have the same total capacity, but the capacities for refrigerated and non-refrigerated cargo are equal. A grocer needs to rent trucks to transport 3000 cubic meters of refrigerated cargo and 4000 cubic meters of non-refrigerated cargo. The rental cost per kilometer for Type A trucks is £30, while the rental cost per kilometer for Type B trucks is £40. How many of each type of truck should the grocer rent to minimize the total cost?\n\nTry to formulate a model for this problem.",
  "ground_truth": 4170.0,
  "formulation": null,
  "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_truck_rental():\n    \"\"\"\n    Solves the truck rental optimization problem to minimize total cost\n    while meeting refrigerated and non-refrigerated cargo requirements.\n    \"\"\"\n    try:\n        # --- Parameters ---\n        truck_types = ['A', 'B']\n\n        # Capacities (m^3 per truck)\n        capacity_refrigerated = {'A': 20, 'B': 30}\n        capacity_non_refrigerated = {'A': 40, 'B': 30}\n\n        # Cargo Requirements (m^3)\n        required_refrigerated = 3000\n        required_non_refrigerated = 4000\n\n        # Rental Costs (£ per truck - assumed for the task)\n        rental_cost = {'A': 30, 'B': 40}\n\n        # --- Create Gurobi Model ---\n        model = gp.Model(\"TruckRentalOptimization\")\n\n        # --- Decision Variables ---\n        # N[t]: Number of trucks of type t to rent\n        N = model.addVars(truck_types,\n                          name=\"NumTrucks\",\n                          vtype=GRB.INTEGER,\n                          lb=0)\n\n        # --- Objective Function: Minimize Total Rental Cost ---\n        model.setObjective(\n            gp.quicksum(rental_cost[t] * N[t] for t in truck_types),\n            GRB.MINIMIZE)\n\n        # --- Constraints ---\n        # 1. Refrigerated Cargo Requirement\n        model.addConstr(gp.quicksum(capacity_refrigerated[t] * N[t]\n                                    for t in truck_types)\n                        >= required_refrigerated,\n                        name=\"RefrigeratedCapacity\")\n\n        # 2. Non-Refrigerated Cargo Requirement\n        model.addConstr(gp.quicksum(capacity_non_refrigerated[t] * N[t]\n                                    for t in truck_types)\n                        >= required_non_refrigerated,\n                        name=\"NonRefrigeratedCapacity\")\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal truck rental plan found.\")\n            print(f\"Minimum Total Rental Cost: £{model.ObjVal:.2f}\")\n\n            print(\"\\nNumber of Trucks to Rent:\")\n            for t in truck_types:\n                print(f\"  Type {t}: {N[t].X:.0f} trucks\")\n\n            print(\"\\nCapacity Provided:\")\n            total_ref_cap = sum(capacity_refrigerated[t] * N[t].X\n                                for t in truck_types)\n            total_nonref_cap = sum(capacity_non_refrigerated[t] * N[t].X\n                                   for t in truck_types)\n            print(\n                f\"  Total Refrigerated Capacity: {total_ref_cap:.0f} m³ (Required: >= {required_refrigerated})\"\n            )\n            print(\n                f\"  Total Non-Refrigerated Capacity: {total_nonref_cap:.0f} m³ (Required: >= {required_non_refrigerated})\"\n            )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\"Model is infeasible. Check constraints and requirements.\")\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            # model.computeIIS()\n            # model.write(\"truck_rental_iis.ilp\")\n            # print(\"IIS written to truck_rental_iis.ilp.\")\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n            if model.SolCount == 0:\n                print(\"No feasible solution found.\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_truck_rental()",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B087",
  "description": "A company uses two machines (Machine 1 and Machine 2) to produce two types of products (liquid fertilizer and solid fertilizer). To produce one unit of liquid fertilizer, it takes 50 minutes on Machine 1 and 30 minutes on Machine 2. To produce one unit of solid fertilizer, it takes 24 minutes on Machine 1 and 33 minutes on Machine 2. At the beginning of the week, there are 30 units of liquid fertilizer and 90 units of solid fertilizer in inventory. The available processing time for Machine 1 this week is expected to be 40 hours, and for Machine 2 it is expected to be 35 hours. The demand for liquid fertilizer this week is estimated at 75 units, and for solid fertilizer at 95 units. The company's policy is to maximize the total number of units of liquid fertilizer and solid fertilizer in inventory at the end of the week.\n\nFormulate a model for this problem.",
  "ground_truth": 1.0,
  "formulation": null,
  "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_fertilizer_production():\n    \"\"\"\n    Solves the fertilizer production planning problem to maximize\n    the total ending inventory for the week.\n    \"\"\"\n    try:\n        # --- Parameters ---\n        products = ['Liquid', 'Solid']\n        machines = [1, 2]\n\n        # Time requirements (minutes/unit)\n        # time_req[product][machine]\n        time_req = {'Liquid': {1: 50, 2: 30}, 'Solid': {1: 24, 2: 33}}\n\n        # Available machine time (minutes/week)\n        avail_machine_time = {\n            1: 40 * 60,  # 2400 minutes\n            2: 35 * 60  # 2100 minutes\n        }\n\n        # Initial inventory (units)\n        initial_inventory = {'Liquid': 30, 'Solid': 90}\n\n        # Demand (units/week)\n        demand = {'Liquid': 75, 'Solid': 95}\n\n        # --- Create Gurobi Model ---\n        model = gp.Model(\"FertilizerProduction\")\n\n        # --- Decision Variables ---\n        # Produce[p]: Number of units of product p produced this week\n        Produce = model.addVars(products,\n                                name=\"Produce\",\n                                vtype=GRB.INTEGER,\n                                lb=0)\n\n        # InvEnd[p]: Inventory of product p at the end of the week\n        # We must ensure it's non-negative, which implicitly forces demand to be met.\n        InvEnd = model.addVars(products,\n                               name=\"InvEnd\",\n                               vtype=GRB.INTEGER,\n                               lb=0)\n\n        # --- Objective Function: Maximize Total Ending Inventory ---\n        model.setObjective(gp.quicksum(InvEnd[p] for p in products),\n                           GRB.MAXIMIZE)\n\n        # --- Constraints ---\n        # 1. Machine Time Constraints\n        for m in machines:\n            model.addConstr(gp.quicksum(time_req[p][m] * Produce[p]\n                                        for p in products)\n                            <= avail_machine_time[m],\n                            name=f\"Machine{m}_TimeLimit\")\n\n        # 2. Inventory Balance Constraints\n        # Ending Inventory = Initial Inventory + Production - Demand\n        for p in products:\n            model.addConstr(InvEnd[p] == initial_inventory[p] + Produce[p] -\n                            demand[p],\n                            name=f\"InventoryBalance_{p}\")\n\n        # Note: The constraint InvEnd[p] >= 0 implicitly handles the demand requirement.\n        # If demand cannot be met, the problem will be infeasible.\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal production plan found.\")\n            print(f\"Maximum Total Ending Inventory: {model.ObjVal:.0f} units\")\n\n            print(\"\\nProduction Quantities (units per week):\")\n            for p in products:\n                print(f\"  Product {p}: {Produce[p].X:.0f} units\")\n\n            print(\"\\nEnding Inventory (units):\")\n            for p in products:\n                print(f\"  Product {p}: {InvEnd[p].X:.0f} units\")\n\n            print(\"\\nResource Utilization:\")\n            for m in machines:\n                time_used = sum(time_req[p][m] * Produce[p].X\n                                for p in products)\n                print(\n                    f\"  Machine {m} Time Used: {time_used:.2f} / {avail_machine_time[m]} minutes \"\n                    f\"({(time_used/avail_machine_time[m]*100) if avail_machine_time[m] > 0 else 0:.1f}%)\"\n                )\n\n            print(\"\\nDemand Fulfillment Check:\")\n            for p in products:\n                available = initial_inventory[p] + Produce[p].X\n                print(\n                    f\"  Product {p}: Available={available:.0f}, Demand={demand[p]}\"\n                )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\n                \"Model is infeasible. Check constraints, demand, and available time.\"\n            )\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            # model.computeIIS()\n            # model.write(\"fertilizer_production_iis.ilp\")\n            # print(\"IIS written to fertilizer_production_iis.ilp.\")\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n            if model.SolCount == 0:\n                print(\"No feasible solution found.\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_fertilizer_production()",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B088",
  "description": "A company produces product A and product B. Each unit of product A sold generates a profit of £30, while each unit of product B sold generates a profit of £10. The company can allocate a maximum of 40 hours per week for production. Producing one unit of product A requires 6 hours, while producing one unit of product B requires 3 hours. Market demand requires that the quantity of product B produced must be at least three times the quantity of product A. The storage space occupied by product A is four times that of product B, and a maximum of four units of product A can be stored per week.\n\nFormulate a model for this problem.",
  "ground_truth": 150.0,
  "formulation": null,
  "correct_program": "def optimize_production(profit_A=30,\n                        profit_B=10,\n                        hours_per_A=6,\n                        hours_per_B=3,\n                        max_hours=40,\n                        min_B_ratio=3,\n                        max_A_storage=4):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"Production_Optimization\")\n\n    # Decision variables: number of units of A and B\n    x_A = model.addVar(vtype=GRB.INTEGER, name=\"x_A\", lb=0)\n    x_B = model.addVar(vtype=GRB.INTEGER, name=\"x_B\", lb=0)\n\n    # Set objective: maximize profit\n    model.setObjective(profit_A * x_A + profit_B * x_B, GRB.MAXIMIZE)\n\n    # Add constraints\n    # Production time constraint\n    model.addConstr(hours_per_A * x_A + hours_per_B * x_B <= max_hours,\n                    \"TimeLimit\")\n    # Market demand constraint for B\n    model.addConstr(x_B >= min_B_ratio * x_A, \"DemandB\")\n    # Storage space constraint for A\n    model.addConstr(x_A <= max_A_storage, \"StorageA\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        return model.objVal\n    else:\n        return None\nif __name__ == \"__main__\":  # pragma: no cover\n    result = optimize_production()\n    if result is not None:\n        print(f\"Optimal profit: {result}\")\n    else:\n        print(\"No feasible solution found.\")",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B089",
  "description": "A store wants to clear out 200 shirts and 100 pairs of pants from last season. They decide to introduce two promotional packages, A and B. Package A includes one shirt and two pairs of pants, priced at £30. Package B includes three shirts and one pair of pants, priced at £50. The store does not want to sell fewer than 20 A packages and 10 B packages. How many of each package do they need to sell to maximize the revenue from the promotion?\n\nTry to establish a model for this problem.",
  "ground_truth": 3600.0,
  "formulation": null,
  "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_promotional_packages():\n    \"\"\"\n    Solves the promotional package problem to maximize revenue,\n    subject to inventory and minimum sales constraints.\n    \"\"\"\n    try:\n        # --- Parameters ---\n        packages = ['A', 'B']\n\n        # Inventory available\n        avail_shirts = 200\n        avail_pants = 100\n\n        # Package composition (units per package)\n        # composition[package][item]\n        composition = {\n            'A': {\n                'shirts': 1,\n                'pants': 2\n            },\n            'B': {\n                'shirts': 3,\n                'pants': 1\n            }\n        }\n\n        # Package prices (£ per package)\n        prices = {'A': 30, 'B': 50}\n\n        # Minimum sales requirements (packages)\n        min_sales = {'A': 20, 'B': 10}\n\n        # --- Create Gurobi Model ---\n        model = gp.Model(\"PromotionalPackages\")\n\n        # --- Decision Variables ---\n        # N[p]: Number of packages of type p to sell\n        N = model.addVars(packages,\n                          name=\"NumPackages\",\n                          vtype=GRB.INTEGER,\n                          lb=0)\n\n        # --- Objective Function: Maximize Total Revenue ---\n        model.setObjective(gp.quicksum(prices[p] * N[p] for p in packages),\n                           GRB.MAXIMIZE)\n\n        # --- Constraints ---\n        # 1. Shirt Availability Constraint\n        model.addConstr(gp.quicksum(composition[p]['shirts'] * N[p]\n                                    for p in packages) <= avail_shirts,\n                        name=\"ShirtLimit\")\n\n        # 2. Pants Availability Constraint\n        model.addConstr(gp.quicksum(composition[p]['pants'] * N[p]\n                                    for p in packages) <= avail_pants,\n                        name=\"PantsLimit\")\n\n        # 3. Minimum Sales Requirements\n        for p in packages:\n            model.addConstr(N[p] >= min_sales[p], name=f\"MinSales_{p}\")\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal package sales plan found.\")\n            print(f\"Maximum Total Revenue: £{model.ObjVal:.2f}\")\n\n            print(\"\\nNumber of Packages to Sell:\")\n            for p in packages:\n                print(f\"  Package {p}: {N[p].X:.0f} units\")\n\n            print(\"\\nResource Utilization:\")\n            shirts_used = sum(composition[p]['shirts'] * N[p].X\n                              for p in packages)\n            pants_used = sum(composition[p]['pants'] * N[p].X\n                             for p in packages)\n            print(f\"  Shirts Used: {shirts_used:.0f} / {avail_shirts}\")\n            print(f\"  Pants Used: {pants_used:.0f} / {avail_pants}\")\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\n                \"Model is infeasible. Check constraints, inventory, and minimum sales requirements.\"\n            )\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            # model.computeIIS()\n            # model.write(\"promo_package_iis.ilp\")\n            # print(\"IIS written to promo_package_iis.ilp.\")\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n            if model.SolCount == 0:\n                print(\"No feasible solution found.\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_promotional_packages()",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B090",
  "description": "A company produces two products (A and B), with a profit of £3 and £5 per unit sold, respectively. Each product must be assembled on a specific machine, requiring 12 minutes of assembly time per unit for product A and 25 minutes per unit for product B. The company's estimated effective machine working time per week is only 30 hours (due to maintenance or malfunctions). Technical constraints mean that for every five units of product A produced, at least two units of product B must be produced.\n\nTry to formulate a model for this problem.",
  "ground_truth": 408.0,
  "formulation": null,
  "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_new_production_planning():\n    \"\"\"\n    Solves a production planning problem with a ratio constraint\n    to maximize weekly profit.\n    \"\"\"\n    try:\n        # --- Parameters ---\n        products = ['A', 'B']\n\n        # Profit (£/unit)\n        profit = {'A': 3, 'B': 5}\n\n        # Assembly time requirements (minutes/unit)\n        assembly_time_req = {'A': 12, 'B': 25}\n\n        # Available assembly time (minutes/week)\n        avail_assembly_time = 30 * 60  # 1800 minutes\n\n        # --- Create Gurobi Model ---\n        model = gp.Model(\"NewProductionPlanning\")\n\n        # --- Decision Variables ---\n        # N[p]: Number of units of product p produced per week\n        N = model.addVars(products, name=\"Produce\", vtype=GRB.INTEGER, lb=0)\n\n        # --- Objective Function: Maximize Total Profit ---\n        model.setObjective(gp.quicksum(profit[p] * N[p] for p in products),\n                           GRB.MAXIMIZE)\n\n        # --- Constraints ---\n        # 1. Assembly Time Constraint\n        model.addConstr(gp.quicksum(assembly_time_req[p] * N[p]\n                                    for p in products) <= avail_assembly_time,\n                        name=\"AssemblyTimeLimit\")\n\n        # 2. Technical Ratio Constraint: For every 5 units of A, at least 2 units of B\n        # N_B >= (2/5) * N_A  =>  5 * N_B >= 2 * N_A  =>  2 * N_A - 5 * N_B <= 0\n        model.addConstr(2 * N['A'] - 5 * N['B'] <= 0, name=\"RatioConstraint\")\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal production plan found.\")\n            print(f\"Maximum Weekly Profit: £{model.ObjVal:.2f}\")\n\n            print(\"\\nOptimal Production Quantities (units per week):\")\n            for p in products:\n                print(f\"  Product {p}: {N[p].X:.0f} units\")\n\n            print(\"\\nResource Utilization:\")\n            assembly_time_used = sum(assembly_time_req[p] * N[p].X\n                                     for p in products)\n            print(\n                f\"  Assembly Time Used: {assembly_time_used:.2f} / {avail_assembly_time} minutes \"\n                f\"({(assembly_time_used/avail_assembly_time*100) if avail_assembly_time > 0 else 0:.1f}%)\"\n            )\n\n            print(\"\\nRatio Constraint Check:\")\n            ratio_val = (2 * N['A'].X - 5 * N['B'].X)\n            print(f\"  2*N_A - 5*N_B = {ratio_val:.2f} (Constraint: <= 0)\")\n            if N['A'].X > 0:\n                print(\n                    f\"  Ratio N_B / N_A = {(N['B'].X / N['A'].X):.3f} (Constraint requires >= 2/5 = 0.4)\"\n                )\n            else:\n                print(\"  Ratio N_B / N_A: N/A (N_A = 0)\")\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\"Model is infeasible. Check constraints and requirements.\")\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            # model.computeIIS()\n            # model.write(\"new_production_iis.ilp\")\n            # print(\"IIS written to new_production_iis.ilp.\")\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n            if model.SolCount == 0:\n                print(\"No feasible solution found.\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_new_production_planning()",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B091",
  "description": "A school is preparing a trip for 400 students. The transportation company has 10 buses with 50 seats each and 8 minibuses with 40 seats each, but only 9 drivers are available. The rental cost for a bus is £800, and the rental cost for a minibus is £600. Calculate how many of each type of bus should be used to achieve the lowest cost.\n\nTry to formulate a model for this problem.",
  "ground_truth": 6200.0,
  "formulation": null,
  "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_school_bus_rental():\n    \"\"\"\n    Solves the school bus rental problem to minimize total cost,\n    subject to student capacity, vehicle availability, and driver constraints.\n    \"\"\"\n    try:\n        # --- Parameters ---\n        num_students = 400\n\n        bus_types = ['LargeBus', 'Minibus']\n\n        # Vehicle details\n        capacity = {'LargeBus': 50, 'Minibus': 40}  # seats\n        availability = {'LargeBus': 10, 'Minibus': 8}  # number of vehicles\n        rental_cost = {'LargeBus': 800, 'Minibus': 600}  # £ per vehicle\n\n        # Driver availability\n        available_drivers = 9\n\n        # --- Create Gurobi Model ---\n        model = gp.Model(\"SchoolBusRental\")\n\n        # --- Decision Variables ---\n        # N[bt]: Number of buses of type bt to rent\n        N = model.addVars(bus_types,\n                          name=\"NumVehicles\",\n                          vtype=GRB.INTEGER,\n                          lb=0)\n\n        # --- Objective Function: Minimize Total Rental Cost ---\n        model.setObjective(\n            gp.quicksum(rental_cost[bt] * N[bt] for bt in bus_types),\n            GRB.MINIMIZE)\n\n        # --- Constraints ---\n        # 1. Student Capacity Constraint: Total seats >= num_students\n        model.addConstr(gp.quicksum(capacity[bt] * N[bt] for bt in bus_types)\n                        >= num_students,\n                        name=\"StudentCapacity\")\n\n        # 2. Driver Availability Constraint: Total vehicles <= available_drivers\n        model.addConstr(gp.quicksum(N[bt] for bt in bus_types)\n                        <= available_drivers,\n                        name=\"DriverLimit\")\n\n        # 3. Vehicle Availability Constraints: N[bt] <= availability[bt]\n        for bt in bus_types:\n            model.addConstr(N[bt] <= availability[bt],\n                            name=f\"VehicleLimit_{bt}\")\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal bus rental plan found.\")\n            print(f\"Minimum Total Rental Cost: £{model.ObjVal:.2f}\")\n\n            print(\"\\nNumber of Vehicles to Rent:\")\n            total_vehicles = 0\n            total_capacity = 0\n            for bt in bus_types:\n                print(\n                    f\"  {bt}: {N[bt].X:.0f} (Max Available: {availability[bt]})\"\n                )\n                total_vehicles += N[bt].X\n                total_capacity += capacity[bt] * N[bt].X\n\n            print(\"\\nSummary:\")\n            print(\n                f\"  Total Vehicles Rented: {total_vehicles:.0f} (Drivers Available: {available_drivers})\"\n            )\n            print(\n                f\"  Total Seating Capacity: {total_capacity:.0f} (Students: {num_students})\"\n            )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\n                \"Model is infeasible. It's impossible to transport all students with the available vehicles/drivers.\"\n            )\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            model.computeIIS()\n            model.write(\"bus_rental_iis.ilp\")\n            print(\"IIS written to bus_rental_iis.ilp for debugging.\")\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n            if model.SolCount == 0:\n                print(\"No feasible solution found.\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_school_bus_rental()",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B092",
  "description": "A dairy processing plant uses milk to produce two dairy products, \\( A_{1} \\) and \\( A_{2} \\). One barrel of milk can be processed into 3 kg of \\( A_{1} \\) in 12 hours on Type A equipment or into 4 kg of \\( A_{2} \\) in 8 hours on Type B equipment. According to market demand, all produced \\( A_{1} \\) and \\( A_{2} \\) can be sold. The profit is 24 yuan per kilogram of \\( A_{1} \\) and 16 yuan per kilogram of \\( A_{2} \\). The processing plant can get a daily supply of 50 barrels of milk, with a total of 480 hours of labor time available from regular workers each day. The Type A equipment can process up to 100 kg of \\( A_{1} \\) per day, while the processing capacity of Type B equipment is not limited. Formulate a production plan for the plant to maximize daily profit.",
  "ground_truth": 3360.0,
  "formulation": null,
  "correct_program": "def optimize_dairy_production(milk_barrels=50,\n                              max_hours=480,\n                              max_A1=100,\n                              profit_A1=24,\n                              profit_A2=16):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"Dairy_Production_Maximization\")\n\n    # Decision variables\n    x_A = model.addVar(name=\"A1_kg\", lb=0, vtype=GRB.CONTINUOUS)\n    x_B = model.addVar(name=\"A2_kg\", lb=0, vtype=GRB.CONTINUOUS)\n\n    # Set objective: maximize profit\n    model.setObjective(profit_A1 * x_A + profit_A2 * x_B, GRB.MAXIMIZE)\n\n    # Constraints\n\n    # Milk supply constraint\n    # (x_A / 3) + (x_B / 4) <= total barrels\n    model.addConstr((x_A / 3) + (x_B / 4) <= milk_barrels, name=\"MilkSupply\")\n\n    # Processing time constraint\n    # 4 * x_A + 2 * x_B <= total hours\n    model.addConstr(4 * x_A + 2 * x_B <= max_hours, name=\"ProcessingTime\")\n\n    # Capacity constraint for A1\n    model.addConstr(x_A <= max_A1, name=\"A1Capacity\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        return model.objVal\n    else:\n        return None\nif __name__ == \"__main__\":  # pragma: no cover\n    result = optimize_dairy_production()\n    if result is not None:\n        print(f\"Optimal profit: {result}\")\n    else:\n        print(\"No feasible solution found.\")",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B093",
  "description": "A company blends two types of crude oil (A and B) to produce two types of gasoline (Type I and Type II). The minimum proportion of crude oil A in gasoline Types I and II is 50% and 60%, respectively. The selling prices are 4800 yuan/t and 5600 yuan/t, respectively. The company has current inventories of 500 t of crude oil A and 1000 t of crude oil B, and they can purchase up to 1500 t of crude oil A from the market. The market price for crude oil A is: 10,000 yuan/t for purchases up to 500 t; 8,000 yuan/t for the portion exceeding 500 t but not exceeding 1000 t; 6,000 yuan/t for the portion exceeding 1000 t. How should the company plan its purchasing and processing of crude oil?",
  "ground_truth": 5000000.0,
  "formulation": null,
  "correct_program": "from gurobipy import Model, GRB, quicksum\n\n# 创建模型\nmodel = Model(\"Crude_Oil_Blending_Improved\")\n\n# ----------------------------\n# 参数设置\n# ----------------------------\nprice_I = 4800  # Type I 汽油售价\nprice_II = 5600  # Type II 汽油售价\n\ncost_A_segment1 = 10000  # 第一段成本（前500吨）\ncost_A_segment2 = 8000  # 第二段成本（500~1000吨）\ncost_A_segment3 = 6000  # 第三段成本（超过1000吨）\n\nmax_segment1 = 500  # 第一段最大购买量\nmax_segment2 = 500  # 第二段最大购买量\nmax_segment3 = 500  # 第三段最大购买量（总共最多1500）\n\ninv_A = 500  # 现有原油A库存\ninv_B = 1000  # 现有原油B库存\n\nM = 1e6  # 大M值\n\n# ----------------------------\n# 决策变量\n# ----------------------------\n\n# 汽油产量\nx1 = model.addVar(name=\"Gasoline_TypeI\")\nx2 = model.addVar(name=\"Gasoline_TypeII\")\n\n# 原油使用量\na1 = model.addVar(name=\"CrudeA_TypeI\")\nb1 = model.addVar(name=\"CrudeB_TypeI\")\na2 = model.addVar(name=\"CrudeA_TypeII\")\nb2 = model.addVar(name=\"CrudeB_TypeII\")\n\n# 购买的原油 A 分段数量\npa1 = model.addVar(ub=max_segment1, name=\"PurchaseA_Segment1\")  # ≤500\npa2 = model.addVar(ub=max_segment2, name=\"PurchaseA_Segment2\")  # ≤500\npa3 = model.addVar(ub=max_segment3, name=\"PurchaseA_Segment3\")  # ≤500\n\n# 是否进入某分段的二元变量\ny1 = model.addVar(vtype=GRB.BINARY, name=\"Segment1_Active\")\ny2 = model.addVar(vtype=GRB.BINARY, name=\"Segment2_Active\")\ny3 = model.addVar(vtype=GRB.BINARY, name=\"Segment3_Active\")\n\n# 总共使用的原油A和B\ntotal_a_used = a1 + a2\ntotal_b_used = b1 + b2\n\n# ----------------------------\n# 约束条件\n# ----------------------------\n\n# 1. 汽油生产由对应原油组成\nmodel.addConstr(a1 + b1 == x1, \"TypeI_Production\")\nmodel.addConstr(a2 + b2 == x2, \"TypeII_Production\")\n\n# 2. 原油A占比约束\nmodel.addConstr(a1 >= 0.5 * x1, \"TypeI_Min_A_Content\")\nmodel.addConstr(a2 >= 0.6 * x2, \"TypeII_Min_A_Content\")\n\n# 3. 原油使用总量不能超过库存+购买量\nmodel.addConstr(total_a_used <= inv_A + pa1 + pa2 + pa3, \"CrudeA_Limit\")\nmodel.addConstr(total_b_used <= inv_B, \"CrudeB_Limit\")\n\n# 4. 分段购买逻辑约束（必须买满前面段才允许进入下一段）\n# 第一段：只要 y1=1，就可以买，但不超过 max_segment1\nmodel.addConstr(pa1 <= max_segment1 * y1, \"Segment1_Upper\")\nmodel.addConstr(pa1 >= 0)\n\n# 第二段：只能在 y2=1 且 pa1 已买满时才能购买\nmodel.addConstr(pa2 <= max_segment2 * y2, \"Segment2_Upper\")\nmodel.addConstr(y1 >= y2, \"Must_Fill_Segment1_First\")\nmodel.addConstr(pa1 >= max_segment1 * y2, \"Fill_Segment1_Before_Segment2\")\n\n# 第三段：只能在 y3=1 且 pa1、pa2 都已买满时才能购买\nmodel.addConstr(pa3 <= max_segment3 * y3, \"Segment3_Upper\")\nmodel.addConstr(y2 >= y3, \"Must_Fill_Segment2_Before_Segment3\")\n# model.addConstr(pa1 >= max_segment1 * y3, \"Fill_Segment1_Before_Segment3\")\nmodel.addConstr(pa2 >= max_segment2 * y3, \"Fill_Segment2_Before_Segment3\")\n\n# ----------------------------\n# 目标函数：最大化利润 = 销售收入 - 原油成本\n# ----------------------------\n\nrevenue = price_I * x1 + price_II * x2\npurchase_cost = cost_A_segment1 * pa1 + cost_A_segment2 * pa2 + cost_A_segment3 * pa3\n\nprofit = revenue - purchase_cost\n\nmodel.setObjective(profit, GRB.MAXIMIZE)\n\n# ----------------------------\n# 求解模型\n# ----------------------------\n\nmodel.optimize()\n\n# ----------------------------\n# 输出结果\n# ----------------------------\n\nif model.status == GRB.OPTIMAL:\n    print(\"\\nOptimal Solution Found:\")\n    print(f\"Produce {x1.X:.2f} tons of Gasoline Type I\")\n    print(f\"Produce {x2.X:.2f} tons of Gasoline Type II\")\n    print(f\"Use {a1.X:.2f} tons of Crude A for Type I\")\n    print(f\"Use {b1.X:.2f} tons of Crude B for Type I\")\n    print(f\"Use {a2.X:.2f} tons of Crude A for Type II\")\n    print(f\"Use {b2.X:.2f} tons of Crude B for Type II\")\n    print(f\"Purchase Segment 1: {pa1.X:.2f} tons (<=500)\")\n    print(f\"Purchase Segment 2: {pa2.X:.2f} tons (500~1000)\")\n    print(f\"Purchase Segment 3: {pa3.X:.2f} tons (>1000)\")\n    print(f\"Total Profit: {profit.getValue():.2f} yuan\")\nelse:\n    print(\"No optimal solution found.\")",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B094",
  "description": "A beverage factory produces a kind of beverage to meet market demand. According to market forecasts, the sales department of the factory has determined the demand for the beverage for the next 4 weeks. The planning department, based on the actual situation of the factory, has provided the production capacity and production cost for the next 4 weeks, as shown in Table 1. When there is a surplus of beverages after meeting the demand each week, a storage cost of 0.2 thousand yuan per week per thousand boxes of beverages needs to be paid. How should the production plan be arranged to minimize the total cost (the sum of production cost and storage cost) over the four weeks while meeting the weekly market demand?\n\nTable 1 Beverage Production and Demand Data:\n\n\\begin{tabular}{c|c|c|c}\n\\hline \nWeek & Demand/1000 boxes & Production Capacity/1000 boxes & Cost per 1000 boxes/1000 yuan \\\\\n\\hline \n1 & 15 & 30 & 5.0 \\\\\n\\hline \n2 & 25 & 40 & 5.1 \\\\\n\\hline \n3 & 35 & 45 & 5.4 \\\\\n\\hline \n4 & 25 & 20 & 5.5 \\\\\n\\hline \nTotal & 100 & 135 & \\\\\n\\hline\n\\end{tabular}",
  "ground_truth": 528.0,
  "formulation": null,
  "correct_program": "def optimize_beverage_production():\n    from gurobipy import Model, GRB\n\n    # Data parameters\n    demand = [15, 25, 35, 25]  # demand for weeks 1-4\n    capacity = [30, 40, 45, 20]  # production capacity for weeks 1-4\n    cost = [5.0, 5.1, 5.4, 5.5]  # production cost per 1000 boxes\n    storage_cost = 0.2  # storage cost per 1000 boxes per week\n\n    # Create model\n    m = Model(\"BeverageProduction\")\n\n    # Decision variables\n    P = m.addVars(4, lb=0, name=\"Production\")  # production in each week\n    I = m.addVars(4, lb=0, name=\"Inventory\")  # inventory at end of each week\n\n    # Initial inventory constraint\n    # I_0 = 0 (not a variable, but initial condition)\n    # Inventory balance constraints\n    for t in range(4):\n        if t == 0:\n            m.addConstr(P[t] + 0 == demand[t] + I[t],\n                        name=f\"Balance_week_{t+1}\")\n        else:\n            m.addConstr(I[t - 1] + P[t] == demand[t] + I[t],\n                        name=f\"Balance_week_{t+1}\")\n\n    # Production capacity constraints\n    for t in range(4):\n        m.addConstr(P[t] <= capacity[t], name=f\"Cap_week_{t+1}\")\n\n    # Objective function\n    total_cost = 0\n    for t in range(4):\n        total_cost += cost[t] * P[t] + storage_cost * I[t]\n    m.setObjective(total_cost, GRB.MINIMIZE)\n\n    # Optimize\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        return m.objVal\n    else:\n        return None\nif __name__ == \"__main__\":  # pragma: no cover\n    result = optimize_beverage_production()\n    if result is not None:\n        print(f\"Optimal total cost: {result}\")\n    else:\n        print(\"No feasible solution found.\")",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B096",
  "description": "A company mixes four types of liquid raw materials with different sulfur contents (denoted as A, B, C, and D, respectively) to produce two products (denoted as \\( \\mathrm{A} \\) and \\( \\mathrm{B} \\)). According to the production process requirements, raw materials A, B, and D must first be mixed in a mixing tank, and then the mixed liquid is further mixed with raw material C to produce \\( \\mathrm{A} \\) and \\( \\mathrm{B} \\). The sulfur contents of raw materials A, B, C, and D are \\( 3\\%, 1\\%, 2\\%, 1\\% \\) respectively, and their purchase prices are 6, 16, 10, 15 (thousand yuan per ton) respectively. The sulfur content of products \\( \\mathrm{A} \\) and \\( \\mathrm{B} \\) must not exceed \\( 2.5\\% \\) and \\( 1.5\\% \\) respectively, and their selling prices are 9.15 (thousand yuan per ton). According to market information, there is no limit to the supply of raw materials A, B, and C, but the supply of raw material D is limited to a maximum of 50 tons. The market demand for products \\( \\mathrm{A} \\) and \\( \\mathrm{B} \\) is 100 tons and 200 tons respectively. How should the production be arranged?",
  "ground_truth": 115.0,
  "formulation": null,
  "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_liquid_blending():\n    \"\"\"\n    Solves the liquid blending problem to maximize profit, subject to\n    raw material supply, product demand, and quality (sulfur) constraints.\n    \"\"\"\n    try:\n        # --- Data ---\n        raw_materials = ['A', 'B', 'C', 'D']\n        gasolines = ['GasA', 'GasB']\n\n        # Sulfur content (%)\n        sulfur_content = {'A': 0.03, 'B': 0.01, 'C': 0.02, 'D': 0.01}\n\n        # Purchase prices (thousand yuan per ton)\n        purchase_price = {'A': 6, 'B': 16, 'C': 10, 'D': 15}\n\n        # Selling prices (thousand yuan per ton) - Same for both\n        selling_price = {'GasA': 9.15, 'GasB': 9.15}\n\n        # Max sulfur content allowed in products (%)\n        max_sulfur = {'GasA': 0.025, 'GasB': 0.015}\n\n        # Supply limits (tons) - Only D is limited\n        supply_limit = {'D': 50}\n\n        # Demand limits (tons)\n        demand_limit = {'GasA': 100, 'GasB': 200}\n\n        # --- Create Gurobi Model ---\n        model = gp.Model(\"LiquidBlending\")\n\n        # --- Decision Variables ---\n        # x[i, j]: amount (tons) of raw material i used in gasoline j\n        x = model.addVars(raw_materials,\n                          gasolines,\n                          name=\"Blend\",\n                          lb=0.0,\n                          vtype=GRB.CONTINUOUS)\n\n        # --- Intermediate Expressions (Total Production) ---\n        # Total amount of each gasoline produced\n        GasProduced = {\n            g: gp.quicksum(x[i, g] for i in raw_materials)\n            for g in gasolines\n        }\n\n        # --- Objective Function: Maximize Total Profit ---\n        # Profit = Total Revenue - Total Cost of Raw Materials\n        total_revenue = gp.quicksum(selling_price[g] * GasProduced[g]\n                                    for g in gasolines)\n\n        total_cost = gp.quicksum(purchase_price[i] * x[i, g]\n                                 for i in raw_materials for g in gasolines)\n\n        model.setObjective(total_revenue - total_cost, GRB.MAXIMIZE)\n\n        # --- Constraints ---\n        # 1. Raw Material D Supply Limit\n        model.addConstr(gp.quicksum(x['D', g] for g in gasolines)\n                        <= supply_limit['D'],\n                        name=\"SupplyLimit_D\")\n\n        # 2. Product Demand Limits\n        for g in gasolines:\n            model.addConstr(GasProduced[g] <= demand_limit[g],\n                            name=f\"DemandLimit_{g}\")\n\n        # 3. Sulfur Content Limits\n        for g in gasolines:\n            total_sulfur_in_g = gp.quicksum(sulfur_content[i] * x[i, g]\n                                            for i in raw_materials)\n            # total_sulfur_in_g <= max_sulfur[g] * GasProduced[g]\n            model.addConstr(total_sulfur_in_g\n                            <= max_sulfur[g] * GasProduced[g],\n                            name=f\"SulfurLimit_{g}\")\n\n            # Alternative formulation (avoids division by zero if GasProduced[g] could be 0):\n            # (total_sulfur_in_g - max_sulfur[g] * GasProduced[g]) <= 0\n            # model.addConstr(gp.quicksum((sulfur_content[i] - max_sulfur[g]) * x[i, g]\n            #                             for i in raw_materials) <= 0,\n            #                 name=f\"SulfurLimit_{g}_alt\")\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal blending plan found.\")\n            # Convert profit back to yuan from thousand yuan\n            print(f\"Maximum Profit: {model.ObjVal * 1000:.2f} Yuan\")\n\n            print(\"\\nOptimal Production Quantities (tons):\")\n            total_revenue_val = 0\n            for g in gasolines:\n                prod_qty = GasProduced[g].getValue()\n                total_revenue_val += selling_price[g] * prod_qty\n                print(f\"  Gasoline {g}: {prod_qty:.2f} tons\")\n                if prod_qty > 1e-6:  # Avoid division by zero\n                    print(f\"    Composition:\")\n                    actual_sulfur_g = 0\n                    for i in raw_materials:\n                        if x[i, g].X > 1e-6:\n                            percentage = (x[i, g].X / prod_qty * 100)\n                            actual_sulfur_g += sulfur_content[i] * x[i, g].X\n                            print(\n                                f\"      Raw Material {i}: {x[i,g].X:.2f} tons ({percentage:.1f}%)\"\n                            )\n                    actual_sulfur_percent = (actual_sulfur_g / prod_qty *\n                                             100) if prod_qty > 1e-6 else 0\n                    print(\n                        f\"    -> Actual Sulfur Content: {actual_sulfur_percent:.3f}% (Max: {max_sulfur[g]*100:.1f}%)\"\n                    )\n\n            print(\"\\nRaw Material Usage (tons):\")\n            total_cost_val = 0\n            for i in raw_materials:\n                usage = sum(x[i, g].X for g in gasolines)\n                cost_i = purchase_price[i] * usage\n                total_cost_val += cost_i\n                limit_str = f\"(Limit: {supply_limit[i]})\" if i in supply_limit else \"\"\n                print(f\"  Raw Material {i}: {usage:.2f} tons {limit_str}\")\n\n            print(\"\\nFinancial Summary (Thousand Yuan):\")\n            print(f\"  Total Revenue: {total_revenue_val:.3f}\")\n            print(f\"  Total Raw Material Cost: {total_cost_val:.3f}\")\n            print(\n                f\"  Calculated Profit: {(total_revenue_val - total_cost_val):.3f}\"\n            )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\n                \"Model is infeasible. Check constraints, demands, supply, and quality requirements.\"\n            )\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            # model.computeIIS()\n            # model.write(\"liquid_blending_iis.ilp\")\n            # print(\"IIS written to liquid_blending_iis.ilp for debugging.\")\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n            if model.SolCount == 0:\n                print(\"No feasible solution found.\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_liquid_blending()",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B097",
  "description": "A company uses steel and aluminum as raw materials to produce two products (A and B). A single unit of product A requires 6 kg of steel, 8 kg of aluminum, 11 hours of labor, and yields a profit of 5000 yuan (excluding worker overtime pay). A single unit of product B requires 12 kg of steel, 20 kg of aluminum, 24 hours of labor, and yields a profit of 11000 yuan (excluding worker overtime pay). The company currently has 200 kg of steel, 300 kg of aluminum, and 300 hours of labor available. If workers need to work overtime, the overtime pay is 100 yuan per hour. Please develop a production plan to maximize the company's profit and minimize worker overtime.",
  "ground_truth": 165900.0,
  "formulation": null,
  "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_production_planning_with_overtime():\n    \"\"\"\n    Solves the production planning problem to maximize net profit,\n    considering resource constraints and overtime pay.\n    \"\"\"\n    try:\n        # --- Parameters ---\n        products = ['A', 'B']\n\n        # Profit per unit (excluding worker overtime pay) (yuan/unit)\n        gross_profit = {'A': 5000, 'B': 11000}\n\n        # Resource requirements per unit\n        steel_req = {'A': 6, 'B': 12}  # kg/unit\n        aluminum_req = {'A': 8, 'B': 20}  # kg/unit\n        labor_req = {'A': 11, 'B': 24}  # hours/unit\n\n        # Resource availability\n        avail_steel = 200  # kg\n        avail_aluminum = 300  # kg\n        avail_labor_regular = 300  # hours\n\n        # Overtime pay (yuan/hour)\n        overtime_pay_per_hour = 100\n\n        # --- Create Gurobi Model ---\n        model = gp.Model(\"ProductionPlanningOvertime\")\n\n        # --- Decision Variables ---\n        # X[p]: Number of units of product p to produce\n        X = model.addVars(products, name=\"Produce\", vtype=GRB.INTEGER, lb=0)\n\n        # OT: Total overtime hours used\n        OT = model.addVar(name=\"OvertimeHours\", lb=0.0, vtype=GRB.CONTINUOUS)\n\n        # --- Objective Function: Maximize Net Profit ---\n        # Net Profit = Gross Profit from Products - Cost of Overtime\n        total_gross_profit = gp.quicksum(gross_profit[p] * X[p]\n                                         for p in products)\n        total_overtime_cost = overtime_pay_per_hour * OT\n\n        model.setObjective(total_gross_profit - total_overtime_cost,\n                           GRB.MAXIMIZE)\n\n        # --- Constraints ---\n        # 1. Steel Constraint\n        model.addConstr(gp.quicksum(steel_req[p] * X[p] for p in products)\n                        <= avail_steel,\n                        name=\"SteelLimit\")\n\n        # 2. Aluminum Constraint\n        model.addConstr(gp.quicksum(aluminum_req[p] * X[p] for p in products)\n                        <= avail_aluminum,\n                        name=\"AluminumLimit\")\n\n        # 3. Labor Constraint\n        # Total labor hours required can be met by regular hours + overtime hours\n        # TotalLaborRequired <= RegularLaborAvailable + Overtime\n        # TotalLaborRequired - Overtime <= RegularLaborAvailable\n        total_labor_needed = gp.quicksum(labor_req[p] * X[p] for p in products)\n        model.addConstr(total_labor_needed <= avail_labor_regular + OT,\n                        name=\"LaborAvailability\")\n\n        # Alternative for Labor Constraint (explicitly defines OT if positive):\n        # model.addConstr(total_labor_needed - OT <= avail_labor_regular, name=\"LaborConstraint\")\n        # This is equivalent to the one above given OT >= 0.\n        # The objective function will naturally try to minimize OT if it costs money.\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal production plan found.\")\n            print(f\"Maximum Net Profit: {model.ObjVal:.2f} Yuan\")\n\n            print(\"\\nOptimal Production Quantities (units):\")\n            for p in products:\n                print(f\"  Product {p}: {X[p].X:.0f} units\")\n\n            print(f\"\\nOvertime Hours Used: {OT.X:.2f} hours\")\n            print(\n                f\"Cost of Overtime: {(overtime_pay_per_hour * OT.X):.2f} Yuan\")\n\n            print(\"\\nResource Utilization:\")\n            steel_used = sum(steel_req[p] * X[p].X for p in products)\n            aluminum_used = sum(aluminum_req[p] * X[p].X for p in products)\n            labor_needed_val = sum(labor_req[p] * X[p].X for p in products)\n\n            print(\n                f\"  Steel Used: {steel_used:.2f} / {avail_steel} kg \"\n                f\"({(steel_used/avail_steel*100) if avail_steel > 0 else 0:.1f}%)\"\n            )\n            print(\n                f\"  Aluminum Used: {aluminum_used:.2f} / {avail_aluminum} kg \"\n                f\"({(aluminum_used/avail_aluminum*100) if avail_aluminum > 0 else 0:.1f}%)\"\n            )\n            print(f\"  Total Labor Needed: {labor_needed_val:.2f} hours\")\n            print(\n                f\"    Met by Regular Hours: {min(labor_needed_val, avail_labor_regular):.2f} / {avail_labor_regular} hours\"\n            )\n            if OT.X > 1e-6:\n                print(f\"    Met by Overtime Hours: {OT.X:.2f} hours\")\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\n                \"Model is infeasible. Check constraints and resource availability.\"\n            )\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            # model.computeIIS()\n            # model.write(\"production_overtime_iis.ilp\")\n            # print(\"IIS written to production_overtime_iis.ilp for debugging.\")\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n            if model.SolCount == 0:\n                print(\"No feasible solution found.\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_production_planning_with_overtime()",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B098",
  "description": "An electronic system is composed of 3 types of components. The system operates normally if all three components function properly. By installing one or more spare parts for any of the components, the reliability of the components can be improved. The system's operational reliability is the product of the reliabilities of each component, and the reliability of each component is a function of the number of spare parts installed. The first half of the table below shows the function relationship between the number of spare parts and the reliability of a specific component. The prices and weights of the 3 types of components are shown in rows 8 to 9 of the table. Given that the total budget for all spare parts is limited to 150 yuan, and the weight limit is 20 kg, how should spare parts be installed to maximize the system's operational reliability? \n\n\\begin{table}[h]\n\\centering\n\\begin{tabular}{|c|c|c|c|}\n\\hline\n\\textbf{Component Number} & \\textbf{1} & \\textbf{2} & \\textbf{3} \\\\ \\hline\n\\textbf{Number of Spares} &             &             &             \\\\ \\hline\n0                & 0.5         & 0.6         & 0.7         \\\\ \\hline\n1                & 0.6         & 0.75        & 0.9         \\\\ \\hline\n2                & 0.7         & 0.95        & 1.0         \\\\ \\hline\n3                & 0.8         & 1.0         & 1.0         \\\\ \\hline\n4                & 0.9         & 1.0         & 1.0         \\\\ \\hline\n5                & 1.0         & 1.0         & 1.0         \\\\ \\hline\n\\textbf{Unit Price (yuan)}  & 20           & 30           & 40           \\\\ \\hline\n\\textbf{Unit Weight (kg)}  & 2            & 4            & 6            \\\\ \\hline\n\\end{tabular}\n\\caption{Spare Component Data Table}\n\\end{table}",
  "ground_truth": 0.6075,
  "formulation": null,
  "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\nimport math  # For math.exp in results if needed\n\n\ndef solve_system_reliability():\n    \"\"\"\n    Solves the system reliability optimization problem to determine the optimal\n    number of spare parts for each component to maximize overall system reliability,\n    subject to budget and weight constraints.\n    Uses a log-transformed objective for Gurobi.\n    \"\"\"\n    try:\n        # --- Data ---\n        num_components = 3\n        components = range(\n            num_components)  # Indices 0, 1, 2 for Components 1, 2, 3\n\n        max_spares_per_component = 5\n        num_spare_options = max_spares_per_component + 1\n        spare_counts_options = range(num_spare_options)\n\n        reliability_data = [\n            [0.5, 0.6, 0.7, 0.8, 0.9, 1.0],  # Component 1\n            [0.6, 0.75, 0.95, 1.0, 1.0, 1.0],  # Component 2\n            [0.7, 0.9, 1.0, 1.0, 1.0, 1.0]  # Component 3\n        ]\n\n        prices = [20, 30, 40]  # yuan\n        weights = [2, 4, 6]  # kg\n\n        max_budget = 150  # yuan\n        max_weight = 20  # kg\n\n        # --- Create Gurobi Model ---\n        model = gp.Model(\"SystemReliabilityOptimization\")\n\n        # --- Decision Variables ---\n        # x[c,s]: 1 if component c has s spares installed, 0 otherwise\n        x = model.addVars(components,\n                          spare_counts_options,\n                          vtype=GRB.BINARY,\n                          name=\"x_spares_selection\")\n\n        # Rel[c]: Achieved reliability of component c\n        # Ensure Rel[c] is strictly positive for log function. Smallest reliability is 0.5.\n        Rel = model.addVars(components,\n                            name=\"Rel_component\",\n                            lb=0.0001,\n                            ub=1.0,\n                            vtype=GRB.CONTINUOUS)\n\n        # log_Rel[c]: Natural logarithm of Rel[c]\n        # Gurobi's log is natural log. The bounds for log_Rel depend on Rel's bounds.\n        # log(0.0001) approx -9.21, log(1) = 0\n        log_Rel = model.addVars(components,\n                                name=\"log_Rel_component\",\n                                lb=-10,\n                                ub=0.0,\n                                vtype=GRB.CONTINUOUS)\n\n        # --- Objective Function: Maximize Sum of Log(Reliabilities) ---\n        # This is equivalent to maximizing the product of reliabilities.\n        # Gurobi needs NonConvex=2 for general constraints like log.\n        model.Params.NonConvex = 2\n        model.setObjective(gp.quicksum(log_Rel[c] for c in components),\n                           GRB.MAXIMIZE)\n\n        # --- Constraints ---\n        # 1. Unique Spare Count Selection: For each component c, exactly one x[c,s] is 1\n        for c in components:\n            model.addConstr(gp.quicksum(\n                x[c, s_option] for s_option in spare_counts_options) == 1,\n                            name=f\"UniqueSpares_Comp{c+1}\")\n\n        # 2. Component Reliability Definition: Rel[c] = sum(Reliability_data[c][s_option] * x[c,s_option])\n        for c in components:\n            model.addConstr(Rel[c] == gp.quicksum(\n                reliability_data[c][s_option] * x[c, s_option]\n                for s_option in spare_counts_options),\n                            name=f\"DefineRel_Comp{c+1}\")\n\n        # 3. Link Rel[c] and log_Rel[c]: log_Rel[c] = log(Rel[c])\n        for c in components:\n            model.addGenConstrLog(Rel[c],\n                                  log_Rel[c],\n                                  name=f\"LogConstraint_Comp{c+1}\")\n\n        # 4. Budget Constraint: sum_c sum_s (price[c] * s * x[c,s]) <= max_budget\n        total_cost = gp.quicksum(prices[c] * s_option * x[c, s_option]\n                                 for c in components\n                                 for s_option in spare_counts_options)\n        model.addConstr(total_cost <= max_budget, name=\"BudgetLimit\")\n\n        # 5. Weight Constraint: sum_c sum_s (weight[c] * s * x[c,s]) <= max_weight\n        total_weight = gp.quicksum(weights[c] * s_option * x[c, s_option]\n                                   for c in components\n                                   for s_option in spare_counts_options)\n        model.addConstr(total_weight <= max_weight, name=\"WeightLimit\")\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n        model.setParam('MIPGap', 0.001)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal spare parts installation plan found.\")\n            # Calculate the actual system reliability (product of individual reliabilities)\n            actual_system_reliability = 1.0\n            for c in components:\n                actual_system_reliability *= Rel[c].X\n\n            print(\n                f\"Maximum System Operational Reliability: {actual_system_reliability:.4f} (or {actual_system_reliability*100:.2f}%)\"\n            )\n            print(\n                f\"Objective Function Value (Sum of Log Reliabilities): {model.ObjVal:.4f}\"\n            )\n\n            print(\"\\nOptimal Number of Spare Parts for Each Component:\")\n            num_spares_chosen = {}\n            for c in components:\n                for s_option_val in spare_counts_options:\n                    if x[c, s_option_val].X > 0.5:\n                        num_spares_chosen[c] = s_option_val\n                        print(\n                            f\"  Component {c+1}: Install {s_option_val} spare part(s)\"\n                        )\n                        break\n\n            print(\"\\nAchieved Component Reliabilities:\")\n            for c in components:\n                print(\n                    f\"  Component {c+1}: {Rel[c].X:.4f} (Reliability with {num_spares_chosen[c]} spares, log(Rel): {log_Rel[c].X:.4f})\"\n                )\n\n            print(\"\\nResource Usage:\")\n            final_cost = sum(prices[c] * num_spares_chosen[c]\n                             for c in components)\n            final_weight = sum(weights[c] * num_spares_chosen[c]\n                               for c in components)\n            print(\n                f\"  Total Cost: {final_cost:.2f} Yuan (Budget: <= {max_budget})\"\n            )\n            print(\n                f\"  Total Weight: {final_weight:.2f} kg (Limit: <= {max_weight})\"\n            )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\n                \"Model is infeasible. The requirements cannot be met under the given budget and weight constraints.\"\n            )\n            model.computeIIS()\n            model.write(\"system_reliability_iis.ilp\")\n            print(\"IIS written to system_reliability_iis.ilp for debugging.\")\n        elif model.status == GRB.INF_OR_UNBD:\n            print(\"Model is infeasible or unbounded.\")\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n            if model.SolCount == 0:\n                print(\"No feasible solution found.\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n        print(f\"Error message: {e.message}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_system_reliability()",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
},
{
  "task_id": "B099",
  "description": "In network communication services, bandwidth plays an important role. Below is a bandwidth communication table between several communication nodes, showing the bandwidth between any two nodes. If two nodes cannot be directly connected, the corresponding bandwidth is $0$. It is required to establish a link between node $A$ and node $E$ that must pass through service node $C$ (without loops). The bandwidth of this link is defined as the minimum bandwidth value on the link. Please propose a reasonable link arrangement to maximize the bandwidth of this link and find out the maximum bandwidth.\n\n\\begin{table}[h]\n    \\centering\n    \\begin{tabular}{|c|c|c|c|c|c|}\n        \\hline\n        & A & B & C & D & E \\\\\n        \\hline\n        A & 0 & 90 & 85 & 0 & 65 \\\\\n        \\hline\n        B & 95 & 0 & 70 & 65 & 34 \\\\\n        \\hline\n        C & 60 & 0 & 0 & 88 & 80 \\\\\n        \\hline\n        D & 67 & 30 & 25 & 0 & 84 \\\\\n        \\hline\n        E & 0 & 51 & 0 & 56 & 0 \\\\\n        \\hline\n    \\end{tabular}\n\\end{table}",
  "ground_truth": 84.0,
  "formulation": null,
  "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_max_bandwidth_path():\n    \"\"\"\n    Solves the problem of finding a path from node A to E via node C\n    that maximizes the bottleneck bandwidth.\n    \"\"\"\n    try:\n        # --- Data ---\n        nodes_map = {'A': 0, 'B': 1, 'C': 2, 'D': 3, 'E': 4}\n        nodes_rev_map = {v: k for k, v in nodes_map.items()}\n        num_nodes = len(nodes_map)\n        all_nodes = range(num_nodes)\n\n        start_node = nodes_map['A']\n        intermediate_node = nodes_map['C']\n        end_node = nodes_map['E']\n\n        # Bandwidth matrix BW[i][j]\n        #       A   B   C   D   E\n        bw_data = [\n            [0, 90, 85, 0, 65],  # A\n            [95, 0, 70, 65, 34],  # B\n            [60, 0, 0, 88, 80],  # C\n            [67, 30, 25, 0, 84],  # D\n            [0, 51, 0, 56, 0]  # E\n        ]\n\n        max_possible_bandwidth = 0\n        for row in bw_data:\n            for val in row:\n                if val > max_possible_bandwidth:\n                    max_possible_bandwidth = val\n        if max_possible_bandwidth == 0:  # Should not happen with given data\n            max_possible_bandwidth = 1000  # A large number\n\n        # --- Create Gurobi Model ---\n        model = gp.Model(\"MaxBandwidthPathViaC\")\n\n        # --- Decision Variables ---\n        # x[i,j]: 1 if link (i,j) is in path A to C\n        x = model.addVars(all_nodes,\n                          all_nodes,\n                          vtype=GRB.BINARY,\n                          name=\"x_path_AC\")\n        # y[i,j]: 1 if link (i,j) is in path C to E\n        y = model.addVars(all_nodes,\n                          all_nodes,\n                          vtype=GRB.BINARY,\n                          name=\"y_path_CE\")\n\n        # B_overall: Overall bottleneck bandwidth of the A-C-E path\n        B_overall = model.addVar(name=\"OverallBandwidth\",\n                                 lb=0.0,\n                                 vtype=GRB.CONTINUOUS)\n\n        # Remove self-loops and links with zero bandwidth\n        for i in all_nodes:\n            x[i, i].UB = 0\n            y[i, i].UB = 0\n            for j in all_nodes:\n                if i == j: continue\n                if bw_data[i][j] == 0:\n                    x[i, j].UB = 0\n                    y[i, j].UB = 0\n\n        # --- Objective Function: Maximize B_overall ---\n        model.setObjective(B_overall, GRB.MAXIMIZE)\n\n        # --- Constraints ---\n        # Path A (start_node) to C (intermediate_node) using x_vars\n        # 1. Flow out of start_node A for path x\n        model.addConstr(\n            gp.quicksum(x[start_node, j] for j in all_nodes\n                        if j != start_node) == 1, \"FlowOut_A_x\")\n        # 2. No flow into start_node A for path x\n        model.addConstr(\n            gp.quicksum(x[j, start_node] for j in all_nodes\n                        if j != start_node) == 0, \"FlowIn_A_x\")\n        # 3. Flow into intermediate_node C for path x\n        model.addConstr(\n            gp.quicksum(x[i, intermediate_node] for i in all_nodes\n                        if i != intermediate_node) == 1, \"FlowIn_C_x\")\n        # 4. No flow out of intermediate_node C for path x\n        model.addConstr(\n            gp.quicksum(x[intermediate_node, j] for j in all_nodes\n                        if j != intermediate_node) == 0, \"FlowOut_C_x\")\n        # 5. Flow conservation for other nodes in path x\n        for k in all_nodes:\n            if k != start_node and k != intermediate_node:\n                model.addConstr(gp.quicksum(x[i, k] for i in all_nodes\n                                            if i != k) == gp.quicksum(\n                                                x[k, j] for j in all_nodes\n                                                if j != k),\n                                name=f\"FlowCons_x_{k}\")\n                # Ensure intermediate nodes are visited at most once\n                model.addConstr(\n                    gp.quicksum(x[i, k] for i in all_nodes if i != k) <= 1,\n                    f\"VisitOnce_x_{k}\")\n\n        # Path C (intermediate_node) to E (end_node) using y_vars\n        # 6. Flow out of intermediate_node C for path y\n        model.addConstr(\n            gp.quicksum(y[intermediate_node, j] for j in all_nodes\n                        if j != intermediate_node) == 1, \"FlowOut_C_y\")\n        # 7. No flow into intermediate_node C for path y\n        model.addConstr(\n            gp.quicksum(y[j, intermediate_node] for j in all_nodes\n                        if j != intermediate_node) == 0, \"FlowIn_C_y\")\n        # 8. Flow into end_node E for path y\n        model.addConstr(\n            gp.quicksum(y[i, end_node] for i in all_nodes\n                        if i != end_node) == 1, \"FlowIn_E_y\")\n        # 9. No flow out of end_node E for path y\n        model.addConstr(\n            gp.quicksum(y[end_node, j] for j in all_nodes\n                        if j != end_node) == 0, \"FlowOut_E_y\")\n        # 10. Flow conservation for other nodes in path y\n        for k in all_nodes:\n            if k != intermediate_node and k != end_node:\n                model.addConstr(gp.quicksum(y[i, k] for i in all_nodes\n                                            if i != k) == gp.quicksum(\n                                                y[k, j] for j in all_nodes\n                                                if j != k),\n                                name=f\"FlowCons_y_{k}\")\n                # Ensure intermediate nodes are visited at most once\n                model.addConstr(\n                    gp.quicksum(y[i, k] for i in all_nodes if i != k) <= 1,\n                    f\"VisitOnce_y_{k}\")\n\n        # 11. Node Disjointness (except at C)\n        # Nodes B, D (indices 1, 3) cannot be intermediate in both paths.\n        # Node A (0) cannot be in path y. Node E (4) cannot be in path x.\n        for k in all_nodes:\n            if k != intermediate_node:  # For all nodes except C\n                # If node k is entered in path x, it cannot be entered in path y\n                model.addConstr(gp.quicksum(x[i, k]\n                                            for i in all_nodes if i != k) +\n                                gp.quicksum(y[i, k]\n                                            for i in all_nodes if i != k) <= 1,\n                                name=f\"NodeDisjoint_{k}\")\n\n        # 12. Bandwidth Definition\n        for i in all_nodes:\n            for j in all_nodes:\n                if i == j or bw_data[i][j] == 0:\n                    continue  # Skip self-loops and zero-bandwidth links\n                # If x[i,j] is 1, then B_overall <= bw_data[i][j]\n                model.addConstr(B_overall <= bw_data[i][j] +\n                                max_possible_bandwidth * (1 - x[i, j]),\n                                name=f\"B_limit_x_{i}_{j}\")\n                # If y[i,j] is 1, then B_overall <= bw_data[i][j]\n                model.addConstr(B_overall <= bw_data[i][j] +\n                                max_possible_bandwidth * (1 - y[i, j]),\n                                name=f\"B_limit_y_{i}_{j}\")\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n        model.setParam('MIPGap', 0.001)  # Set a small MIP gap\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal link arrangement found.\")\n            print(\n                f\"Maximum Path Bandwidth (A through C to E): {B_overall.X:.2f}\"\n            )\n\n            path_AC_str = nodes_rev_map[start_node]\n            curr = start_node\n            visited_in_ac = {start_node}\n            for _ in range(num_nodes):  # Max possible length\n                found_next = False\n                for j_node in all_nodes:\n                    if curr != j_node and x[curr, j_node].X > 0.5:\n                        path_AC_str += f\" -> {nodes_rev_map[j_node]}\"\n                        curr = j_node\n                        visited_in_ac.add(curr)\n                        found_next = True\n                        break\n                if curr == intermediate_node or not found_next:\n                    break\n            print(f\"  Path A to C: {path_AC_str}\")\n\n            path_CE_str = nodes_rev_map[intermediate_node]\n            curr = intermediate_node\n            visited_in_ce = {intermediate_node}\n            for _ in range(num_nodes):  # Max possible length\n                found_next = False\n                for j_node in all_nodes:\n                    if curr != j_node and y[curr, j_node].X > 0.5:\n                        path_CE_str += f\" -> {nodes_rev_map[j_node]}\"\n                        curr = j_node\n                        visited_in_ce.add(curr)\n                        found_next = True\n                        break\n                if curr == end_node or not found_next:\n                    break\n            print(f\"  Path C to E: {path_CE_str}\")\n\n            print(\"\\n  Links used in A-C path and their bandwidths:\")\n            for i in all_nodes:\n                for j in all_nodes:\n                    if i != j and x[i, j].X > 0.5:\n                        print(\n                            f\"    {nodes_rev_map[i]} -> {nodes_rev_map[j]} (BW: {bw_data[i][j]})\"\n                        )\n\n            print(\"  Links used in C-E path and their bandwidths:\")\n            for i in all_nodes:\n                for j in all_nodes:\n                    if i != j and y[i, j].X > 0.5:\n                        print(\n                            f\"    {nodes_rev_map[i]} -> {nodes_rev_map[j]} (BW: {bw_data[i][j]})\"\n                        )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\n                \"Model is infeasible. No path from A to E via C could be found or satisfies constraints.\"\n            )\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            model.computeIIS()\n            model.write(\"bandwidth_path_iis.ilp\")\n            print(\"IIS written to bandwidth_path_iis.ilp for debugging.\")\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n            if model.SolCount == 0:\n                print(\"No feasible solution found.\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_max_bandwidth_path()",
  "output_status": [],
  "success_count": 0,
  "success_confidence": 0,
  "fail_to_diagnose": 0
,
  "retrieved_insights": []
}
]
