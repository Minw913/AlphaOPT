[
  {
    "task_id": "D073",
    "description": "A regional beverage distributor needs to optimize the delivery of 5 products (A,B,C,D,E) from their central warehouse (Node 1) to 3 retail stores (Nodes 4,5,6) through a transportation network with 6 nodes and 8 directed arcs. Each arc has a maximum capacity (in pallets/day) and transportation cost ($/pallet): (1→2): 20 pallets, $3; (1→3): 15 pallets, $4; (2→3): 10 pallets, $2; (2→4): 12 pallets, $5; (3→5): 18 pallets, $3; (3→6): 10 pallets, $6; (4→5): 8 pallets, $1; (5→6): 15 pallets, $2. The daily demands are: Store 4 needs 8 pallets (A:3, B:2, C:3), Store 5 needs 12 pallets (B:4, D:5, E:3), Store 6 needs 10 pallets (A:2, C:3, E:5). The warehouse can supply up to 30 pallets total daily. The goal is to satisfy all demands at minimum transportation cost while respecting arc capacities and product-specific requirements.",
    "ground_truth": 249.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_beverage_distribution(\n    N=[1, 2, 3, 4, 5, 6],\n    A=[(1, 2), (1, 3), (2, 3), (2, 4), (3, 5), (3, 6), (4, 5), (5, 6)],\n    P=['A', 'B', 'C', 'D', 'E'],\n    source=1,\n    sinks=[4, 5, 6],\n    u={\n        (1, 2): 20, (1, 3): 15, (2, 3): 10, (2, 4): 12,\n        (3, 5): 18, (3, 6): 10, (4, 5): 8, (5, 6): 15\n    },\n    c={\n        (1, 2): 3, (1, 3): 4, (2, 3): 2, (2, 4): 5,\n        (3, 5): 3, (3, 6): 6, (4, 5): 1, (5, 6): 2\n    },\n    d={\n        (4, 'A'): 3, (4, 'B'): 2, (4, 'C'): 3,\n        (5, 'B'): 4, (5, 'D'): 5, (5, 'E'): 3,\n        (6, 'A'): 2, (6, 'C'): 3, (6, 'E'): 5\n    },\n    supply_limit=30\n):\n    \"\"\"Solve the multi-commodity beverage distribution problem using Gurobi.\"\"\"\n    # Create model\n    model = gp.Model(\"BeverageDistribution\")\n\n    # ========== Decision Variables ==========\n    # Flow of product p on arc (i,j)\n    x = model.addVars(A, P, lb=0, name=\"flow\")\n\n    # ========== Objective Function ==========\n    # Minimize total transportation cost\n    model.setObjective(\n        gp.quicksum(c[i, j] * x[i, j, p] for (i, j) in A for p in P),\n        GRB.MINIMIZE\n    )\n\n    # ========== Constraints ==========\n    # 1. Flow conservation at intermediate nodes (nodes 2,3)\n    for i in [2, 3]:\n        for p in P:\n            model.addConstr(\n                gp.quicksum(x[i, j, p] for (i_, j) in A if i_ == i) -\n                gp.quicksum(x[j, i, p] for (j, i_) in A if i_ == i) == 0,\n                f\"flow_conservation_node_{i}_product_{p}\"\n            )\n\n    # 2. Demand satisfaction at sink nodes\n    for i in sinks:\n        for p in P:\n            if (i, p) in d:\n                model.addConstr(\n                    gp.quicksum(x[j, i, p] for (j, i_) in A if i_ == i) -\n                    gp.quicksum(x[i, j, p] for (i_, j) in A if i_ == i) == d[i, p],\n                    f\"demand_satisfaction_node_{i}_product_{p}\"\n                )\n            else:\n                # No demand for this product at this node\n                model.addConstr(\n                    gp.quicksum(x[j, i, p] for (j, i_) in A if i_ == i) -\n                    gp.quicksum(x[i, j, p] for (i_, j) in A if i_ == i) == 0,\n                    f\"no_demand_node_{i}_product_{p}\"\n                )\n\n    # 3. Arc capacity constraints\n    for (i, j) in A:\n        model.addConstr(\n            gp.quicksum(x[i, j, p] for p in P) <= u[i, j],\n            f\"arc_capacity_{i}_{j}\"\n        )\n\n    # 4. Source supply limit\n    model.addConstr(\n        gp.quicksum(x[source, j, p] for (i, j) in A if i == source for p in P) <= supply_limit,\n        \"source_supply_limit\"\n    )\n\n    # ========== Solve the Model ==========\n    model.optimize()\n\n    # ========== Return Results ==========\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\n# Execute the function\nif __name__ == \"__main__\":\n    result = solve_beverage_distribution()\n    print(result)",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Network Flow",
        "modeling_type": "LP",
        "industry_sector": "Logistics",
        "reason": "The problem involves optimizing the flow of multiple products through a network to satisfy demands at minimum cost, which is a classic multi-commodity network flow problem. The solver uses continuous variables and linear constraints, making it a Linear Program (LP). The application is in distributing goods, fitting within the logistics sector."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D026",
    "description": "A national e-commerce company operates three distribution centers in the Metro region. Each center currently stores different quantities of standard and premium products as shown below:\n\n| Distribution Center | Standard Products | Premium Products |\n|---------------------|-------------------|------------------|\n| Center 1            | 150               | 30               |\n| Center 2            | 250               | 100              |\n| Center 3            | 300               | 70               |\n\nThe company plans to open three retail fulfillment hubs that will serve customers with same-day delivery. Corporate policy requires that each fulfillment hub must maintain exactly 300 products in total inventory, and each hub must stock the same number of premium products to ensure consistent customer experience across all locations. The shipping distances (in kilometers) between distribution centers and fulfillment hubs are shown as follows:\n\n| From / To           | Hub 1 | Hub 2 | Hub 3 |\n|---------------------|-------|-------|-------|\n| Center 1            | 0     | 12    | 18    |\n| Center 2            | 12    | 0     | 15    |\n| Center 3            | 18    | 15    | 0     |\n\nWhat is the minimum total transportation distance required to move the products under the company's inventory requirements?",
    "ground_truth": 1440.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_product_distribution(\n    HubInventoryRequirement=300,\n    StoreStandardProducts=[150, 250, 300],\n    StorePremiumProducts=[30, 100, 70],\n    ShippingDistance=[[0, 12, 18], [12, 0, 15], [18, 15, 0]]):\n    \"\"\"\n    Solves the product distribution optimization problem.\n    \"\"\"\n    # Create a new model\n    model = gp.Model(\"Product Distribution Optimization\")\n\n    # Parameters and Sets\n    DistributionCenterNum = len(StoreStandardProducts)\n    FulfillmentHubNum = len(ShippingDistance)\n    ProductTypeNum = 2  # 0 for standard, 1 for premium\n\n    DCs = range(DistributionCenterNum)\n    Hubs = range(FulfillmentHubNum)\n    Products = range(ProductTypeNum)\n\n    # Decision Variables\n    ShipAmount = model.addVars(DCs,\n                               Hubs,\n                               Products,\n                               vtype=GRB.INTEGER,\n                               name=\"ShipAmount\")\n\n    # Objective: Minimize total transportation distance\n    model.setObjective(\n        gp.quicksum(ShippingDistance[d][h] * ShipAmount[d, h, p]\n                    for d in DCs for h in Hubs for p in Products),\n        GRB.MINIMIZE)\n\n    # Constraint 1: Fulfillment hub inventory constraint\n    model.addConstrs(\n        (gp.quicksum(ShipAmount[d, h, p] for d in DCs for p in Products) ==\n         HubInventoryRequirement for h in Hubs),\n        name=\"Hub_Inventory\")\n\n    # Constraint 2: Product type balance constraint (standard products)\n    # This constraint limits the amount shipped on each individual path\n    # based on the total stock at the distribution center.\n    model.addConstrs(\n        (ShipAmount[d, h, 0] <= StoreStandardProducts[d] for d in DCs\n         for h in Hubs),\n        name=\"Standard_Product_Limit\")\n\n    # Constraint 3: Product type balance constraint (premium products)\n    model.addConstrs(\n        (ShipAmount[d, h, 1] <= StorePremiumProducts[d] for d in DCs\n         for h in Hubs),\n        name=\"Premium_Product_Limit\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Return results\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_product_distribution()\n    print(result)",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Network Flow",
        "modeling_type": "MILP",
        "industry_sector": "E-commerce",
        "reason": "The problem involves distributing products from distribution centers to fulfillment hubs, minimizing transportation distance, which is a classic network flow problem. The solver uses integer variables and linear constraints, making it a Mixed-Integer Linear Program. The context of distribution centers and fulfillment hubs for same-day delivery clearly places it in the e-commerce sector."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D002",
    "description": "A logistics company has many boxes with the same structure and capacity, and the number of boxes is sufficient for the purpose at hand. The capacity of each box is 10. There are 7 items with loads of 6, 7, 8, 3, 2, 4 and 5 that need to be packed into the boxes. Find a loading method that uses the minimum number of boxes to pack all 7 items.",
    "ground_truth": 4.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_bin_packing(\n    item_loads={1: 6, 2: 7, 3: 8, 4: 3, 5: 2, 6: 4, 7: 5},\n    box_capacity=10\n):\n    \"\"\"\n    Models and solves the Bin Packing problem.\n    \"\"\"\n    # --- 1. Model Creation ---\n    model = gp.Model(\"BinPacking\")\n\n    # --- 2. Sets and Parameters ---\n    items = list(item_loads.keys())\n    # The number of bins cannot exceed the number of items\n    bins = range(1, len(items) + 1)\n\n    # --- 3. Decision Variables ---\n    # x[b] = 1 if bin b is used, 0 otherwise\n    x = model.addVars(bins, vtype=GRB.BINARY, name=\"BinUsed\")\n\n    # y[i,b] = 1 if item i is packed in bin b, 0 otherwise\n    y = model.addVars(items, bins, vtype=GRB.BINARY, name=\"ItemInBin\")\n\n    # --- 4. Objective Function ---\n    # Minimize the number of bins used\n    model.setObjective(gp.quicksum(x[b] for b in bins), GRB.MINIMIZE)\n\n    # --- 5. Constraints ---\n    # Constraint 1: Each item must be packed in exactly one bin\n    for i in items:\n        model.addConstr(gp.quicksum(y[i, b] for b in bins) == 1,\n                        name=f\"item_assign_{i}\")\n\n    # Constraint 2: The total load of items in each bin must not exceed its capacity.\n    # This also links the y and x variables: if a bin is not used (x[b]=0),\n    # no items can be placed in it (sum of y[i,b] must be 0).\n    for b in bins:\n        model.addConstr(\n            gp.quicksum(item_loads[i] * y[i, b] for i in items) <= box_capacity * x[b],\n            name=f\"bin_capacity_{b}\"\n        )\n\n    # --- 6. Solve the Model ---\n    model.setParam(\"OutputFlag\", 0)  # Suppress Gurobi output\n    model.optimize()\n\n    # --- 7. Return Results ---\n    if model.status == GRB.OPTIMAL:\n        # Gurobi objective value can be a float, so we cast to int for bin packing\n        return {\"status\": \"optimal\", \"obj\": int(model.ObjVal)}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\n# Run the solver function\nif __name__ == \"__main__\":\n    result = solve_bin_packing()\n    print(result)",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Bin Packing",
        "modeling_type": "MILP",
        "industry_sector": "Logistics",
        "reason": "The problem explicitly describes packing items into boxes with a fixed capacity to minimize the number of boxes used, which is the definition of Bin Packing. The solver uses binary variables for item assignment and bin usage, and linear constraints and objective, classifying it as a Mixed-Integer Linear Program. The context of packing items into boxes for a logistics company places it in the Logistics sector."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D044",
    "description": "You are in charge of GreenTech Manufacturing, a company that produces eco-friendly packaging materials from recycled paper. The company produces two types of packaging: Premium and Standard. Premium packaging sells for $15 per ton and must have an average quality score of at least 9. Standard packaging sells for $8 per ton and must have an average quality score of at least 7. The maximum demand is 2,500 tons of Premium packaging and 800 tons of Standard packaging per month. \n\nRecycled paper can be processed using one of three methods. The yield and cost per ton for each method are shown in the table below. For example, processing one ton of recycled paper using Method 1 costs $4.20 and yields 0.3 tons of quality score 6, 0.4 tons of quality score 8, and 0.3 tons of quality score 10. These costs include the expenses of acquiring the recycled paper. Before being converted into packaging materials, quality scores 6 and 8 can be enhanced through a refinement process. For $1.20 per ton, one ton of quality score 6 can be upgraded to quality score 8. For $1.80 per ton, one ton of quality score 8 can be upgraded to quality score 10. How can GreenTech Manufacturing maximize its monthly profit while meeting quality and demand requirements?\n\n| Processing Method | Cost per Ton ($) | Yield (Quality 6) | Yield (Quality 8) | Yield (Quality 10) |  \n|--------------------|-------------------|--------------------|--------------------|---------------------|  \n| Method 1           | 4.20              | 0.3                | 0.4                | 0.3                 |  \n| Method 2           | 3.80              | 0.5                | 0.3                | 0.2                 |  \n| Method 3           | 4.50              | 0.2                | 0.5                | 0.3                 |",
    "ground_truth": 28864.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_greentech_manufacturing(\n    cost_per_ton_method={\"Method1\": 4.20, \"Method2\": 3.80, \"Method3\": 4.50},\n    yield_per_method={\n        \"Method1\": {\"Q6\": 0.3, \"Q8\": 0.4, \"Q10\": 0.3},\n        \"Method2\": {\"Q6\": 0.5, \"Q8\": 0.3, \"Q10\": 0.2},\n        \"Method3\": {\"Q6\": 0.2, \"Q8\": 0.5, \"Q10\": 0.3}\n    },\n    actual_quality_values={\"Q6\": 6, \"Q8\": 8, \"Q10\": 10},\n    upgrade_cost={\"Q6_to_Q8\": 1.20, \"Q8_to_Q10\": 1.80},\n    price_per_ton={\"Premium\": 15, \"Standard\": 8},\n    min_quality_score_req={\"Premium\": 9, \"Standard\": 7},\n    max_demand={\"Premium\": 2500, \"Standard\": 800}\n):\n    \"\"\"\n    Models and solves the GreenTech Manufacturing problem.\n    \"\"\"\n    # Create a new model\n    model = gp.Model(\"GreenTechManufacturing\")\n\n    # --- Sets ---\n    packaging_types = [\"Premium\", \"Standard\"]\n    methods = [\"Method1\", \"Method2\", \"Method3\"]\n    quality_labels = [\"Q6\", \"Q8\", \"Q10\"]\n\n    # --- Decision Variables ---\n    processing_amount = model.addVars(methods, name=\"ProcessingAmount\", lb=0)\n    quality6_upgrade_amount = model.addVar(name=\"Quality6UpgradeAmount\", lb=0)\n    quality8_upgrade_amount = model.addVar(name=\"Quality8UpgradeAmount\", lb=0)\n    packaging_produced = model.addVars(packaging_types, quality_labels, name=\"PackagingProduced\", lb=0)\n\n    # --- Objective Function: Maximize Total Profit ---\n    total_revenue = gp.quicksum(price_per_ton[p] * packaging_produced.sum(p, '*') for p in packaging_types)\n    total_processing_cost = gp.quicksum(cost_per_ton_method[m] * processing_amount[m] for m in methods)\n    total_upgrade_cost = (upgrade_cost[\"Q6_to_Q8\"] * quality6_upgrade_amount +\n                          upgrade_cost[\"Q8_to_Q10\"] * quality8_upgrade_amount)\n    model.setObjective(total_revenue - total_processing_cost - total_upgrade_cost, GRB.MAXIMIZE)\n\n    # --- Constraints ---\n    for p in packaging_types:\n        weighted_quality_sum = gp.quicksum(actual_quality_values[q_label] * packaging_produced[p, q_label]\n                                           for q_label in quality_labels)\n        total_produced_p = packaging_produced.sum(p, '*')\n        model.addConstr(weighted_quality_sum >= min_quality_score_req[p] * total_produced_p,\n                        name=f\"QualityScore_{p}\")\n\n    for p in packaging_types:\n        model.addConstr(packaging_produced.sum(p, '*') <= max_demand[p], name=f\"Demand_{p}\")\n\n    produced_q6_material = gp.quicksum(yield_per_method[m][\"Q6\"] * processing_amount[m] for m in methods)\n    used_as_q6_in_packaging = gp.quicksum(packaging_produced[p, \"Q6\"] for p in packaging_types)\n    model.addConstr(produced_q6_material - quality6_upgrade_amount >= used_as_q6_in_packaging, name=\"Balance_Q6\")\n\n    produced_q8_material_native = gp.quicksum(yield_per_method[m][\"Q8\"] * processing_amount[m] for m in methods)\n    total_available_q8_material = produced_q8_material_native + quality6_upgrade_amount\n    used_as_q8_in_packaging = gp.quicksum(packaging_produced[p, \"Q8\"] for p in packaging_types)\n    model.addConstr(total_available_q8_material - quality8_upgrade_amount >= used_as_q8_in_packaging, name=\"Balance_Q8\")\n\n    produced_q10_material_native = gp.quicksum(yield_per_method[m][\"Q10\"] * processing_amount[m] for m in methods)\n    total_available_q10_material = produced_q10_material_native + quality8_upgrade_amount\n    used_as_q10_in_packaging = gp.quicksum(packaging_produced[p, \"Q10\"] for p in packaging_types)\n    model.addConstr(total_available_q10_material >= used_as_q10_in_packaging, name=\"Balance_Q10\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Return Results\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == '__main__':\n    result = solve_greentech_manufacturing()\n    print(result)\n",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Blending",
        "modeling_type": "LP",
        "industry_sector": "Manufacturing",
        "reason": "The problem involves mixing different qualities of recycled paper, potentially after refinement, to produce two types of packaging materials (Premium and Standard) that meet specific average quality requirements. This is a classic blending problem. The solver program uses continuous variables and linear constraints, indicating a Linear Programming (LP) model. The context of producing packaging materials from recycled paper clearly falls under the manufacturing sector."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D078",
    "description": "A specialty coffee roasting company has received shipments of two premium green coffee beans: Ethiopia Yirgacheffe (8,000 kg) and Colombia Supremo (12,000 kg). The company needs to allocate these beans to two different product lines to maximize its weekly profit:\n1.  **Single-Origin Bags (SO):** High-end bags of whole beans sold to specialty cafes.\n2.  **House Blend (HB):** A signature blend sold ground to retail partners.\n\n**Economic & Quality Data:**\nThe profitability of each product line depends on the cost of the beans and the processing involved. Furthermore, each product line must meet a minimum average quality standard, measured by the coffee's \"cupping score\" (a 0-100 scale).\n\n| Bean Origin | Available (kg) | Cupping Score |\n|:-----------:|:--------------:|:-------------:|\n| Ethiopia    | 8,000          | 92            |\n| Colombia    | 12,000         | 87            |\n\n| Product Line      | Revenue per kg | Processing Cost per kg | Minimum Avg. Cupping Score |\n|:------------------|:--------------:|:----------------------:|:--------------------------:|\n| Single-Origin (SO)| $40.00         | $5.00                  | 90                         |\n| House Blend (HB)  | $28.00         | $8.50                  | 88                         |\n\n**Operational Constraints:**\n- The company's primary roaster, used for the House Blend, has a maximum weekly processing capacity of 10,000 kg.\n- Due to a contract with a key client, the company must produce at least 2,000 kg of Single-Origin bags per week.\n\nThe goal is to determine the optimal quantity (in kg) of each type of green bean to allocate to each product line to maximize total weekly profit, while respecting all inventory, quality, and operational constraints.",
    "ground_truth": 545000.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_coffee_blending(\n    beans=['Ethiopia', 'Colombia'],\n    processes=['SO', 'HB'],\n    inventory={'Ethiopia': 8000, 'Colombia': 12000},\n    cupping_score={'Ethiopia': 92, 'Colombia': 87},\n    revenue={'SO': 40, 'HB': 28},\n    proc_cost={'SO': 5, 'HB': 8.5},\n    quality_threshold={'SO': 90, 'HB': 88},\n    roaster_capacity_hb=10000,\n    min_production_so=2000\n):\n    \"\"\"\n    Solves the specialty coffee blending and allocation problem to maximize profit.\n    \"\"\"\n\n    # Create a new model\n    model = gp.Model(\"CoffeeBlending\")\n\n    # --- Decision Variables ---\n    # x[b, p]: kg of bean 'b' allocated to process 'p'\n    x = model.addVars(beans, processes, lb=0, name=\"allocation\")\n\n    # --- Objective Function ---\n    # Maximize total profit: (Revenue - Processing Cost) * Quantity\n    profit = gp.quicksum((revenue[p] - proc_cost[p]) * x[b, p]\n                         for b in beans for p in processes)\n    model.setObjective(profit, GRB.MAXIMIZE)\n\n    # --- Constraints ---\n    # 1. Inventory limits for each bean type\n    model.addConstrs((x.sum(b, '*') <= inventory[b] for b in beans),\n                     name=\"inventory\")\n\n    # 2. Quality requirements for each product line (linearized)\n    for p in processes:\n        model.addConstr(gp.quicksum(\n            (cupping_score[b] - quality_threshold[p]) * x[b, p]\n            for b in beans) >= 0,\n                        name=f\"quality_{p}\")\n\n    # 3. Operational constraints\n    model.addConstr(x.sum('*', 'HB') <= roaster_capacity_hb,\n                    name=\"roaster_capacity\")\n    model.addConstr(x.sum('*', 'SO') >= min_production_so,\n                    name=\"min_so_production\")\n\n    # --- Solve the model ---\n    model.optimize()\n\n    # --- Return results ---\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_coffee_blending()\n    print(result)",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Blending",
        "modeling_type": "LP",
        "industry_sector": "Food & Beverage",
        "reason": "The problem involves mixing different types of coffee beans to create products while meeting quality standards and maximizing profit, which is a classic blending problem. The solver program uses continuous variables and linear constraints, making it a Linear Program. The application is clearly within the coffee roasting business, which falls under the Food & Beverage sector."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D072",
    "description": "A regional distribution center needs to optimize its daily delivery routes for 5 stores located at different distances. The center has 3 available delivery trucks with capacities of 8, 10, and 12 tons respectively. The daily demands of the stores are: Store1 (3 tons), Store2 (4 tons), Store3 (5 tons), Store4 (2 tons), and Store5 (6 tons). The distance matrix (in km) between the distribution center (DC) and stores is: DC-Store1: 15, DC-Store2: 20, DC-Store3: 25, DC-Store4: 30, DC-Store5: 35. Each truck can visit multiple stores but cannot exceed its capacity. The objective is to minimize the total distance traveled by all trucks while ensuring all store demands are met.",
    "ground_truth": 60.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\ndef solve_delivery_routing(\n    trucks=[1, 2, 3],\n    stores=[1, 2, 3, 4, 5],\n    truck_capacities={1: 8, 2: 10, 3: 12},\n    store_demands={1: 3, 2: 4, 3: 5, 4: 2, 5: 6},\n    distances={1: 15, 2: 20, 3: 25, 4: 30, 5: 35}\n):\n    \"\"\"\n    Solves the delivery routing optimization problem using Gurobi.\n    Minimizes total distance traveled by trucks while meeting store demands and truck capacity constraints.\n    \"\"\"\n    # Create model\n    model = gp.Model(\"DeliveryRouting\")\n\n    # Decision variables\n    # Binary variable indicating if truck t is used\n    truck_used = model.addVars(trucks, vtype=GRB.BINARY, name=\"truck_used\")\n    # Binary variable indicating if store s is assigned to truck t\n    store_assignment = model.addVars(stores, trucks, vtype=GRB.BINARY, name=\"store_assignment\")\n    # Continuous variable for distance traveled by each truck\n    route_distance = model.addVars(trucks, lb=0, vtype=GRB.CONTINUOUS, name=\"route_distance\")\n\n    # Objective: Minimize total distance traveled by all trucks\n    model.setObjective(\n        gp.quicksum(route_distance[t] for t in trucks),\n        GRB.MINIMIZE\n    )\n\n    # Constraints\n    # 1. Each store must be assigned to exactly one truck\n    model.addConstrs(\n        (store_assignment.sum(s, '*') == 1 for s in stores),\n        name=\"store_assignment\"\n    )\n\n    # 2. Truck capacity cannot be exceeded\n    model.addConstrs(\n        (gp.quicksum(store_demands[s] * store_assignment[s, t] for s in stores) <= truck_capacities[t]\n         for t in trucks),\n        name=\"truck_capacity\"\n    )\n\n    # 3. Distance calculation (truck distance is distance to farthest store visited)\n    model.addConstrs(\n        (route_distance[t] >= distances[s] * store_assignment[s, t]\n         for s in stores for t in trucks),\n        name=\"distance_calc\"\n    )\n\n    # 4. Truck usage constraint (if any store is assigned to truck)\n    model.addConstrs(\n        (gp.quicksum(store_assignment[s, t] for s in stores) <= len(stores) * truck_used[t]\n         for t in trucks),\n        name=\"truck_usage\"\n    )\n\n    # Optimize model\n    model.optimize()\n\n    # Return results\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_delivery_routing()\n    print(result)",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Vehicle Routing",
        "modeling_type": "MILP",
        "industry_sector": "Logistics",
        "reason": "The problem involves assigning stores to trucks and determining routes to minimize total distance, which is a classic Vehicle Routing Problem. The solver uses binary and continuous variables with linear constraints and an objective function, indicating a Mixed-Integer Linear Programming formulation."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D013",
    "description": "A logistics company needs to deliver packages to multiple booked customer, the logistics center's coordinates are (0, 0), and the company has 5 trucks with a capacity of 15 units of packages available for delivery. It is known that there are 12 customer points that need to be delivered, with coordinates (4.36, -2.75), (-7.29, -3.22), (-8.74, -2.47), (-0.68, -5.15), (-0.39, -3.49), (-6.06, -5.52), (-2.67, 9.32), (9.91, 7.87), (2.03, -2.98), (2.33, -1.47), (5.1, -2.08), (-8.04, -9.78), and the demands are 6, 7, 1, 10, 8, 7, 3, 6, 5, 2, 4, 4 units of packages respectively. Trucks start from the logistics center, complete the delivery on the planned route, and then return to the logistics center. The number of trucks used should be less than or equal to the number of trucks owned by the company. Under the condition of meeting all customer demands, what is the shortest total driving distance for the trucks? (Assuming the distance between each point is calculated based on the straight-line distance.)",
    "ground_truth": 104.3352564869,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\nimport math\n\ndef solve_vehicle_routing(\n    customer_num=12,\n    truck_num=5,\n    truck_capacity=15,\n    node_coordinates=[\n        (0, 0), (4.36, -2.75), (-7.29, -3.22), (-8.74, -2.47),\n        (-0.68, -5.15), (-0.39, -3.49), (-6.06, -5.52),\n        (-2.67, 9.32), (9.91, 7.87), (2.03, -2.98), (2.33, -1.47),\n        (5.1, -2.08), (-8.04, -9.78)\n    ],\n    customer_demand=[6, 7, 1, 10, 8, 7, 3, 6, 5, 2, 4, 4]\n):\n    \"\"\"\n    Solves the vehicle routing problem.\n    \"\"\"\n    model = gp.Model(\"VehicleRoutingProblem\")\n\n    center = 0\n    customers = range(1, customer_num + 1)\n    nodes = [center] + list(customers)\n    trucks = range(1, truck_num + 1)\n\n    distance = {}\n    for i in nodes:\n        for j in nodes:\n            if i != j:\n                x1, y1 = node_coordinates[i]\n                x2, y2 = node_coordinates[j]\n                distance[i, j] = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)\n\n    x = {}\n    for i in nodes:\n        for j in nodes:\n            if i != j:\n                for k in trucks:\n                    x[i, j, k] = model.addVar(vtype=GRB.BINARY, name=f\"x_{i}_{j}_{k}\")\n\n    objective = gp.quicksum(distance[i, j] * x[i, j, k] for i in nodes for j in nodes for k in trucks if i != j)\n    model.setObjective(objective, GRB.MINIMIZE)\n\n    for j in customers:\n        model.addConstr(gp.quicksum(x[i, j, k] for i in nodes if i != j for k in trucks) == 1, name=f\"customer_visited_{j}\")\n\n    for i in customers:\n        for k in trucks:\n            model.addConstr(gp.quicksum(x[i, j, k] for j in nodes if i != j) - gp.quicksum(x[j, i, k] for j in nodes if i != j) == 0, name=f\"flow_conservation_{i}_{k}\")\n\n    for k in trucks:\n        model.addConstr(gp.quicksum(x[center, j, k] for j in customers) <= 1, name=f\"truck_{k}_leaves_center\")\n        model.addConstr(gp.quicksum(x[center, j, k] for j in customers) == gp.quicksum(x[j, center, k] for j in customers), name=f\"truck_{k}_returns_center\")\n\n    for k in trucks:\n        model.addConstr(gp.quicksum(customer_demand[j - 1] * gp.quicksum(x[i, j, k] for i in nodes if i != j) for j in customers) <= truck_capacity, name=f\"truck_{k}_capacity\")\n\n    def find_subtours(x_vals, k):\n        edges = [(i, j) for i in customers for j in customers if i != j and x_vals.get((i, j, k), 0) > 0.5]\n        if not edges:\n            return []\n        \n        neighbors = {i: [] for i in customers}\n        for i, j in edges:\n            neighbors[i].append(j)\n        \n        unvisited = set(customers)\n        subtours = []\n        while unvisited:\n            curr = next(iter(unvisited))\n            tour = [curr]\n            unvisited.remove(curr)\n            \n            while True:\n                neighbors_of_curr = [j for j in neighbors.get(curr, []) if j in unvisited]\n                if not neighbors_of_curr:\n                    break\n                curr = neighbors_of_curr[0]\n                tour.append(curr)\n                unvisited.remove(curr)\n            \n            is_valid_tour = any(x_vals.get((center, i, k), 0) > 0.5 for i in tour) and any(x_vals.get((i, center, k), 0) > 0.5 for i in tour)\n            if not is_valid_tour and tour:\n                subtours.append(tour)\n        return subtours\n\n    def subtour_elimination_callback(model, where):\n        if where == GRB.Callback.MIPSOL:\n            x_vals = model.cbGetSolution(x)\n            for k in trucks:\n                subtours = find_subtours(x_vals, k)\n                for subtour in subtours:\n                    if len(subtour) < customer_num:\n                        model.cbLazy(gp.quicksum(x[i, j, k] for i in subtour for j in subtour if i != j) <= len(subtour) - 1)\n\n    model.Params.lazyConstraints = 1\n    model.optimize(subtour_elimination_callback)\n\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.objVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\nif __name__ == \"__main__\":\n    result = solve_vehicle_routing()\n    print(result)\n\n",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Routing",
        "modeling_type": "MILP",
        "industry_sector": "Logistics",
        "reason": "The problem involves finding the shortest routes for multiple trucks to deliver packages to customers, starting and ending at a central depot, which is a classic Vehicle Routing Problem. The solver uses binary variables for arc selection and integer variables for flow, along with linear constraints and a lazy constraint callback for subtour elimination, fitting the Mixed-Integer Linear Programming paradigm. The application directly addresses package delivery for a logistics company."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D053",
    "description": "A large-scale logistics company specializes in transporting a wide variety of perishable goods from a central distribution hub to several supermarket chains. The company uses a fleet of advanced refrigerated trucks, and for a specific delivery route, one truck needs to be loaded. Each truck has strict capacity limits in four dimensions: a maximum weight of 12 tons, a total volume of 35 m³, a refrigeration power output of 40 kW, and a total cool-down time budget of 100 hours (a proxy for the energy and time required to bring goods to their optimal temperature and maintain it).\n\nThe goods are classified into 10 distinct categories. For each category, the company can choose from 5 different variants, each sourced from a different supplier and having unique characteristics. The company must select exactly one variant from each of the 10 categories to be included in the shipment with the primary goal to maximize the total profit.\n\nFurthermore, there are two special conditions for this delivery:\n1.  Product Synergy: If Variant B of Fruits (Category 1) and Variant C of Baked Goods (Category 6) are shipped together, a special packaging collaboration creates an additional bonus profit of $150.\n2.  Product Conflict: Due to the high risk of cross-contamination, shipping Variant A of Seafood (Category 5) and Variant A of Dairy (Category 3) together is forbidden.\n\nThe complete data for all available goods is as follows:\n\n| Category | Variant | Weight (t) | Volume (m³) | Power (kW) | Cool-Down (hr) | Profit ($) |\n| :--- | :--- | :--- | :--- | :--- | :--- | :--- |\n| **1: Fruits** | A | 1.1 | 2.8 | 2.0 | 8.0 | 210 |\n| | B | 1.3 | 3.2 | 2.5 | 10.0 | 290 |\n| | C | 0.9 | 2.4 | 1.8 | 7.0 | 190 |\n| | D | 1.4 | 3.5 | 2.8 | 11.0 | 320 |\n| | E | 1.0 | 2.6 | 1.9 | 7.5 | 200 |\n| **2: Vegetables** | A | 0.8 | 2.0 | 1.0 | 5.0 | 160 |\n| | B | 1.0 | 2.5 | 1.5 | 6.0 | 230 |\n| | C | 0.7 | 1.8 | 0.9 | 4.5 | 140 |\n| | D | 1.2 | 2.8 | 1.8 | 7.0 | 260 |\n| | E | 0.9 | 2.2 | 1.2 | 5.5 | 190 |\n| **3: Dairy** | A | 1.5 | 4.5 | 4.2 | 12.0 | 360 |\n| | B | 1.3 | 4.0 | 3.5 | 10.0 | 310 |\n| | C | 1.7 | 5.0 | 4.8 | 14.0 | 420 |\n| | D | 1.4 | 4.2 | 3.8 | 11.0 | 340 |\n| | E | 1.6 | 4.8 | 4.5 | 13.0 | 400 |\n| **4: Meat** | A | 1.9 | 4.0 | 6.5 | 15.0 | 520 |\n| | B | 1.6 | 3.5 | 5.5 | 13.0 | 460 |\n| | C | 2.1 | 4.5 | 7.2 | 17.0 | 580 |\n| | D | 1.8 | 3.8 | 6.0 | 14.0 | 500 |\n| | E | 2.2 | 4.8 | 7.5 | 18.0 | 600 |\n| **5: Seafood** | A | 1.4 | 3.0 | 8.0 | 16.0 | 480 |\n| | B | 1.2 | 2.8 | 7.0 | 14.0 | 430 |\n| | C | 1.6 | 3.5 | 9.0 | 18.0 | 550 |\n| | D | 1.3 | 2.9 | 7.5 | 15.0 | 450 |\n| | E | 1.7 | 3.8 | 9.5 | 19.0 | 590 |\n| **6: Baked Goods**| A | 0.5 | 1.5 | 0.5 | 2.0 | 90 |\n| | B | 0.7 | 2.0 | 0.8 | 3.0 | 140 |\n| | C | 0.6 | 1.8 | 0.6 | 2.5 | 120 |\n| | D | 0.8 | 2.2 | 1.0 | 3.5 | 160 |\n| | E | 0.4 | 1.2 | 0.4 | 1.5 | 80 |\n| **7: Beverages** | A | 1.8 | 3.0 | 1.5 | 4.0 | 250 |\n| | B | 2.0 | 3.5 | 1.8 | 5.0 | 290 |\n| | C | 1.6 | 2.8 | 1.4 | 3.5 | 220 |\n| | D | 2.2 | 3.8 | 2.0 | 6.0 | 330 |\n| | E | 1.7 | 2.9 | 1.6 | 4.5 | 240 |\n| **8: Frozen** | A | 2.0 | 5.0 | 8.0 | 20.0 | 500 |\n| | B | 1.8 | 4.5 | 7.0 | 18.0 | 450 |\n| | C | 2.3 | 5.5 | 9.0 | 22.0 | 580 |\n| | D | 2.1 | 5.2 | 8.5 | 21.0 | 540 |\n| | E | 2.5 | 6.0 | 9.8 | 24.0 | 620 |\n| **9: Deli Meats** | A | 0.9 | 2.0 | 3.0 | 6.0 | 180 |\n| | B | 1.1 | 2.5 | 3.5 | 7.0 | 240 |\n| | C | 0.8 | 1.8 | 2.8 | 5.5 | 160 |\n| | D | 1.2 | 2.8 | 4.0 | 8.0 | 270 |\n| | E | 1.0 | 2.2 | 3.2 | 6.5 | 210 |\n| **10: Prepared** | A | 1.3 | 3.0 | 4.0 | 9.0 | 300 |\n| | B | 1.5 | 3.5 | 4.5 | 10.0 | 350 |\n| | C | 1.2 | 2.8 | 3.8 | 8.0 | 280 |\n| | D | 1.6 | 3.8 | 5.0 | 11.0 | 380 |\n| | E | 1.4 | 3.2 | 4.2 | 9.5 | 330 |",
    "ground_truth": 2880.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_large_scale_transport_problem(\n    categories={\n        1: \"Fruits\", 2: \"Vegetables\", 3: \"Dairy\", 4: \"Meat\", 5: \"Seafood\",\n        6: \"Baked Goods\", 7: \"Beverages\", 8: \"Frozen\", 9: \"Deli Meats\", 10: \"Prepared\"\n    },\n    variants=['A', 'B', 'C', 'D', 'E'],\n    weight_limit=12.0,\n    volume_limit=35.0,\n    power_limit=40.0,\n    time_limit=100.0,\n    bonus_profit=150,\n    data={\n        1: {'A': [1.1, 2.8, 2.0, 8, 210], 'B': [1.3, 3.2, 2.5, 10, 290], 'C': [0.9, 2.4, 1.8, 7, 190], 'D': [1.4, 3.5, 2.8, 11, 320], 'E': [1.0, 2.6, 1.9, 7.5, 200]},\n        2: {'A': [0.8, 2.0, 1.0, 5, 160], 'B': [1.0, 2.5, 1.5, 6, 230], 'C': [0.7, 1.8, 0.9, 4.5, 140], 'D': [1.2, 2.8, 1.8, 7, 260], 'E': [0.9, 2.2, 1.2, 5.5, 190]},\n        3: {'A': [1.5, 4.5, 4.2, 12, 360], 'B': [1.3, 4.0, 3.5, 10, 310], 'C': [1.7, 5.0, 4.8, 14, 420], 'D': [1.4, 4.2, 3.8, 11, 340], 'E': [1.6, 4.8, 4.5, 13, 400]},\n        4: {'A': [1.9, 4.0, 6.5, 15, 520], 'B': [1.6, 3.5, 5.5, 13, 460], 'C': [2.1, 4.5, 7.2, 17, 580], 'D': [1.8, 3.8, 6.0, 14, 500], 'E': [2.2, 4.8, 7.5, 18, 600]},\n        5: {'A': [1.4, 3.0, 8.0, 16, 480], 'B': [1.2, 2.8, 7.0, 14, 430], 'C': [1.6, 3.5, 9.0, 18, 550], 'D': [1.3, 2.9, 7.5, 15, 450], 'E': [1.7, 3.8, 9.5, 19, 590]},\n        6: {'A': [0.5, 1.5, 0.5, 2, 90], 'B': [0.7, 2.0, 0.8, 3, 140], 'C': [0.6, 1.8, 0.6, 2.5, 120], 'D': [0.8, 2.2, 1.0, 3.5, 160], 'E': [0.4, 1.2, 0.4, 1.5, 80]},\n        7: {'A': [1.8, 3.0, 1.5, 4, 250], 'B': [2.0, 3.5, 1.8, 5, 290], 'C': [1.6, 2.8, 1.4, 3.5, 220], 'D': [2.2, 3.8, 2.0, 6, 330], 'E': [1.7, 2.9, 1.6, 4.5, 240]},\n        8: {'A': [2.0, 5.0, 8.0, 20, 500], 'B': [1.8, 4.5, 7.0, 18, 450], 'C': [2.3, 5.5, 9.0, 22, 580], 'D': [2.1, 5.2, 8.5, 21, 540], 'E': [2.5, 6.0, 9.8, 24, 620]},\n        9: {'A': [0.9, 2.0, 3.0, 6, 180], 'B': [1.1, 2.5, 3.5, 7, 240], 'C': [0.8, 1.8, 2.8, 5.5, 160], 'D': [1.2, 2.8, 4.0, 8, 270], 'E': [1.0, 2.2, 3.2, 6.5, 210]},\n        10: {'A': [1.3, 3.0, 4.0, 9, 300], 'B': [1.5, 3.5, 4.5, 10, 350], 'C': [1.2, 2.8, 3.8, 8, 280], 'D': [1.6, 3.8, 5.0, 11, 380], 'E': [1.4, 3.2, 4.2, 9.5, 330]}\n    }\n):\n    \"\"\"\n    Solves the large-scale, multi-constraint perishable goods\n    transportation problem using Gurobi.\n    \"\"\"\n    # Create a new model\n    model = gp.Model(\"LargeScalePerishableTransport\")\n\n    # --- Decision Variables ---\n    x = model.addVars(data.keys(), variants, vtype=GRB.BINARY, name=\"x\")\n    y = model.addVar(vtype=GRB.BINARY, name=\"SynergyBonus\")\n\n    # --- Objective Function ---\n    base_profit = gp.quicksum(data[c][v][4] * x[c, v] for c in data for v in variants)\n    total_profit = base_profit + (bonus_profit * y)\n    model.setObjective(total_profit, GRB.MAXIMIZE)\n\n    # --- Constraints ---\n    for c in data:\n        model.addConstr(gp.quicksum(x[c, v] for v in variants) == 1, name=f\"SelectOne_{c}\")\n\n    model.addConstr(gp.quicksum(data[c][v][0] * x[c, v] for c in data for v in variants) <= weight_limit, \"WeightLimit\")\n    model.addConstr(gp.quicksum(data[c][v][1] * x[c, v] for c in data for v in variants) <= volume_limit, \"VolumeLimit\")\n    model.addConstr(gp.quicksum(data[c][v][2] * x[c, v] for c in data for v in variants) <= power_limit, \"PowerLimit\")\n    model.addConstr(gp.quicksum(data[c][v][3] * x[c, v] for c in data for v in variants) <= time_limit, \"TimeLimit\")\n\n    model.addConstr(y <= x[1, 'B'], \"SynergyCheck1\")\n    model.addConstr(y <= x[6, 'C'], \"SynergyCheck2\")\n    model.addConstr(y >= x[1, 'B'] + x[6, 'C'] - 1, \"SynergyActivation\")\n\n    model.addConstr(x[5, 'A'] + x[3, 'A'] <= 1, \"ProductConflict\")\n\n    # --- Solve ---\n    model.optimize()\n\n    # --- Return Results ---\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_large_scale_transport_problem()\n    print(result)\n",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Selection",
        "modeling_type": "MILP",
        "industry_sector": "Logistics",
        "reason": "The problem involves selecting exactly one variant from each category to maximize profit, subject to multiple resource constraints and specific product synergy/conflict conditions. The solver uses binary variables and linear constraints, including a product term for the synergy bonus, which is linearized using auxiliary binary variables and Big-M constraints, making it a Mixed-Integer Linear Program."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D000",
    "description": "RapidLink Logistics, a regional delivery company, needs to optimize its daily outbound operations from its main distribution hub. Today, they have 3 delivery trucks of varying capacities and 8 high-priority parcels that must be shipped. The goal is to assign each of the 8 parcels to exactly one of the three trucks to maximize the total revenue for the day.\n\nThe total revenue is composed of two parts: a standard shipping fee for each parcel and a significant synergy bonus that is gained when specific pairs of parcels are placed in the *same* truck. These bonuses arise because certain parcels are headed to the same dense urban block or large corporate campus, allowing for a much more efficient final-mile delivery.\n\nThe capacities of the three available trucks are:\n- Truck 1: 100 kg\n- Truck 2: 120 kg\n- Truck 3: 80 kg\n\nThe details for the 8 high-priority parcels are listed below:\n| Parcel ID | Weight (kg) | Base Revenue ($) |\n| :--- | :--- | :--- |\n| 1 | 35 | 50 |\n| 2 | 45 | 75 |\n| 3 | 25 | 40 |\n| 4 | 50 | 80 |\n| 5 | 30 | 60 |\n| 6 | 40 | 65 |\n| 7 | 20 | 35 |\n| 8 | 55 | 90 |\n\nAdditionally, the logistics team has identified specific pairs of parcels that generate a synergy bonus if shipped in the same truck. These pairings and their associated bonuses are:\n| Parcel Pair | Synergy Bonus ($) | Reason |\n| :--- | :--- | :--- |\n| (1, 3) | 25 | Same residential complex |\n| (2, 5) | 30 | Same industrial park |\n| (2, 6) | 20 | Neighboring corporate offices |\n| (4, 8) | 40 | Both are heavy-lift items for one client |\n| (5, 7) | 22 | Same downtown skyscraper |\n\nThe company must decide which parcels go into which truck, respecting the weight capacity of each truck, to achieve the maximum possible total revenue.",
    "ground_truth": 537.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_logistics_optimization(\n    parcels=[1, 2, 3, 4, 5, 6, 7, 8],\n    trucks=[1, 2, 3],\n    weights={1: 35, 2: 45, 3: 25, 4: 50, 5: 30, 6: 40, 7: 20, 8: 55},\n    base_revenues={\n        1: 50,\n        2: 75,\n        3: 40,\n        4: 80,\n        5: 60,\n        6: 65,\n        7: 35,\n        8: 90\n    },\n    capacities={1: 100, 2: 120, 3: 80},\n    synergy_bonuses={\n        (1, 3): 25,\n        (2, 5): 30,\n        (2, 6): 20,\n        (4, 8): 40,\n        (5, 7): 22\n    }\n):\n    \"\"\"\n    Models and solves the quadratic multiple knapsack problem for RapidLink Logistics\n    \"\"\"\n    # --- 1. Model Creation ---\n    model = gp.Model(\"QuadraticKnapsackLogistics\")\n\n    # --- 2. Decision Variables ---\n    # x[i, j] = 1 if parcel i is assigned to truck j, 0 otherwise.\n    x = model.addVars(parcels, trucks, vtype=GRB.BINARY, name=\"assign\")\n\n    # --- 3. Objective Function ---\n    # The total revenue is the sum of base revenues plus synergy bonuses.\n    synergy_revenue = gp.quicksum(synergy_bonuses[i, k] * x[i, j] * x[k, j]\n                                    for (i, k) in synergy_bonuses\n                                    for j in trucks)\n    sum_base_revenue = gp.quicksum(base_revenues[i] for i in parcels)\n\n    model.setObjective(synergy_revenue + sum_base_revenue, GRB.MAXIMIZE)\n\n    # --- 4. Constraints ---\n\n    # Constraint 1: Each parcel must be assigned to exactly one truck.\n    for i in parcels:\n        model.addConstr(gp.quicksum(x[i, j] for j in trucks) == 1,\n                        name=f\"parcel_assign_{i}\")\n\n    # Constraint 2: The weight in each truck cannot exceed its capacity.\n    for j in trucks:\n        model.addConstr(gp.quicksum(weights[i] * x[i, j] for i in parcels)\n                        <= capacities[j],\n                        name=f\"truck_capacity_{j}\")\n\n    # --- 5. Solve the Model ---\n    model.optimize()\n\n    # --- 6. Return Results ---\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\n# Run the solver function\nif __name__ == \"__main__\":\n    result = solve_logistics_optimization()\n    print(result)\n",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "QP",
        "industry_sector": "Transportation",
        "reason": "The problem involves allocating parcels (resources) to trucks (containers) to maximize revenue, which is a classic resource allocation problem. The objective function contains quadratic terms (x[i,j] * x[k,j]), making it a Quadratic Programming (QP) model. The application is clearly in logistics and delivery, falling under the transportation sector."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D038",
    "description": "HealthSupply Co. manages a medical supply chain that must fulfill demand for two types of products, Vaccine X and Vaccine Y, over the next two quarters, with demands of 100 doses of Vaccine X and 200 doses of Vaccine Y in Quarter 1, and 300 doses of Vaccine X and 100 doses of Vaccine Y in Quarter 2. The company can produce a maximum of 1,500 doses per quarter, with each dose of Vaccine X requiring 4 liters of raw biochemical material and each dose of Vaccine Y requiring 3 liters. The cost of raw material is $300 per liter in Quarter 1 and $450 per liter in Quarter 2, with a maximum purchase limit of 2,500 liters per quarter, and material can only be used in the quarter it is purchased. At the start of Quarter 1, the company has an inventory of 200 doses of Vaccine X and 300 doses of Vaccine Y, and a storage cost of $100 per dose is assessed at the end of each quarter for remaining inventory. Additionally, the company must meet a regulatory requirement that the vaccines produced each quarter have an average efficacy rate of at least 90%, with Vaccine X having an efficacy rate of 85% and Vaccine Y having an efficacy rate of 95%. How to meet the demand and regulatory requirements at minimum cost, including raw material and storage costs.",
    "ground_truth": 460000.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_vaccine_production_optimization(\n    Demand=[[100, 200], [300, 100]],\n    MaxProductionPerQuarter=[1500, 1500],\n    RawMaterialCost=[300, 450],\n    RawMaterialPerProduct=[4, 3],\n    MaxRawMaterialPurchase=[2500, 2500],\n    InitialInventory=[200, 300],\n    StorageCost=[100, 100],\n    EfficacyRate=[0.85, 0.95],\n    RegulatoryEfficacyRate=0.90\n):\n    \"\"\"\n    Models and solves the vaccine production optimization problem.\n    \"\"\"\n    # Create a new model\n    model = gp.Model(\"HealthSupply_Vaccine_Production\")\n\n    # Sets\n    P = range(len(EfficacyRate))  # Products\n    Q = range(len(MaxProductionPerQuarter))  # Quarters\n\n    # Decision Variables\n    RawMaterialPurchased = model.addVars(Q, lb=0.0, name=\"RawMaterialPurchased\")\n    ProductProduced = model.addVars(P, Q, vtype=GRB.INTEGER, lb=0, name=\"ProductProduced\")\n    ProductStorage = model.addVars(P, Q, vtype=GRB.INTEGER, lb=0, name=\"ProductStorage\")\n\n    # Objective Function: Minimize total cost\n    raw_material_cost = gp.quicksum(RawMaterialCost[q] * RawMaterialPurchased[q] for q in Q)\n    storage_cost = gp.quicksum(StorageCost[q] * ProductStorage[p, q] for p in P for q in Q)\n    total_cost = raw_material_cost + storage_cost\n\n    model.setObjective(total_cost, GRB.MINIMIZE)\n\n    # Constraints\n    # 1. Demand constraints\n    for p in P:\n        # First quarter uses initial inventory\n        model.addConstr(\n            ProductProduced[p, 0] + InitialInventory[p] - ProductStorage[p, 0] >= Demand[0][p],\n            f\"Demand_P{p}_Q1\"\n        )\n\n    for p in P:\n        # Second quarter uses storage from first quarter\n        model.addConstr(\n            ProductProduced[p, 1] + ProductStorage[p, 0] - ProductStorage[p, 1] >= Demand[1][p],\n            f\"Demand_P{p}_Q2\"\n        )\n\n    # 2. Production capacity constraints\n    for q in Q:\n        model.addConstr(\n            gp.quicksum(ProductProduced[p, q] for p in P) <= MaxProductionPerQuarter[q],\n            f\"ProductionCapacity_Q{q+1}\"\n        )\n\n    # 3. Raw material constraints\n    for q in Q:\n        model.addConstr(\n            gp.quicksum(RawMaterialPerProduct[p] * ProductProduced[p, q] for p in P) <= RawMaterialPurchased[q],\n            f\"RawMaterial_Q{q+1}\"\n        )\n\n    # 4. Raw material purchase limit constraints\n    for q in Q:\n        model.addConstr(\n            RawMaterialPurchased[q] <= MaxRawMaterialPurchase[q],\n            f\"RawMaterialPurchaseLimit_Q{q+1}\"\n        )\n\n    # 5. Regulatory efficacy constraints\n    for q in Q:\n        total_produced = gp.quicksum(ProductProduced[p, q] for p in P)\n        weighted_efficacy = gp.quicksum(EfficacyRate[p] * ProductProduced[p, q] for p in P)\n\n        model.addConstr(\n            weighted_efficacy >= RegulatoryEfficacyRate * total_produced,\n            f\"RegulatoryEfficacy_Q{q+1}\"\n        )\n\n    # Optimize the model\n    model.optimize()\n\n    # Return Results\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_vaccine_production_optimization()\n    print(result)\n",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Production Planning",
        "modeling_type": "MILP",
        "industry_sector": "Health",
        "reason": "The problem involves determining optimal production and inventory levels for vaccines over multiple quarters to meet demand and regulatory requirements at minimum cost, which is characteristic of production planning. The model uses integer variables for product production and storage, continuous variables for raw material, and linear constraints and objective, making it a Mixed-Integer Linear Program. The context of vaccines and medical supply chain clearly places it in the health sector."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D011",
    "description": "A milk supplier needs to deliver milk to all scheduled customers, with the supplier's warehouse location coordinates being (5, 5), and 5 trucks with a capacity of 25 units of milk can be used for delivery. It is known that there are 20 customer points to be delivered to, with coordinates (5.2, 3.8), (8.7, 4.0), (7.9, 8.8), (1.6, 4.1), (8.3, 2.4), (4.5, 3.3), (3.7, 6.2), (8.9, 5.5), (8.4, 0.3), (0.7, 8.9), (0.3, 7.8), (5.5, 5.7), (2.4, 1.8), (3.5, 6.9), (5.4, 7.8), (2.8, 4.0), (4.9, 1.1), (6.8, 4.3), (9.2, 4.3), (0.1, 8.6), and the milk requirements are 6, 2, 7, 3, 4, 8, 7, 7, 1, 4, 1, 3, 5, 1, 2, 2, 6, 8, 2, 7 units respectively. Every truck departs from the warehouse, delivers milk to customers on the planned route, and returns to the warehouse after delivering to all customers. Under the condition of meeting all customer demands, what is the shortest total driving distance for the trucks? (Assuming that the distance between each point is calculated based on the straight-line distance.)",
    "ground_truth": 51.7829015493,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\nimport math\n\n\ndef solve_vehicle_routing(\n    customer_num=20,\n    truck_num=5,\n    truck_capacity=25,\n    node_coordinates = [\n        (5, 5),  # Warehouse (0)\n        (5.2, 3.8),\n        (8.7, 4.0),\n        (7.9, 8.8),\n        (1.6, 4.1),\n        (8.3, 2.4),\n        (4.5, 3.3),\n        (3.7, 6.2),\n        (8.9, 5.5),\n        (8.4, 0.3),\n        (0.7, 8.9),\n        (0.3, 7.8),\n        (5.5, 5.7),\n        (2.4, 1.8),\n        (3.5, 6.9),\n        (5.4, 7.8),\n        (2.8, 4.0),\n        (4.9, 1.1),\n        (6.8, 4.3),\n        (9.2, 4.3),\n        (0.1, 8.6)\n    ],\n    customer_demand = [6, 2, 7, 3, 4, 8, 7, 7, 1, 4, 1, 3, 5, 1, 2, 2, 6, 8, 2, 7],\n    \n):\n    # --- Model Initialization ---\n    model = gp.Model(\"VehicleRoutingProblem\")\n    \n    # --- Define sets ---\n    warehouse = 0  # Warehouse is node 0\n    customers = range(1, customer_num + 1)  # Customers are 1 to 20\n    nodes = [warehouse] + list(customers)  # All nodes including warehouse\n    trucks = range(1, truck_num + 1)  # Trucks are 1 to 5\n\n    # Calculate distances between nodes\n    distance = {}\n    for i in nodes:\n        for j in nodes:\n            if i != j:  # No self-loops\n                x1, y1 = node_coordinates[i]\n                x2, y2 = node_coordinates[j]\n                distance[i, j] = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)\n\n    # --- Decision Variables ---\n    # x[i,j,k] = 1 if truck k travels from node i to node j, 0 otherwise\n    x = {}\n    for i in nodes:\n        for j in nodes:\n            if i != j:  # No self-loops\n                for k in trucks:\n                    x[i, j, k] = model.addVar(vtype=GRB.BINARY,\n                                            name=f\"x_{i}_{j}_{k}\")\n                    \n    # --- Objective Function ---\n    # minimize total distance traveled\n    objective = gp.quicksum(distance[i, j] * x[i, j, k] for i in nodes\n                            for j in nodes for k in trucks if i != j)\n    model.setObjective(objective, GRB.MINIMIZE)\n\n    # --- Constraints ---\n    # Constraint 1: Each customer must be visited exactly once by exactly one truck\n    for j in customers:\n        model.addConstr(gp.quicksum(x[i, j, k] for i in nodes if i != j\n                                    for k in trucks) == 1,\n                        name=f\"customer_visited_{j}\")\n\n    # Constraint 2: Flow conservation - if a truck enters a customer, it must also leave\n    for i in customers:\n        for k in trucks:\n            model.addConstr(gp.quicksum(x[i, j, k] for j in nodes if j != i) -\n                            gp.quicksum(x[j, i, k] for j in nodes if j != i) == 0,\n                            name=f\"flow_conservation_{i}_{k}\")\n\n    # Constraint 3: Each truck must leave the warehouse exactly once and return to it\n    for k in trucks:\n        model.addConstr(gp.quicksum(x[warehouse, j, k] for j in customers) == 1,\n                        name=f\"truck_{k}_leaves_warehouse\")\n        model.addConstr(gp.quicksum(x[j, warehouse, k] for j in customers) == 1,\n                        name=f\"truck_{k}_returns_warehouse\")\n\n    # Constraint 4: Capacity constraint for each truck\n    for k in trucks:\n        model.addConstr(gp.quicksum(customer_demand[j - 1] *\n                                    gp.quicksum(x[i, j, k]\n                                                for i in nodes if i != j)\n                                    for j in customers) <= truck_capacity,\n                        name=f\"truck_{k}_capacity\")\n\n\n    # Function to find subtours in the current solution\n    def find_subtours(x_vals, k):\n        \"\"\"Find subtours in the current solution for truck k\"\"\"\n        # Create an edge list from the solution\n        edges = [(i, j) for i in customers for j in customers\n                if i != j and x_vals[i, j, k] > 0.5]\n\n        if not edges:\n            return []\n\n        # Create an undirected graph for finding connected components\n        neighbors = {i: [] for i in customers}\n        for i, j in edges:\n            neighbors[i].append(j)\n\n        # Find all connected components (subtours)\n        unvisited = set(customers)\n        subtours = []\n\n        while unvisited:\n            # Start a new tour with an unvisited node\n            curr = next(iter(unvisited))\n            tour = [curr]\n            unvisited.remove(curr)\n\n            # Build the tour\n            while True:\n                neighbors_of_curr = [j for j in neighbors[curr] if j in unvisited]\n                if not neighbors_of_curr:\n                    break\n\n                curr = neighbors_of_curr[0]\n                tour.append(curr)\n                unvisited.remove(curr)\n\n            # Check if it's a subtour (not connected to the warehouse)\n            if any(x_vals[warehouse, i, k] > 0.5\n                for i in tour) and any(x_vals[i, warehouse, k] > 0.5\n                                        for i in tour):\n                # This is a valid tour connected to the warehouse\n                continue\n            elif tour:  # Only add non-empty tours\n                subtours.append(tour)\n\n        return subtours\n\n\n    # Callback function for lazy constraints\n    def subtour_elimination_callback(model, where):\n        if where == GRB.Callback.MIPSOL:\n            # Get the current solution values\n            x_vals = {}\n            for i in nodes:\n                for j in nodes:\n                    if i != j:\n                        for k in trucks:\n                            if (i, j, k) in x:\n                                x_vals[i, j, k] = model.cbGetSolution(x[i, j, k])\n\n            # For each truck, find subtours and add constraints\n            for k in trucks:\n                subtours = find_subtours(x_vals, k)\n                for subtour in subtours:\n                    if len(subtour) < len(\n                            customers):  # Check if it's a proper subtour\n                        # Add DFJ subtour elimination constraint\n                        model.cbLazy(\n                            gp.quicksum(x[i, j, k] for i in subtour\n                                        for j in subtour\n                                        if i != j) <= len(subtour) - 1)\n\n\n    # Enable lazy constraints and store variables for callback\n    model._vars = x\n    model.Params.lazyConstraints = 1\n\n    # --- Solve the Model ---\n    model.optimize(subtour_elimination_callback)\n\n    # --- Return Results ---\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\nif __name__ == \"__main__\":\n    result = solve_vehicle_routing()\n    print(result)\n",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Routing",
        "modeling_type": "MILP",
        "industry_sector": "Logistics",
        "reason": "The problem involves finding the shortest routes for multiple trucks to deliver milk to customers, starting and ending at a warehouse, which is a classic Vehicle Routing Problem. The solver uses binary variables for truck movements and linear constraints, including subtour elimination, making it a Mixed-Integer Linear Program. The application is clearly in the domain of goods delivery and transportation, fitting into the logistics sector."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D009",
    "description": "A logistics company needs to construct a logistics transfer center in a certain area. The company has identified 5 candidate locations for the transfer centers, which will need to deliver goods to 10 subordinate outlets. The distance matrix between the 5 candidate locations and the 10 outlets is as follows:\n\n| Candidate Location \\ Outlet | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |\n|------------------------------|----------|----------|----------|----------|----------|----------|----------|----------|----------|-----------|\n| 1                            | 15       | 22       | 30       | 45       | 50       | 12       | 28       | 35       | 40       | 25        |\n| 2                            | 10       | 18       | 25       | 35       | 40       | 8        | 20       | 28       | 32       | 18        |\n| 3                            | 25       | 30       | 35       | 50       | 55       | 22       | 32       | 40       | 45       | 30        |\n| 4                            | 30       | 35       | 40       | 55       | 60       | 25       | 35       | 45       | 50       | 35        |\n| 5                            | 5        | 12       | 20       | 30       | 35       | 5        | 15       | 22       | 28       | 12        |\n\nIf 2 out of the 5 candidate locations are to be selected to build transfer centers, what is the minimum possible value of the maximum distance from all outlets to their nearest transfer center?",
    "ground_truth": 35.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_p_center(\n    distance=[\n        [15, 22, 30, 45, 50, 12, 28, 35, 40, 25],\n        [10, 18, 25, 35, 40, 8, 20, 28, 32, 18],\n        [25, 30, 35, 50, 55, 22, 32, 40, 45, 30],\n        [30, 35, 40, 55, 60, 25, 35, 45, 50, 35],\n        [5, 12, 20, 30, 35, 5, 15, 22, 28, 12]\n    ],\n    select_location_num=2\n):\n    \"\"\"\n    Models and solves the P-Center facility location problem.\n    \"\"\"\n    # --- 1. Model Creation ---\n    model = gp.Model(\"P-Center-Problem\")\n\n    # --- 2. Sets ---\n    # Derive sets from the dimensions of the input data\n    candidate_locations = range(len(distance))\n    outlets = range(len(distance[0]))\n\n    # --- 3. Decision Variables ---\n    # x[i] = 1 if location i is selected, 0 otherwise\n    x = model.addVars(candidate_locations, vtype=GRB.BINARY, name=\"select_location\")\n\n    # z = auxiliary variable for the min-max objective (maximum distance)\n    z = model.addVar(vtype=GRB.CONTINUOUS, name=\"max_distance\")\n\n    # y[i, j] = 1 if outlet j is assigned to location i, 0 otherwise\n    y = model.addVars(candidate_locations, outlets, vtype=GRB.BINARY, name=\"assign\")\n\n    # --- 4. Objective Function ---\n    # Minimize the maximum distance (z)\n    model.setObjective(z, GRB.MINIMIZE)\n\n    # --- 5. Constraints ---\n    # Constraint 1: Select exactly 'p' (select_location_num) locations\n    model.addConstr(gp.quicksum(x[i] for i in candidate_locations) == select_location_num,\n                    name=\"p_selection\")\n\n    # Constraint 2: Each outlet must be assigned to exactly one location\n    for j in outlets:\n        model.addConstr(gp.quicksum(y[i, j] for i in candidate_locations) == 1,\n                        name=f\"outlet_assignment_{j}\")\n\n    # Constraint 3: An outlet can only be assigned to a selected (opened) location\n    for i in candidate_locations:\n        for j in outlets:\n            model.addConstr(y[i, j] <= x[i], name=f\"valid_assignment_{i}_{j}\")\n\n    # Constraint 4: Define the maximum distance 'z'\n    # If outlet j is assigned to location i (y[i,j]=1), then z must be at least\n    # as large as the distance between them.\n    for i in candidate_locations:\n        for j in outlets:\n            model.addConstr(z >= distance[i][j] * y[i, j],\n                            name=f\"max_distance_link_{i}_{j}\")\n\n    # --- 6. Solve the Model ---\n    model.setParam(\"OutputFlag\", 0)  # Suppress Gurobi output\n    model.optimize()\n\n    # --- 7. Return Results ---\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\n# Run the solver function\nif __name__ == \"__main__\":\n    result = solve_p_center()\n    print(result)\n",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Facility Location",
        "modeling_type": "MILP",
        "industry_sector": "Logistics",
        "reason": "The problem involves selecting a subset of candidate locations for transfer centers to serve outlets, which is a classic Facility Location problem. Specifically, it's a P-Center problem because the objective is to minimize the maximum distance from any outlet to its assigned center. The solver uses binary decision variables for selection and assignment, and continuous variables for the objective, formulated as a Mixed-Integer Linear Program (MILP)."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D024",
    "description": "A publishing company needs to plan the optimal strategy for printing books over the next six months. The company has forecasted the monthly demand as follows: Month 1—5,000 copies; Month 2—6,000 copies; Month 3—5,500 copies; Month 4—7,000 copies; Month 5—4,500 copies; Month 6—4,000 copies. The cost of printing one copy is $2 during regular working hours (RT) and $3 during overtime (OT). Each month, regular-time production is limited to 6,000 copies, and overtime production is limited to 2,000 copies. Additionally, the inventory holding cost is $0.5 per copy per month. What is the minimum total cost to meet the demand for the next six months on time?",
    "ground_truth": 64750.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_production_planning(\n    RegularTimeProductionLimit=6000,\n    OvertimeProductionLimit=2000,\n    RegularTimeCost=2,\n    OvertimeCost=3,\n    InventoryHoldingCost=0.5,\n    Demand=[5000, 6000, 5500, 7000, 4500, 4000]):\n    \"\"\"\n    Solves the production planning optimization problem.\n    \"\"\"\n    # Create a new model\n    model = gp.Model(\"Production Planning\")\n\n    # Parameters\n    MonthNum = len(Demand)\n\n    # Define month set (1-indexed to match the model description)\n    Months = range(1, MonthNum + 1)\n\n    # Decision Variables\n    RegularTimeProduction = model.addVars(Months,\n                                          vtype=GRB.INTEGER,\n                                          name=\"RegularTimeProduction\")\n    OvertimeProduction = model.addVars(Months,\n                                       vtype=GRB.INTEGER,\n                                       name=\"OvertimeProduction\")\n    Inventory = model.addVars(Months, vtype=GRB.INTEGER, name=\"Inventory\")\n\n    # Objective: Minimize total cost\n    objective = gp.quicksum(RegularTimeCost * RegularTimeProduction[m] +\n                            OvertimeCost * OvertimeProduction[m] +\n                            InventoryHoldingCost * Inventory[m] for m in Months)\n    model.setObjective(objective, GRB.MINIMIZE)\n\n    # Constraint 1: Initial inventory constraint\n    model.addConstr(\n        Inventory[1] == RegularTimeProduction[1] + OvertimeProduction[1] -\n        Demand[0], \"InitialInventory\")\n\n    # Constraint 2: Inventory balance constraint for months after the first\n    model.addConstrs(\n        (Inventory[m] == Inventory[m - 1] + RegularTimeProduction[m] +\n         OvertimeProduction[m] - Demand[m - 1]\n         for m in range(2, MonthNum + 1)), \"InventoryBalance\")\n\n    # Constraint 3: Demand constraint\n    # Note: This is redundant given inventory balance and non-negative inventory\n    model.addConstrs(\n        (RegularTimeProduction[m] + OvertimeProduction[m] >= Demand[m - 1]\n         for m in [1]), \"DemandSatisfaction_1\")\n    model.addConstrs(\n        (Inventory[m - 1] + RegularTimeProduction[m] +\n         OvertimeProduction[m] >= Demand[m - 1]\n         for m in range(2, MonthNum + 1)), \"DemandSatisfaction_Rest\")\n\n    # Constraint 4: Regular time production limit constraint\n    model.addConstrs((RegularTimeProduction[m] <= RegularTimeProductionLimit\n                      for m in Months), \"RegularTimeLimit\")\n\n    # Constraint 5: Overtime production limit constraint\n    model.addConstrs((OvertimeProduction[m] <= OvertimeProductionLimit\n                      for m in Months), \"OvertimeLimit\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Return results\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_production_planning()\n    print(result)",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Production Planning",
        "modeling_type": "MILP",
        "industry_sector": "Publishing",
        "reason": "The problem involves determining optimal production levels (regular and overtime) and inventory over multiple periods to meet forecasted demand at minimum cost. The decision variables are integers, and the objective function and constraints are linear, classifying it as a Mixed-Integer Linear Program. The specific context of printing books for a publishing company places it in the publishing sector."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D085",
    "description": "You are in charge of a national health agency planning to establish 2 regional emergency blood centers in a province by selecting from 4 candidate cities. These centers will serve the province's 3 main hospitals. The success probability of blood transportation is known to decrease with the square of the distance, following the formula: p = 1 - 0.00005 * (distance)², where p is the success probability. Regulations require that for each hospital, the joint supply failure probability (i.e., the probability that all designated service channels fail) must be less than 10%. The agency's objective is to select the two locations that minimize the total construction cost while satisfying this reliability constraint. The costs for candidate locations, hospital locations, and distance data are shown in Table 1.\n\nHow should the agency select the two locations for the centers to minimize the total construction cost, subject to the reliability requirement?\n\nTable 1: Blood Center Location Data\n| Candidate City | Construction Cost (¥M) | Distance to H1 (km) | Distance to H2 (km) | Distance to H3 (km) |\n|:---:|:---:|:---:|:---:|:---:|\n| C1 | 8 | 50 | 80 | 120 |\n| C2 | 7 | 60 | 40 | 90 |\n| C3 | 9 | 110 | 70 | 50 |\n| C4 | 7.5 | 130 | 100 | 60 |",
    "ground_truth": 17.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\ndef solve_blood_center_location(\n    candidate_cities=[1, 2, 3, 4],\n    hospitals=[1, 2, 3],\n    construction_cost={1: 8, 2: 7, 3: 9, 4: 7.5},\n    distances_matrix=[[50, 80, 120], [60, 40, 90], [110, 70, 50], [130, 100, 60]],\n    num_to_select=2,\n    max_joint_failure_prob=0.1,\n    prob_coeff=0.00005\n):\n    \"\"\"\n    Solve the blood center location problem using Gurobi.\n    The model aims to minimize construction cost while satisfying the number of centers and supply reliability constraints.\n    \"\"\"\n    # Create a new model\n    model = gp.Model(\"BloodCenterLocation\")\n\n    # Convert distance data to a dictionary for easy access\n    distances = {(c, h): distances_matrix[c-1][h-1]\n                 for c in candidate_cities for h in hospitals}\n\n    # --- Decision Variables ---\n    # 1 if a center is built in city c, 0 otherwise\n    select_city = model.addVars(candidate_cities, vtype=GRB.BINARY, name=\"SelectCity\")\n    \n    # Auxiliary variable for joint failure probability for each hospital\n    joint_failure_prob = model.addVars(hospitals, vtype=GRB.CONTINUOUS, \n                                       lb=0, ub=1, name=\"JointFailureProb\")\n\n    # --- Objective Function: Minimize Total Construction Cost ---\n    total_construction_cost = gp.quicksum(construction_cost[c] * select_city[c]\n                                          for c in candidate_cities)\n    model.setObjective(total_construction_cost, GRB.MINIMIZE)\n\n    # --- Constraints ---\n\n    # 1. The total number of centers built must equal the specified number\n    model.addConstr(select_city.sum('*') == num_to_select, name=\"TotalCentersConstraint\")\n\n    # 2. Supply reliability constraint for each hospital (nonlinear constraint)\n    for h in hospitals:\n        # Expression for joint failure probability\n        joint_failure_prob_expr = 1\n        for c in candidate_cities:\n            fail_prob_ch = prob_coeff * (distances[c, h] ** 2)\n            term = (1 - select_city[c]) + select_city[c] * fail_prob_ch\n            joint_failure_prob_expr *= term\n        \n        # Use equality constraint to define auxiliary variable\n        model.addConstr(joint_failure_prob[h] == joint_failure_prob_expr,\n                        name=f\"JointFailureProb_Hospital_{h}\")\n        \n        # Add linear constraint for reliability requirement\n        model.addConstr(joint_failure_prob[h] <= max_joint_failure_prob,\n                        name=f\"Reliability_Hospital_{h}\")\n\n    # --- Solve ---\n    # Gurobi needs to know the model is non-convex\n    model.params.NonConvex = 2\n    model.optimize()\n\n    # --- Return Results ---\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.objVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\n# Run the solver function\nif __name__ == '__main__':\n    result = solve_blood_center_location()\n    print(result)",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Facility Location",
        "modeling_type": "MINLP",
        "industry_sector": "Health",
        "reason": "The problem involves selecting optimal locations for blood centers from a set of candidates, which is a classic Facility Location problem. The model uses binary variables for location selection and continuous variables for probabilities, with a non-linear objective function (implied by the joint failure probability calculation involving products of terms with binary variables) and constraints, making it a Mixed-Integer Non-Linear Program (MINLP). The application is clearly within the Health sector, specifically for emergency blood services."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D005",
    "description": "A company has three warehouses storing three products with inventory: Warehouse 1 (600, 900, 750), Warehouse 2 (500, 1500, 1200), Warehouse 3 (800, 1100, 100). These products must be shipped to seven sales locations with demands: Location 1 (200, 400, 300), Location 2 (300, 800, 50), Location 3 (200, 300, 50), Location 4 (75, 250, 80), Location 5 (600, 700, 200), Location 6 (225, 850, 100), Location 7 (300, 200, 200). Transportation costs vary by product, warehouse, and destination: For Warehouse 1, the costs per unit are Product 1: 30, 10, 8, 10, 11, 71, 6 for Locations 1–7; Product 2: 39, 14, 11, 14, 16, 82, 8 for Locations 1–7; and Product 3: 41, 15, 12, 16, 17, 86, 8 for Locations 1–7. For Warehouse 2, the costs per unit are Product 1: 22, 7, 10, 7, 21, 82, 13 for Locations 1–7; Product 2: 27, 9, 12, 9, 26, 95, 17 for Locations 1–7; and Product 3: 29, 9, 13, 9, 28, 99, 18 for Locations 1–7. For Warehouse 3, the costs per unit are Product 1: 19, 11, 12, 10, 25, 83, 15 for Locations 1–7; Product 2: 24, 14, 17, 13, 28, 99, 20 for Locations 1–7; and Product 3: 26, 14, 17, 13, 31, 104, 20 for Locations 1–7. And shipments from any warehouse to any location cannot exceed 625 units. How to allocate shipments to minimize total transportation cost?",
    "ground_truth": 181320.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_multi_product_transportation(\n    warehouse_storage=[\n        [600, 900, 750],\n        [500, 1500, 1200],\n        [800, 1100, 100]\n    ],\n    location_demand=[\n        [200, 400, 300],\n        [300, 800, 50],\n        [200, 300, 50],\n        [75, 250, 80],\n        [600, 700, 200],\n        [225, 850, 100],\n        [300, 200, 200]\n    ],\n    transportation_cost=[\n        [[30, 39, 41], [10, 14, 15], [8, 11, 12], [10, 14, 16], [11, 16, 17], [71, 82, 86], [6, 8, 8]],\n        [[22, 27, 29], [7, 9, 9], [10, 12, 13], [7, 9, 9], [21, 26, 28], [82, 95, 99], [13, 17, 18]],\n        [[19, 24, 26], [11, 14, 14], [12, 17, 17], [10, 13, 13], [25, 28, 31], [83, 99, 104], [15, 20, 20]]\n    ],\n    max_one_shipment=625\n):\n    \"\"\"\n    Models and solves the multi-product transportation problem.\n    \"\"\"\n    # --- 1. Model Creation ---\n    model = gp.Model(\"WarehouseTransportation\")\n\n    # --- 2. Sets ---\n    # Derive sets from the dimensions of the input data\n    warehouses = range(len(warehouse_storage))\n    locations = range(len(location_demand))\n    products = range(len(warehouse_storage[0]))\n\n    # --- 3. Decision Variables ---\n    # t[i, j, p] = amount of product p transported from warehouse i to location j\n    t = model.addVars(warehouses, locations, products, vtype=GRB.INTEGER, lb=0, name=\"transport\")\n\n    # --- 4. Objective Function ---\n    # Minimize total transportation cost\n    objective = gp.quicksum(transportation_cost[i][j][p] * t[i, j, p]\n                           for i in warehouses\n                           for j in locations\n                           for p in products)\n    model.setObjective(objective, GRB.MINIMIZE)\n\n    # --- 5. Constraints ---\n    # Constraint 1: Warehouse storage capacity\n    for i in warehouses:\n        for p in products:\n            model.addConstr(gp.quicksum(t[i, j, p] for j in locations) <= warehouse_storage[i][p],\n                           name=f\"warehouse_capacity_{i+1}_{p+1}\")\n\n    # Constraint 2: Sales location demand must be met\n    for j in locations:\n        for p in products:\n            model.addConstr(gp.quicksum(t[i, j, p] for i in warehouses) == location_demand[j][p],\n                           name=f\"location_demand_{j+1}_{p+1}\")\n\n    # Constraint 3: Shipment limit for each warehouse-location pair\n    for i in warehouses:\n        for j in locations:\n            model.addConstr(gp.quicksum(t[i, j, p] for p in products) <= max_one_shipment,\n                           name=f\"shipment_limit_{i+1}_{j+1}\")\n\n    # --- 6. Solve the Model ---\n    model.setParam(\"OutputFlag\", 0)  # Suppress Gurobi output\n    model.optimize()\n\n    # --- 7. Return Results ---\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        # Return the Gurobi status code if no optimal solution is found\n        return {\"status\": f\"{model.status}\"}\n\n\n# Run the solver function\nif __name__ == \"__main__\":\n    result = solve_multi_product_transportation()\n    print(result)",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Transportation",
        "modeling_type": "MILP",
        "industry_sector": "Logistics",
        "reason": "The problem involves allocating products from warehouses to sales locations to minimize transportation costs, which is a classic transportation problem. The decision variables are integers (amount of product shipped), and the objective and constraints are linear, making it a Mixed-Integer Linear Program. The application directly relates to the movement and storage of goods, fitting within the logistics sector."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D019",
    "description": "A delivery company has a fleet of vehicles at a certain location, consisting of 3 trucks. Each truck has a load limit of 1 ton (i.e., 1000 kg) and a speed of 30 km/h. The delivery fleet needs to provide pickup and delivery services for a group of customers. Each order has independent time windows for the pickup point and the delivery point. Below are the detailed customer order details:\n\n| Order ID | Pickup Point (x, y) | Pickup Time Window | Delivery Point (x, y) | Delivery Time Window | Delivery Weight (kg) |\n|----------|---------------------|---------------|---------------------|---------------|-------------------|\n| 1        | (1.41, 2.64)        | [9:30, 10:00] | (8.56, 1.11)        | [9:40, 10:40] | 198               |\n| 2        | (6.34, -4.45)       | [12:00, 12:30]| (3.63, -7.65)       | [12:10, 13:10]| 252               |\n| 3        | (3.04, 7.82)        | [10:30, 11:00]| (-8.88, 9.6)        | [10:50, 11:50]| 94                |\n| 4        | (8.18, -6.27)       | [12:00, 12:30]| (-4.31, -5.73)      | [12:20, 12:20]| 223               |\n| 5        | (3.03, 2.34)        | [12:30, 13:00]| (7.93, 5.0)         | [12:40, 13:40]| 163               |\n| 6        | (0.07, 9.32)        | [8:30, 9: 00] | (-7.54, -3.57)      | [9:00, 10:00] | 247               |\n| 7        | (0.57, -1.09)       | [8:00, 8:30]  | (-5.15, -4.55)      | [8:10, 9:10]  | 133               |\n| 8        | (8.87, 2.71)        | [14:00, 14:30]| (-9.87, 0.49)       | [14:30, 15:30]| 188               |\n| 9        | (-3.97, -3.81)      | [10:00, 10:30]| (-3.91, -2.12)      | [10:00, 11:00]| 216               |\n| 10       | (-0.08, -8.95)      | [9:30, 10:00] | (-6.29, -7.8)       | [9:40, 10:40] | 225               |\n\nThe delivery fleet departs from the depot at coordinates (0, 0), serves all orders, and then returns to the depot. How should the routes be planned to minimize the total distance traveled by the trucks? (Distances are calculated as straight-line distances.)",
    "ground_truth": 172.4960492825,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\nimport math\n\n\ndef solve_PickupDeliveryVRP(\n    order_num=10,\n    truck_num=3,\n    speed=30,\n    maxload=1000,\n    M=1e5,\n    coordinates = [(0, 0), (1.41, 2.64), (6.34, -4.45), (3.04, 7.82),\n                (8.18, -6.27), (3.03, 2.34), (0.07, 9.32), (0.57, -1.09),\n                (8.87, 2.71), (-3.97, -3.81), (-0.08, -8.95), (8.56, 1.11),\n                (3.63, -7.65), (-8.88, 9.6), (-4.31, -5.73), (7.93, 5.0),\n                (-7.54, -3.57), (-5.15, -4.55), (-9.87, 0.49), (-3.91, -2.12),\n                (-6.29, -7.8)],\n    demands = [\n        0, 198, 252, 94, 223, 163, 247, 133, 188, 216, 225, -198, -252, -94, -223,\n        -163, -247, -133, -188, -216, -225\n    ],\n    time_windows = [(0, 1440), (570, 600), (720, 750), (630, 660), (720, 750),\n                    (750, 780), (510, 540), (480, 510), (840, 870), (600, 630),\n                    (570, 600), (580, 640), (730, 760), (650, 680), (720, 750),\n                    (780, 810), (540, 570), (490, 520), (870, 900), (630, 660),\n                    (580, 610)]\n):\n    # --- Model Initialization ---\n    model = gp.Model(\"PickupDeliveryVRP\")\n\n    # Define sets\n    nodes = range(order_num * 2 + 1)  # 0 is depot, 1-10 are pickup, 11-20 are delivery\n    pickup_nodes = range(1, order_num + 1)\n    trucks = range(truck_num)\n\n    # Calculate distance matrix\n    def calculate_distance(coord1, coord2):\n        return math.sqrt((coord1[0] - coord2[0])**2 + (coord1[1] - coord2[1])**2)\n\n\n    distance = {}\n    for i in nodes:\n        for j in nodes:\n            if i != j:\n                distance[i, j] = calculate_distance(coordinates[i], coordinates[j])\n\n    # --- Decision variables ---\n    # x[i,j,k] = 1 if truck k travels from i to j\n    x = {}\n    for i in nodes:\n        for j in nodes:\n            if i != j:\n                for k in trucks:\n                    x[i, j, k] = model.addVar(vtype=GRB.BINARY,\n                                            name=f'x_{i}_{j}_{k}')\n\n    # t_a[i] = arrival time at node i\n    t_a = {}\n    for i in nodes:\n        t_a[i] = model.addVar(lb=time_windows[i][0],\n                            ub=time_windows[i][1],\n                            name=f't_a_{i}')\n\n    # t_d[i] = departure time from node i\n    t_d = {}\n    for i in nodes:\n        t_d[i] = model.addVar(lb=time_windows[i][0],\n                            ub=time_windows[i][1],\n                            name=f't_d_{i}')\n\n    # load[i,k] = load of truck k when departing from node i\n    load = {}\n    for i in nodes:\n        for k in trucks:\n            load[i, k] = model.addVar(lb=0, ub=maxload, name=f'load_{i}_{k}')\n\n    # --- Objective function ---\n    # minimize total distance\n    objective = gp.quicksum(distance[i, j] * x[i, j, k] for i in nodes\n                            for j in nodes for k in trucks if i != j)\n    model.setObjective(objective, GRB.MINIMIZE)\n\n    # --- Constraints ---\n    # Constraint 1: Each pickup & delivery point must be visited exactly once by one truck\n    for j in nodes:\n        if j != 0:  # Skip depot\n            model.addConstr(gp.quicksum(x[i, j, k] for i in nodes for k in trucks\n                                        if i != j) == 1,\n                            name=f'visit_to_{j}')\n\n    # Constraint 2: One order's pickup and delivery points must be visited by the same truck\n    for i in pickup_nodes:\n        for k in trucks:\n            model.addConstr(gp.quicksum(x[i, j, k] for j in nodes\n                                        if j != i) == gp.quicksum(\n                                            x[i + order_num, j, k] for j in nodes\n                                            if j != i + order_num),\n                            name=f'same_truck_{i}_{k}')\n\n    # Constraint 3: Flow conservation for each point\n    for i in nodes:\n        for k in trucks:\n            model.addConstr(gp.quicksum(x[i, j, k] for j in nodes\n                                        if j != i) == gp.quicksum(x[j, i, k]\n                                                                for j in nodes\n                                                                if j != i),\n                            name=f'flow_cons_{i}_{k}')\n\n    # Constraint 4: Each truck must leave the depot once\n    for k in trucks:\n        model.addConstr(gp.quicksum(x[0, j, k] for j in nodes if j != 0) == 1,\n                        name=f'truck_{k}_leaves_depot')\n\n    # Constraint 5: The order's pickup point must be visited before its delivery point\n    for i in pickup_nodes:\n        model.addConstr(t_a[i] <= t_d[i + order_num],\n                        name=f'pickup_before_delivery_{i}')\n\n    # Constraints 6 & 7: Time window constraints (already handled by variable bounds)\n\n    # Constraint 8: Time consistency constraints\n    for i in nodes:\n        for j in nodes:\n            if i != j:\n                for k in trucks:\n                    # If truck k goes from i to j, arrival time at j must be after departure from i plus travel time\n                    model.addConstr(t_d[i] + 60 * distance[i, j] / speed - M *\n                                    (1 - x[i, j, k]) <= t_a[j],\n                                    name=f'time_cons_{i}_{j}_{k}')\n\n    # Constraint 9: The truck's load must not exceed its maximum load (handled by variable bounds)\n\n    # Constraint 10: The truck's load must be updated at every visited point\n    for i in nodes:\n        for j in nodes:\n            if i != j:\n                for k in trucks:\n                    model.addConstr(load[j, k] >= load[i, k] + demands[j] - M *\n                                    (1 - x[i, j, k]),\n                                    name=f'load_update_lb_{i}_{j}_{k}')\n                    model.addConstr(load[j, k] <= load[i, k] + demands[j] + M *\n                                    (1 - x[i, j, k]),\n                                    name=f'load_update_ub_{i}_{j}_{k}')\n\n    # Constraint 11: The truck's load must be initialized at the depot\n    for k in trucks:\n        model.addConstr(load[0, k] == 0, name=f'initial_load_{k}')\n\n\n    # Constraint 12: Eliminate sub-tours (using lazy constraints approach)\n    def find_subtours(edges):\n        # Create adjacency list\n        adj = {i: [] for i in nodes}\n        for i, j in edges:\n            adj[i].append(j)\n\n        # Find all subtours\n        unvisited = set(nodes)\n        subtours = []\n        while unvisited:\n            current = next(iter(unvisited))\n            subtour = []\n            while current in unvisited:\n                unvisited.remove(current)\n                subtour.append(current)\n                next_nodes = adj.get(current, [])\n                if not next_nodes:\n                    break\n                current = next_nodes[0]\n            if len(subtour) < len(nodes):\n                subtours.append(subtour)\n        return subtours\n\n\n    def subtour_cb(model, where):\n        if where == GRB.Callback.MIPSOL:\n            # Get values of binary variables\n            x_vals = model.cbGetSolution(model._vars)\n            for k in trucks:\n                edges = [\n                    (i, j) for i in nodes for j in nodes\n                    if i != j and (i, j, k) in x_vals and x_vals[i, j, k] > 0.5\n                ]\n\n                subtours = find_subtours(edges)\n\n                # Add subtour elimination constraints\n                for S in subtours:\n                    if len(S) < len(\n                            nodes\n                    ) and 0 not in S:  # Exclude depot from subtour check\n                        model.cbLazy(\n                            gp.quicksum(x[i, j, k] for i in S for j in S\n                                        if i != j) <= len(S) - 1)\n\n\n    # Enable lazy constraints\n    model._vars = x\n    model.Params.lazyConstraints = 1\n\n    # Set a time limit (optional)\n    model.Params.timeLimit = 3600  # 1 hour\n\n    # Optimize model with callback\n    model.optimize(subtour_cb)\n\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.objVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_PickupDeliveryVRP()\n    print(result)",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Routing",
        "modeling_type": "MILP",
        "industry_sector": "Transportation",
        "reason": "The problem involves planning routes for a fleet of vehicles to serve pickup and delivery orders, which is a classic Vehicle Routing Problem (VRP). The solver program uses binary variables for routing decisions and continuous variables for time and load, along with linear constraints, making it a Mixed-Integer Linear Program (MILP). The application is clearly in the context of a delivery company, falling under the transportation sector."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D081",
    "description": "A container shipping company needs to execute a transport contract from Shanghai to Los Angeles, a total sailing distance of 6000 nautical miles. The voyage must be completed within 12 days (288 hours). The company can choose one of three different types of vessels from its fleet to carry out this mission. The fuel consumption rate for each vessel is an approximate quadratic function of its sailing speed v. The price of fuel is ¥4000 per ton. Additionally, due to new environmental regulations, the company must pay for its carbon dioxide emissions at a rate of ¥300 per ton of CO2. Specific information for the three vessels is shown in Table 1, including their fuel consumption formulas, CO2 emission factors, and a fixed cost for selecting each vessel.\n\nTable 1: Vessel Information \n\n| Vessel | Fuel Consumption (tons/hour) | CO2 Emission Factor (ton CO2/ton fuel) | Selection Fixed Cost (¥) |\n|------|----------------------------------|------|---------|\n| Ship A | $0.005 \\times v^2 + 0.1v + 1.2$  | 3.2  | 500,000 |\n| Ship B | $0.004 \\times v^2 + 0.08v + 1.5$ | 3.15 | 600,000 |\n| Ship C | $0.006 \\times v^2 + 0.12v + 1.0$ | 3.25 | 450,000 |\n\nThe objective is to select one vessel and determine its optimal sailing speed to minimize the total cost of the voyage.",
    "ground_truth": 7582340.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_shipping_minlp_robust(\n    vessels=[\"Ship_A\", \"Ship_B\", \"Ship_C\"],\n    distance=6000.0,\n    max_time=288.0,\n    fuel_price=4000.0,\n    carbon_tax=300.0,\n    max_speed=30.0,\n    fixed_cost={\n        \"Ship_A\": 500000,\n        \"Ship_B\": 600000,\n        \"Ship_C\": 450000\n    },\n    co2_factor={\n        \"Ship_A\": 3.2,\n        \"Ship_B\": 3.15,\n        \"Ship_C\": 3.25\n    },\n    fuel_coeffs={\n        \"Ship_A\": {\"a\": 0.005, \"b\": 0.1, \"c\": 1.2},\n        \"Ship_B\": {\"a\": 0.004, \"b\": 0.08, \"c\": 1.5},\n        \"Ship_C\": {\"a\": 0.006, \"b\": 0.12, \"c\": 1.0}\n    }\n):\n    \"\"\"\n    Solves the vessel selection and speed optimization problem using a robust\n    MIQCP (Mixed-Integer Quadratically Constrained Programming) formulation.\n    \"\"\"\n    # Create a new model\n    model = gp.Model(\"ShippingOptimization_Robust\")\n\n    # --- Decision Variables ---\n    # 1. Binary variable to select exactly one vessel\n    select_vessel = model.addVars(vessels, vtype=GRB.BINARY, name=\"SelectVessel\")\n\n    # 2. Continuous variable for the speed of EACH vessel\n    speed_per_vessel = model.addVars(vessels, lb=0.0, ub=max_speed, name=\"Speed\")\n\n    # 3. Auxiliary variable z_s = y_s / v_s\n    aux_z = model.addVars(vessels, lb=0.0, name=\"Aux_Z\")\n\n    # --- Constraints ---\n    # 1. Vessel Selection Constraint: Exactly one vessel must be chosen\n    model.addConstr(select_vessel.sum('*') == 1, name=\"OneVesselMustBeSelected\")\n\n    # 2. Link speed to vessel selection\n    min_speed = distance / max_time\n    for s in vessels:\n        # The speed v_s must be >= min_speed if vessel s is selected (y_s=1)\n        model.addConstr(speed_per_vessel[s] >= min_speed * select_vessel[s], name=f\"MinSpeed_{s}\")\n        # The speed v_s must be <= max_speed if vessel s is selected (y_s=1)\n        model.addConstr(speed_per_vessel[s] <= max_speed * select_vessel[s], name=f\"MaxSpeed_{s}\")\n\n        # 3. Core non-convex quadratic constraint: z_s * v_s = y_s\n        model.addQConstr(aux_z[s] * speed_per_vessel[s] == select_vessel[s], name=f\"AuxConstraint_{s}\")\n\n    # --- Objective Function: Minimize Total Cost ---\n    # Total Fixed Cost\n    total_fixed_cost = select_vessel.prod(fixed_cost)\n\n    # Total Variable Cost (Fuel + Carbon)\n    # The original variable cost per ship was C_var * D * (a*v + b + c/v)\n    # With our auxiliary variables, this becomes:\n    # C_var * D * (a*v_s + b*y_s + c*z_s)\n    total_variable_cost = gp.quicksum(\n        (fuel_price + carbon_tax * co2_factor[s]) * distance * (\n            fuel_coeffs[s]['a'] * speed_per_vessel[s] +\n            fuel_coeffs[s]['b'] * select_vessel[s] +\n            fuel_coeffs[s]['c'] * aux_z[s]\n        ) for s in vessels\n    )\n\n    model.setObjective(total_fixed_cost + total_variable_cost, GRB.MINIMIZE)\n\n    # --- Gurobi Settings for Non-Convex Problems ---\n    model.Params.NonConvex = 2\n\n    # Optimize the model\n    model.optimize()\n\n    # --- Return Results ---\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.objVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\n# Run the solver function\nif __name__ == '__main__':\n    result = solve_shipping_minlp_robust()\n    print(result)",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Vessel Selection and Speed Optimization",
        "modeling_type": "MINLP",
        "industry_sector": "Transportation",
        "reason": "The problem involves selecting one vessel from a fleet and optimizing its speed to minimize cost, which falls under vessel selection and speed optimization in the transportation sector. The solver uses binary variables for selection and continuous variables for speed, with quadratic fuel consumption functions, leading to a Mixed-Integer Non-Linear Programming (MINLP) formulation, specifically handled as MIQCP by Gurobi's NonConvex=2 parameter."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D048",
    "description": "LogiTech’s main distribution center is organized into two key areas: a packaging area located at coordinates (0, 0) and a loading dock located at coordinates (800, 600) (distances are in meters). The company must determine where to locate a sorting facility and a storage facility to minimize the daily cost of moving goods through the center. All movement within the distribution center is restricted to either east–west or north–south directions.  \n\nThe number of daily trips between the areas are as follows:  \n\n| From/To          | Packaging Area | Loading Dock | Sorting Facility | Storage Facility |  \n|-------------------|----------------|--------------|-------------------|------------------|  \n| Packaging Area    | -              | 20           | 15                | 10               |  \n| Loading Dock      | 20             | -            | 25                | 30               |  \n| Sorting Facility  | 15             | 25           | -                 | 40               |  \n| Storage Facility  | 10             | 30           | 40                | -                |  \n\nThe cost of moving goods is $0.50 per meter per trip. The sorting facility and storage facility must be located within the boundaries of the distribution center, which spans from (0, 0) to (1000, 1000). And any two areas among the four areas are at least 100 units apart.\n\nHow should LogiTech locate the sorting and storage facilities to minimize daily transportation costs?",
    "ground_truth": 70000.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_logistics_optimization(\n    distance_packaging_loading=1400.0,\n    daily_trips=[\n        [0, 20, 15, 10],\n        [20, 0, 25, 30],\n        [15, 25, 0, 40],\n        [10, 30, 40, 0]\n    ],\n    cost_per_meter_per_trip=0.50,\n    minimal_distance=100.0\n):\n    \"\"\"\n    Solves the logistics optimization problem.\n    \"\"\"\n    try:\n        # --- Create a new model ---\n        model = gp.Model(\"LogisticsOptimization\")\n\n        # --- Decision Variables ---\n        d_S_St = model.addVar(lb=minimal_distance, name=\"DistanceBetweenSortingAndStorage\")\n        d_S_Pk = model.addVar(lb=minimal_distance, name=\"DistanceBetweenSortingAndPackaging\")\n        d_S_L = model.addVar(lb=minimal_distance, name=\"DistanceBetweenSortingAndLoading\")\n        d_St_Pk = model.addVar(lb=minimal_distance, name=\"DistanceBetweenStorageAndPackaging\")\n        d_St_L = model.addVar(lb=minimal_distance, name=\"DistanceBetweenStorageAndLoading\")\n\n        # --- Objective Function ---\n        cost_Pk_L = (daily_trips[0][1] + daily_trips[1][0]) * distance_packaging_loading\n        cost_Pk_S = (daily_trips[0][2] + daily_trips[2][0]) * d_S_Pk\n        cost_Pk_St = (daily_trips[0][3] + daily_trips[3][0]) * d_St_Pk\n        cost_L_S = (daily_trips[1][2] + daily_trips[2][1]) * d_S_L\n        cost_L_St = (daily_trips[1][3] + daily_trips[3][1]) * d_St_L\n        cost_S_St = (daily_trips[2][3] + daily_trips[3][2]) * d_S_St\n        total_transport_cost_before_factor = cost_Pk_L + cost_Pk_S + cost_Pk_St + cost_L_S + cost_L_St + cost_S_St\n        model.setObjective(total_transport_cost_before_factor * cost_per_meter_per_trip, GRB.MINIMIZE)\n\n        # --- Constraints ---\n        model.addConstr(d_S_L + d_S_Pk == distance_packaging_loading, \"Collinearity_Sorting\")\n        model.addConstr(d_St_Pk + d_St_L == distance_packaging_loading, \"Collinearity_Storage\")\n        model.addConstr(d_S_St <= distance_packaging_loading, \"MaxDist_SortingStorage\")\n\n        # --- Optimize model ---\n        model.optimize()\n\n        # --- Return solution ---\n        if model.status == GRB.OPTIMAL:\n            return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n        else:\n            return {\"status\": f\"{model.status}\"}\n\n    except gp.GurobiError as e:\n        return {\"status\": f\"Gurobi error: {e}\"}\n    except Exception as e:\n        return {\"status\": f\"An unexpected error occurred: {e}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_logistics_optimization()\n    print(result)\n",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Facility Location",
        "modeling_type": "LP",
        "industry_sector": "Logistics",
        "reason": "The problem aims to determine the optimal locations for new facilities (sorting and storage) to minimize transportation costs within a distribution center. The solver program uses linear equations and inequalities to model the objective function and constraints, making it a Linear Program."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D049",
    "description": "A delivery company is using a drone to make a series of urgent deliveries to 6 specific customer locations (C1 to C6) within a dense urban area. The drone must start from its depot, visit each of the 6 customer locations exactly once to drop off a package, and then return to the depot. The company has calculated the flight time (in minutes) between all pairs of locations (depot and customer sites), considering air-traffic restrictions and optimal flight paths.\n\nFlight Time Matrix (Minutes - Symmetric):\n\n|        | Depot | C1    | C2    | C3    | C4    | C5    | C6    |\n| :----- | :---- | :---- | :---- | :---- | :---- | :---- | :---- |\n| Depot  | -     | 8     | 12    | 15    | 7     | 10    | 14    |\n|   C1   | 8     | -     | 5     | 11    | 6     | 9     | 13    |\n|   C2   | 12    | 5     | -     | 7     | 10    | 4     | 8     |\n|   C3   | 15    | 11    | 7     | -     | 9     | 6     | 5     |\n|   C4   | 7     | 6     | 10    | 9     | -     | 3     | 11    |\n|   C5   | 10    | 9     | 4     | 6     | 3     | -     | 7     |\n|   C6   | 14    | 13    | 8     | 5     | 11    | 7     | -     |",
    "ground_truth": 42.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_drone_tsp(\n    flight_times_input=[\n        [0, 8, 12, 15, 7, 10, 14],\n        [8, 0, 5, 11, 6, 9, 13],\n        [12, 5, 0, 7, 10, 4, 8],\n        [15, 11, 7, 0, 9, 6, 5],\n        [7, 6, 10, 9, 0, 3, 11],\n        [10, 9, 4, 6, 3, 0, 7],\n        [14, 13, 8, 5, 11, 7, 0]\n    ]\n):\n    \"\"\"\n    Solves the Drone Traveling Salesperson Problem (TSP).\n    \"\"\"\n    try:\n        # --- Parameters ---\n        customer_locations_set = {\"C1\", \"C2\", \"C3\", \"C4\", \"C5\", \"C6\"}\n        depot_name = \"Depot\"\n        location_names = [depot_name] + sorted(list(customer_locations_set))\n        num_total_locations = len(location_names)\n        depot_index = 0\n        customer_indices = list(range(1, num_total_locations))\n\n        flight_time_matrix = {\n            (i, j): flight_times_input[i][j]\n            for i in range(num_total_locations)\n            for j in range(num_total_locations)\n        }\n\n        # --- Create a new model ---\n        model = gp.Model(\"DroneTSP\")\n\n        # --- Decision Variables ---\n        arcs = [(i, j) for i in range(num_total_locations) for j in range(num_total_locations) if i != j]\n        x = model.addVars(arcs, vtype=GRB.BINARY, name=\"Route\")\n\n        # --- Objective Function ---\n        model.setObjective(gp.quicksum(flight_time_matrix[i, j] * x[i, j] for i, j in arcs), GRB.MINIMIZE)\n\n        # --- Constraints ---\n        model.addConstr(gp.quicksum(x[depot_index, j] for j in customer_indices) == 1, \"LeaveDepot\")\n        model.addConstr(gp.quicksum(x[i, depot_index] for i in customer_indices) == 1, \"ReturnToDepot\")\n\n        for j in customer_indices:\n            model.addConstr(gp.quicksum(x[i, j] for i in range(num_total_locations) if i != j) == 1, f\"EnterCustomer_{j}\")\n\n        for i in customer_indices:\n            model.addConstr(gp.quicksum(x[i, j] for j in range(num_total_locations) if i != j) == 1, f\"LeaveCustomer_{i}\")\n\n        num_customers = len(customer_indices)\n        u = model.addVars(customer_indices, lb=1.0, ub=float(num_customers), vtype=GRB.CONTINUOUS, name=\"u\")\n\n        for i in customer_indices:\n            for j in customer_indices:\n                if i != j:\n                    model.addConstr(u[i] - u[j] + num_customers * x[i, j] <= num_customers - 1, f\"MTZ_{i}_{j}\")\n\n        # --- Optimize model ---\n        model.optimize()\n\n        # --- Return solution ---\n        if model.status == GRB.OPTIMAL:\n            return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n        else:\n            return {\"status\": f\"{model.status}\"}\n\n    except gp.GurobiError as e:\n        return {\"status\": f\"Gurobi error: {e}\"}\n    except Exception as e:\n        return {\"status\": f\"An unexpected error occurred: {e}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_drone_tsp()\n    print(result)\n",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Routing",
        "modeling_type": "MILP",
        "industry_sector": "Transportation",
        "reason": "The problem involves finding the shortest route for a drone to visit multiple locations and return to the depot, which is a classic Traveling Salesperson Problem (TSP), a type of routing problem. The solver uses binary decision variables for arc selection and continuous variables for subtour elimination, formulated as a Mixed-Integer Linear Program (MILP). The application is clearly in the context of package delivery by a drone, falling under the transportation sector."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D036",
    "description": "LogiCorp operates a logistics network that ships two types of products: Basic and Advanced. The raw materials needed to produce these products can be purchased for $5 per unit. Processing 1 unit of raw material requires 2 hours of warehouse labor. Each unit of processed raw material yields 2 units of Basic Product and 3 units of Advanced Product. Basic Product can be sold for $10/unit, and Advanced Product can be sold for $12/unit. LogiCorp also has the option of further processing Basic and Advanced Products to produce Premium Basic and Premium Advanced, which sell for $20/unit and $25/unit, respectively. Each unit of Basic Product processed further requires an additional 3 hours of warehouse labor and $5 processing cost, yielding 1 unit of Premium Basic. Each unit of Advanced Product processed further requires an additional 4 hours of warehouse labor and $6 processing cost, yielding 1 unit of Premium Advanced. Each year, LogiCorp has 8,000 hours of warehouse labor available and can purchase up to 3,000 units of raw material. How can LogiCorp maximize its profits? Assume that the cost of warehouse labor is a fixed cost, raw materials can only be purchased in whole units.",
    "ground_truth": 348500.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_product_manufacturing_optimization(\n    ProductPerRawMaterial=[2, 3, 2, 3],\n    LaborHoursPerRawMaterial=2,\n    LaborHoursPerProduct=[0, 0, 3, 4],\n    SellingPrice=[10, 12, 20, 25],\n    ProcessingCost=[0, 0, 5, 6],\n    RawMaterialCost=5,\n    MaxLaborHours=8000,\n    MaxRawMaterial=3000\n):\n    \"\"\"\n    Models and solves the product manufacturing optimization problem.\n    \"\"\"\n    # Create a new model\n    model = gp.Model(\"Product Manufacturing Optimization\")\n\n    # Sets\n    Products = range(len(SellingPrice))\n\n    # Decision Variables\n    RawMaterialPurchased = model.addVar(vtype=GRB.INTEGER, name=\"RawMaterialPurchased\")\n    ProductProduced = model.addVars(Products, vtype=GRB.INTEGER, name=\"ProductProduced\")\n\n    # Objective: Maximize profit\n    revenue = gp.quicksum(SellingPrice[p] * ProductProduced[p] for p in Products)\n    raw_material_cost = RawMaterialCost * RawMaterialPurchased\n    processing_cost = gp.quicksum(ProcessingCost[p] * ProductProduced[p] for p in Products)\n\n    model.setObjective(revenue - raw_material_cost - processing_cost, GRB.MAXIMIZE)\n\n    # Constraint 1: Labor hours constraint\n    labor_hours = (LaborHoursPerRawMaterial * RawMaterialPurchased +\n                   gp.quicksum(LaborHoursPerProduct[p] * ProductProduced[p] for p in Products))\n    model.addConstr(labor_hours <= MaxLaborHours, \"LaborHours\")\n\n    # Constraint 2: Raw material constraint\n    model.addConstr(RawMaterialPurchased <= MaxRawMaterial, \"RawMaterial\")\n\n    # Constraint 3: Product production constraint\n    model.addConstr(\n        gp.quicksum(ProductProduced[p] for p in Products) ==\n        gp.quicksum(ProductPerRawMaterial[p] * RawMaterialPurchased for p in Products),\n        \"ProductionBalance\"\n    )\n\n    # Optimize the model\n    model.optimize()\n\n    # Return Results\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_product_manufacturing_optimization()\n    print(result)\n",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Production Planning",
        "modeling_type": "MILP",
        "industry_sector": "Manufacturing",
        "reason": "The problem focuses on determining the optimal quantities of raw materials to purchase and products to produce (including further processing) to maximize profit, which is a classic production planning scenario. The model uses integer variables for raw material purchase and product production, and all constraints and the objective function are linear, classifying it as a Mixed-Integer Linear Program."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D023",
    "description": "A commodities trader oversees a secure vault facility with a maximum capacity of 500 kilograms, dedicated to storing refined platinum. At the beginning of Quarter 1, the trader holds 150 kilograms of platinum. Each quarter, the trader assesses the current inventory, sells any amount of platinum up to the available stock at the prevailing selling price, then purchase platinum at the current purchase price for the season, while ensuring that the total inventory does not exceed the vault's capacity (requires selling first before buying). The selling and purchase prices for platinum for each quarter are as follows:\n\n| Quarter | Selling Price ($/kg) | Purchase Price ($/kg) |\n|---------|-----------------------|-----------------------|\n| 1       | 30,000               | 32,000               |\n| 2       | 35,000               | 36,000               |\n| 3       | 40,000               | 38,000               |\n| 4       | 36,000               | 33,000               |\n| 5       | 38,000               | 39,000               |\n| 6       | 42,000               | 40,000               |\n\nThe trader's objective is to devise an optimal strategy for buying and selling platinum over the six quarters to maximize total profit. What is the maximum achievable profit?",
    "ground_truth": 13300000.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_platinum_trading(\n    vault_capacity=500,\n    initial_inventory=150,\n    selling_price=[30000, 35000, 40000, 36000, 38000, 42000],\n    purchase_price=[32000, 36000, 38000, 33000, 39000, 40000]):\n    \"\"\"\n    Solves the platinum trading optimization problem.\n    \"\"\"\n    # --- 1. Model Creation ---\n    model = gp.Model(\"PlatinumTrading\")\n\n    # --- 2. Parameters & Sets ---\n    quarter_num = len(selling_price)\n    quarters = range(1, quarter_num + 1)\n\n    # --- 3. Decision Variables ---\n    selling_amount = model.addVars(quarters, lb=0, name=\"SellingAmount\")\n    purchase_amount = model.addVars(quarters, lb=0, name=\"PurchaseAmount\")\n    inventory = model.addVars(quarters,\n                              lb=0,\n                              ub=vault_capacity,\n                              name=\"Inventory\")\n\n    # --- 4. Objective Function ---\n    # Maximize total profit\n    objective = gp.quicksum(selling_price[q - 1] * selling_amount[q] -\n                            purchase_price[q - 1] * purchase_amount[q]\n                            for q in quarters)\n    model.setObjective(objective, GRB.MAXIMIZE)\n\n    # --- 5. Constraints ---\n    # Constraint 1: Initial inventory constraint\n    model.addConstr(inventory[1] == initial_inventory + purchase_amount[1] -\n                    selling_amount[1], \"InitialInventory\")\n\n    # Constraint 2: Inventory balance constraint\n    model.addConstrs(\n        (inventory[q] == inventory[q - 1] + purchase_amount[q] -\n         selling_amount[q] for q in range(2, quarter_num + 1)),\n        \"InventoryBalance\")\n\n    # Constraint 3: Selling amount must be less than or equal to inventory\n    model.addConstr(selling_amount[1] <= initial_inventory,\n                    \"InitialInventoryLimit\")\n    model.addConstrs((selling_amount[q] <= inventory[q - 1]\n                      for q in range(2, quarter_num + 1)), \"InventoryLimit\")\n\n    # --- 6. Solve the Model ---\n    model.optimize()\n\n    # --- 7. Return Results ---\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\n# Run the solver function\nif __name__ == \"__main__\":\n    result = solve_platinum_trading()\n    print(result)\n",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Inventory Management",
        "modeling_type": "LP",
        "industry_sector": "Commodities Trading",
        "reason": "The problem involves managing the inventory levels of platinum over multiple quarters to maximize profit, which is a classic inventory management problem. The model uses linear equations and inequalities with continuous variables, making it a Linear Program."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D030",
    "description": "Global Freight Solutions (GFS), a logistics company, needs to transport goods across three regions using services from three shipping providers. Each provider offers different cost structures and service mixes for large, medium, and small shipments, as detailed in Table as follows:\n\n| Supplier | Cost Per Shipment ($) | Percent Large | Percent Medium | Percent Small |\n|----------|-----------------------|---------------|----------------|---------------|\n| 1        | 5.2                   | 45            | 35             | 20            |\n| 2        | 4.7                   | 30            | 45             | 25            |\n| 3        | 3.5                   | 15            | 20             | 65            |\n\nGFS must fulfill a minimum monthly demand of at least 500 large shipments, 300 medium shipments, and 300 small shipments while minimizing total costs. Additionally, due to capacity constraints, no more than 700 shipments can be contracted from any single provider each month. Determine what the lowest possible cost is.",
    "ground_truth": 6553.7,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_supplier_shipment_optimization(\n    CostPerShipment=[5.2, 4.7, 3.5],\n    Percent=[\n        [45, 35, 20],\n        [30, 45, 25],\n        [15, 20, 65]\n    ],\n    Demand=[500, 300, 300],\n    MaxShipment=[700, 700, 700]\n):\n    # Create a new model\n    model = gp.Model(\"Supplier Shipment Optimization\")\n\n    # Sets\n    Suppliers = range(len(CostPerShipment))\n    ShipmentTypes = range(len(Demand))\n\n    # Decision Variables\n    ShipmentNum = model.addVars(Suppliers, vtype=GRB.INTEGER, name=\"ShipmentNum\")\n\n    # Objective: Minimize total cost of shipments\n    obj = gp.quicksum(CostPerShipment[s] * ShipmentNum[s] for s in Suppliers)\n    model.setObjective(obj, GRB.MINIMIZE)\n\n    # Constraint 1: Shipment number constraint (cannot exceed maximum)\n    for s in Suppliers:\n        model.addConstr(\n            ShipmentNum[s] <= MaxShipment[s],\n            f\"MaxShipment_{s+1}\"\n        )\n\n    # Constraint 2: Demand satisfaction constraint\n    for t in ShipmentTypes:\n        # Convert percentage to decimal\n        model.addConstr(\n            gp.quicksum((Percent[s][t] / 100) * ShipmentNum[s] for s in Suppliers) >= Demand[t],\n            f\"DemandSatisfaction_{t+1}\"\n        )\n\n    # Optimize the model\n    model.optimize()\n\n    # Return results\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.objVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_supplier_shipment_optimization()\n    print(result)",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MILP",
        "industry_sector": "Logistics",
        "reason": "The problem involves allocating shipment contracts to different providers to satisfy demand while minimizing cost and respecting capacity limits, which is a classic resource allocation problem. The solver uses integer variables and linear constraints, making it a Mixed-Integer Linear Program."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D047",
    "description": "The operations manager of QuickShip Logistics is trying to determine the number of warehouse supervisors needed to manage the company's distribution operations throughout the year. The estimated number of operational hours required each month is as follows:  \n\n| Month     | Operational Hours Needed |  \n|-----------|--------------------------|  \n| January   | 600                      |  \n| February  | 450                      |  \n| March     | 350                      |  \n| April     | 800                      |  \n| May       | 1,000                    |  \n| June      | 450                      |  \n| July      | 350                      |  \n| August    | 600                      |  \n| September | 450                      |  \n| October   | 350                      |  \n| November  | 250                      |  \n| December  | 150                      |  \n\nQuickShip Logistics aims to determine the optimal number of full-time warehouse supervisors to employ for the entire year, with the primary goal of minimizing total annual labor costs. These costs are composed of fixed monthly salaries of $5,000 for each supervisor (who are employed for all 12 months) and any overtime expenses incurred to meet fluctuating monthly operational hour demands. The company must ensure all operational tasks for each month are completed within that month, and all annual tasks are finalized by the end of December. \n\nEach of the N supervisors, when not taking their mandatory one-month annual paid vacation, can provide up to 160 standard operational hours monthly. To cover demands exceeding this standard capacity, these non-vacationing supervisors can work up to an additional 40 hours of overtime each per month, with overtime labor paid at a rate of $45 per hour. How can QuickShip Logistics minimize employment costs?",
    "ground_truth": 309000.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_supervisor_scheduling(\n    operational_hours_needed={\n        1: 600, 2: 450, 3: 350, 4: 800, 5: 1000, 6: 450,\n        7: 350, 8: 600, 9: 450, 10: 350, 11: 250, 12: 150\n    },\n    normal_hours_per_supervisor=160,\n    overtime_hours_per_supervisor=40,\n    supervisors_vacation_months=1,\n    fixed_salary=5000,\n    overtime_rate=45\n):\n    \"\"\"\n    Models and solves the supervisor scheduling problem.\n    \"\"\"\n    model = gp.Model(\"WarehouseSupervisors\")\n    model.setParam('OutputFlag', 0)\n\n    # --- Parameters ---\n    months = range(1, 13)\n\n    # --- Decision Variables ---\n    supervisors_needed = model.addVar(vtype=GRB.INTEGER, name=\"SupervisorsNeeded\")\n    work_supervisor_per_month = model.addVars(months, vtype=GRB.INTEGER, name=\"WorkSupervisorPerMonth\")\n    overtime_hours_per_month = model.addVars(months, vtype=GRB.INTEGER, name=\"OvertimeHoursPerMonth\")\n\n    # --- Objective Function ---\n    total_cost = fixed_salary * supervisors_needed * 12\n    for m in months:\n        total_cost += overtime_rate * overtime_hours_per_month[m]\n    model.setObjective(total_cost, GRB.MINIMIZE)\n\n    # --- Constraints ---\n    for m in months:\n        model.addConstr(\n            work_supervisor_per_month[m] * normal_hours_per_supervisor +\n            overtime_hours_per_month[m] >= operational_hours_needed[m],\n            name=f\"OperationalHoursNeeded_{m}\"\n        )\n\n    model.addConstr(\n        gp.quicksum(work_supervisor_per_month[m] for m in months) ==\n        (12 - supervisors_vacation_months) * supervisors_needed,\n        name=\"VacationConstraint\"\n    )\n\n    for m in months:\n        model.addConstr(\n            work_supervisor_per_month[m] <= supervisors_needed,\n            name=f\"SupervisorsNumberConstraint_{m}\"\n        )\n\n    for m in months:\n        model.addConstr(\n            overtime_hours_per_month[m] <= work_supervisor_per_month[m] * overtime_hours_per_supervisor,\n            name=f\"OvertimeLimit_{m}\"\n        )\n\n    # --- Solve ---\n    model.optimize()\n\n    # --- Return Results ---\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == '__main__':\n    result = solve_supervisor_scheduling()\n    print(result)",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Workforce Scheduling",
        "modeling_type": "MILP",
        "industry_sector": "Logistics",
        "reason": "The problem involves determining the optimal number of supervisors and their work/overtime hours to meet fluctuating monthly operational demands while minimizing labor costs, which is a classic workforce scheduling problem. The solver program uses integer variables for the number of supervisors and working supervisors per month, and linear constraints and objective function, classifying it as a Mixed-Integer Linear Program. The application is within a logistics company's distribution operations."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D083",
    "description": "You are in charge of Green Freight, a logistics company that owns 5 old diesel trucks and plans to renew part of its fleet with new electric trucks to reduce costs and emissions. The company needs to decide which of the 5 old trucks to retire and may purchase up to 3 new electric trucks, while it must maintain a total fleet capacity of at least 4 trucks. The government imposes a punitive carbon tax on the company's total carbon emissions, which is proportional to the square of the total emissions, with a tax coefficient of 80. The company's goal is to make an optimal vehicle replacement decision to minimize the total operating cost for the coming year, which consists of vehicle costs, operating costs, and the punitive carbon tax. The specific vehicle information and cost data are shown in Table 1.\n\nHow should Green Freight decide which trucks to keep and which to buy to minimize its total annual cost?\n\nTable 1: Vehicle Cost and Emission Data\n| Vehicle Model | Attribute | Annual Operating Cost (¥) | Annual Carbon Emissions (tons) | Annualized Investment/Depreciation Cost (¥) |\n| :--- | :--- | :--- | :--- | :--- |\n| Old Diesel Truck D1 | - | 80,000 | 15 | - |\n| Old Diesel Truck D2 | - | 85,000 | 16 | - |\n| Old Diesel Truck D3 | - | 78,000 | 14 | - |\n| Old Diesel Truck D4 | - | 92,000 | 18 | - |\n| Old Diesel Truck D5 | - | 88,000 | 17 | - |\n| New Electric Truck | (per vehicle) | 30,000 | 0 | 120,000 |",
    "ground_truth": 525280.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\ndef solve_green_freight_minlp(\n    old_trucks=['D1', 'D2', 'D3', 'D4', 'D5'],\n    annual_op_cost_old={\n        'D1': 80000, 'D2': 85000, 'D3': 78000, 'D4': 92000, 'D5': 88000\n    },\n    annual_emissions_old={\n        'D1': 15, 'D2': 16, 'D3': 14, 'D4': 18, 'D5': 17\n    },\n    annual_op_cost_new=30000,\n    annualized_investment_new=120000,\n    carbon_tax_coeff=80,\n    min_fleet_size=4,\n    max_new_trucks=3\n):\n    \"\"\"\n    Solves the Green Freight vehicle replacement problem to minimize total annual cost.\n    This is a Mixed-Integer Non-Linear Programming (MINLP) problem due to the\n    quadratic term in the carbon tax calculation.\n    \"\"\"\n    # Create a new model\n    model = gp.Model(\"GreenFreight\")\n\n    # --- Decision Variables ---\n    # Binary variable: 1 if an old truck is kept, 0 if retired\n    keep_old_truck = model.addVars(old_trucks, vtype=GRB.BINARY, name=\"KeepOldTruck\")\n\n    # Integer variable: number of new electric trucks to buy\n    buy_new_trucks = model.addVar(vtype=GRB.INTEGER, name=\"BuyNewTrucks\", lb=0)\n\n    # --- Objective Function: Minimize Total Annual Cost ---\n    \n    # 1. Cost of operating the old trucks that are kept\n    cost_kept_trucks = gp.quicksum(annual_op_cost_old[d] * keep_old_truck[d] \n                                   for d in old_trucks)\n\n    # 2. Cost (operating + investment) of new trucks\n    cost_new_trucks = (annual_op_cost_new + annualized_investment_new) * buy_new_trucks\n\n    # 3. Punitive carbon tax (non-linear part)\n    total_emissions = gp.quicksum(annual_emissions_old[d] * keep_old_truck[d] \n                                  for d in old_trucks)\n    carbon_tax = carbon_tax_coeff * total_emissions * total_emissions\n\n    model.setObjective(\n        cost_kept_trucks + cost_new_trucks + carbon_tax,\n        GRB.MINIMIZE\n    )\n\n    # --- Constraints ---\n    \n    # 1. Minimum fleet size constraint\n    model.addConstr(keep_old_truck.sum('*') + buy_new_trucks >= min_fleet_size, \n                    name=\"MinFleetSize\")\n\n    # 2. New truck purchase limit\n    model.addConstr(buy_new_trucks <= max_new_trucks, \n                    name=\"MaxNewTrucks\")\n\n    # The domain of the variables (Binary, Integer, >=0) is already set during their creation.\n\n    # Optimize the model\n    model.optimize()\n\n    # --- Return Results ---\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.objVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\n# Run the solver function\nif __name__ == '__main__':\n    result = solve_green_freight_minlp()\n    print(result)",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Fleet Management",
        "modeling_type": "MINLP",
        "industry_sector": "Transportation",
        "reason": "The problem involves deciding which vehicles to keep and which to purchase for a logistics company's fleet, which falls under fleet management. The objective function includes a quadratic term for carbon tax and decision variables are binary and integer, making it a Mixed-Integer Non-Linear Program (MINLP). The context of a logistics company directly places it in the transportation sector."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D017",
    "description": "To strengthen grassroots medical services, the Health Bureau of a city has equipped a mobile medical vehicle to regularly provide basic medical check-ups and medicines to various communities in the suburbs. To improve service efficiency, it is necessary to optimize the route of the mobile medical vehicle. The starting point of the medical vehicle is the Central City Hospital, located at coordinates (0, 0). The information for the 10 communities to be served is as follows:\n\n|  COMMUNITY ID |        (x, y)       | TIME WINDOW |\n|---------------|---------------------|-------------|\n| C1            | (-5.87, -3.3)       | [8, 12]     |\n| C2            | (-4.1, 4.6)         | [9, 13]     |\n| C3            | (-2.27, -7.45)      | [10, 15]    |\n| C4            | (4.36, 3.38)        | [11, 15]    |\n| C5            | (9.05, 5.02)        | [9, 16]     |\n| C6            | (-7.46, 6.97)       | [9, 17]     |\n| C7            | (7.75, 7.38)        | [10, 18]    |\n| C8            | (0.06, -4.25)       | [13, 19]    |\n| C9            | (-6.13, -9.78)      | [8, 16]     |\n| C10           | (3.25, 9.86)        | [8, 16]     |\n\nEach community has a time window during which the medical vehicle must arrive. The medical vehicle departs from the Central City Hospital at 8:00 AM and travels at a speed of 15 km/h. After visiting all communities, the vehicle must return to the Central City Hospital. What is the shortest travel distance? (Distances are calculated as straight-line distances in kilometers.)",
    "ground_truth": 70.6552168606,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\nimport math\n\n\ndef solve_time_windowed_tsp(\n    coordinates=[(0, 0), (-5.87, -3.3), (-4.1, 4.6), (-2.27, -7.45),\n                 (4.36, 3.38), (9.05, 5.02), (-7.46, 6.97), (7.75, 7.38),\n                 (0.06, -4.25), (-6.13, -9.78), (3.25, 9.86)],\n    time_windows=[(8, 16), (8, 12), (9, 13), (10, 15), (11, 15), (9, 16),\n                  (9, 17), (10, 18), (13, 19), (8, 16), (8, 16)],\n    speed=15,\n    M=10000,\n    start_time=8):\n    \"\"\"\n    Solves the Traveling Salesperson Problem with Time Windows (TSPTW).\n    \"\"\"\n    community_num = len(coordinates) - 1\n    nodes = range(community_num + 1)  # 0 is hospital, 1-10 are communities\n\n    # Calculate distance matrix\n    def calculate_distance(coord1, coord2):\n        return math.sqrt(\n            (coord1[0] - coord2[0])**2 + (coord1[1] - coord2[1])**2)\n\n    distance = {}\n    for i in nodes:\n        for j in nodes:\n            if i != j:\n                distance[i, j] = calculate_distance(coordinates[i],\n                                                    coordinates[j])\n\n    # --- Model Initialization ---\n    model = gp.Model(\"TimeWindowedTSP\")\n\n    # --- Decision variables ---\n    # x[i,j] = 1 if path goes from i to j\n    x = model.addVars(nodes, nodes, vtype=GRB.BINARY, name='x')\n    for i in nodes:\n        x[i, i].ub = 0\n\n    # t_a[i] = arrival time at node i\n    t_a = model.addVars(nodes,\n                        lb=[tw[0] for tw in time_windows],\n                        ub=[tw[1] for tw in time_windows],\n                        vtype=GRB.CONTINUOUS,\n                        name='t_a')\n\n    # t_d[i] = departure time from node i\n    t_d = model.addVars(nodes,\n                        lb=[tw[0] for tw in time_windows],\n                        ub=[tw[1] for tw in time_windows],\n                        vtype=GRB.CONTINUOUS,\n                        name='t_d')\n\n    # Hospital departure time is fixed\n    t_d[0].lb = start_time\n    t_d[0].ub = start_time\n\n    # --- Objective Function ---\n    # minimize total distance\n    objective = gp.quicksum(distance[i, j] * x[i, j] for i in nodes\n                            for j in nodes if i != j)\n    model.setObjective(objective, GRB.MINIMIZE)\n\n    # --- Constraints ---\n    # Constraint 1: Each node must be visited exactly once\n    model.addConstrs((gp.quicksum(x[i, j] for i in nodes if i != j) == 1\n                      for j in nodes if j != 0),\n                     name='visit_to')\n\n    # Constraint 2: Must leave each node exactly once\n    model.addConstrs((gp.quicksum(x[i, j] for j in nodes if i != j) == 1\n                      for i in nodes if i != 0),\n                     name='leave_from')\n\n    # Hospital constraints: must leave once and return once\n    model.addConstr(gp.quicksum(x[0, j] for j in nodes if j != 0) == 1,\n                    name='leave_hospital')\n    model.addConstr(gp.quicksum(x[i, 0] for i in nodes if i != 0) == 1,\n                    name='return_hospital')\n\n    # Time window constraints\n    for i in nodes[1:]:  # Skip hospital\n        # Departure time must be after arrival time\n        model.addConstr(t_d[i] >= t_a[i], name=f'depart_after_arrival_{i}')\n\n    # Time consistency constraints\n    for i in nodes:\n        for j in nodes:\n            if i != j:\n                # If we go from i to j, arrival time at j must be after departure from i plus travel time\n                model.addConstr(\n                    t_d[i] + distance[i, j] / speed - M * (1 - x[i, j]) <=\n                    t_a[j], f'time_consistency_min_{i}_{j}')\n                model.addConstr(\n                    t_d[i] + distance[i, j] / speed + M * (1 - x[i, j]) >=\n                    t_a[j], f'time_consistency_max_{i}_{j}')\n\n    def find_subtours(edges):\n        # Create adjacency list\n        adj = {i: [] for i in nodes}\n        for i, j in edges:\n            adj[i].append(j)\n\n        # Find all subtours\n        unvisited = set(nodes)\n        subtours = []\n        while unvisited:\n            current = next(iter(unvisited))\n            subtour = []\n            while current in unvisited:\n                unvisited.remove(current)\n                subtour.append(current)\n                next_nodes = adj.get(current, [])\n                if not next_nodes:\n                    break\n                current = next_nodes[0]\n            if len(subtour) < len(nodes):\n                subtours.append(subtour)\n        return subtours\n\n    def subtour_cb(model, where):\n        if where == GRB.Callback.MIPSOL:\n            # Get values of binary variables\n            x_vals = model.cbGetSolution(model._vars)\n            edges = [(i, j) for i, j in x_vals.keys() if x_vals[i, j] > 0.5]\n\n            # Find subtours\n            subtours = find_subtours(edges)\n\n            # Add subtour elimination constraints\n            for S in subtours:\n                if len(S) < len(nodes):\n                    model.cbLazy(\n                        gp.quicksum(x[i, j] for i in S for j in S\n                                    if i != j) <= len(S) - 1)\n\n    # Enable lazy constraints\n    model._vars = x\n    model.Params.lazyConstraints = 1\n\n    # Optimize model with callback\n    model.optimize(subtour_cb)\n\n    # --- Return Results ---\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_time_windowed_tsp()\n    print(result)\n",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Routing",
        "modeling_type": "MILP",
        "industry_sector": "Health",
        "reason": "The problem involves finding the shortest route for a single vehicle to visit multiple locations (communities) with time window constraints, which is a classic Traveling Salesperson Problem with Time Windows (TSPTW). The solver program uses binary and continuous variables, linear objective, and linear constraints, including subtour elimination, characteristic of a Mixed-Integer Linear Program (MILP). The application is for a mobile medical vehicle providing services to communities, placing it in the health sector."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D037",
    "description": "AutoParts Ltd. manufactures three types of automotive components: Engine Block, Transmission, and Brake System. The company sources raw materials at a cost of $60 per unit. Each unit of raw material can be processed into 7 units of Engine Block and 3 units of Transmission. Processing one unit of raw material requires $8 in energy costs and 7 hours of machine time.  \n\nEngine Block can be used in three ways:  \n- Sold directly for $25 per unit.  \n- Processed into 1 unit of Transmission, requiring 4 hours of machine time and $5 in additional costs.  \n- Processed into 1 unit of Brake System, requiring 6 hours of machine time and $10 in additional costs.  \n\nTransmission can be used in two ways:  \n- Sold directly for $35 per unit.  \n- Processed into 1 unit of Brake System, requiring 5 hours of machine time and $12 in additional costs.  \n\nBrake System is sold for $45 per unit. The company has a maximum machine time capacity of 60,000 hours per year. Additionally, there is a contractual obligation to produce at least 4,000 units of Brake System annually. The maximum market demand for each component is as follows:  \n- Engine Block: 20,000 units  \n- Transmission: 15,000 units  \n- Brake System: 12,000 units  \n\nDetermine how AutoParts Ltd. can maximize its annual profit while meeting all constraints.",
    "ground_truth": 851452.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_component_manufacturing_optimization(\n    RawMaterialCost=60,\n    ComponentPerRawMaterial=[7, 3, 0],\n    EnergyCostPerRawMaterial=8,\n    MachineTimePerRawMaterial=7,\n    SellingPrice=[25, 35, 45],\n    Engine2TransmissionCost=5,\n    Engine2TransmissionMachineTime=4,\n    Engine2BrakeSystemCost=10,\n    Engine2BrakeSystemMachineTime=6,\n    Transmission2BrakeSystemCost=12,\n    Transmission2BrakeSystemMachineTime=5,\n    MaxMachineTime=60000,\n    MinBrakeSystemProduction=4000,\n    MaxDemand=[20000, 15000, 12000]\n):\n    \"\"\"\n    Models and solves the component manufacturing and processing optimization problem.\n    \"\"\"\n    # Create a new model\n    model = gp.Model(\"Component Manufacturing and Processing Optimization\")\n\n    # Sets\n    Components = range(len(SellingPrice))\n\n    # Decision Variables\n    RawMaterialPurchased = model.addVar(vtype=GRB.INTEGER, name=\"RawMaterialPurchased\")\n    ComponentProducedfromRawMaterial = model.addVars(Components, vtype=GRB.INTEGER, name=\"ComponentProducedfromRawMaterial\")\n    Engine2TransmissionProduced = model.addVar(vtype=GRB.INTEGER, name=\"Engine2TransmissionProduced\")\n    Engine2BrakeSystemProduced = model.addVar(vtype=GRB.INTEGER, name=\"Engine2BrakeSystemProduced\")\n    Transmission2BrakeSystemProduced = model.addVar(vtype=GRB.INTEGER, name=\"Transmission2BrakeSystemProduced\")\n    ComponentSold = model.addVars(Components, vtype=GRB.INTEGER, name=\"ComponentSold\")\n\n    # Objective: Maximize total profit\n    revenue = gp.quicksum(SellingPrice[c] * ComponentSold[c] for c in Components)\n    raw_material_cost = (RawMaterialCost + EnergyCostPerRawMaterial) * RawMaterialPurchased\n    processing_cost = (Engine2TransmissionCost * Engine2TransmissionProduced +\n                       Engine2BrakeSystemCost * Engine2BrakeSystemProduced +\n                       Transmission2BrakeSystemCost * Transmission2BrakeSystemProduced)\n\n    model.setObjective(revenue - raw_material_cost - processing_cost, GRB.MAXIMIZE)\n\n    # Constraint 1: Machine time constraint\n    machine_time = (MachineTimePerRawMaterial * RawMaterialPurchased +\n                    Engine2TransmissionMachineTime * Engine2TransmissionProduced +\n                    Engine2BrakeSystemMachineTime * Engine2BrakeSystemProduced +\n                    Transmission2BrakeSystemMachineTime * Transmission2BrakeSystemProduced)\n    model.addConstr(machine_time <= MaxMachineTime, \"MachineTime\")\n\n    # Constraint 2: Minimum Brake System production constraint\n    model.addConstr(\n        Engine2BrakeSystemProduced + Transmission2BrakeSystemProduced >= MinBrakeSystemProduction,\n        \"MinBrakeSystemProduction\"\n    )\n\n    # Constraint 3: Demand constraint\n    for c in Components:\n        model.addConstr(ComponentSold[c] <= MaxDemand[c], f\"MaxDemand_{c}\")\n\n    # Constraint 4: Production constraint - components from raw material\n    for c in Components:\n        model.addConstr(\n            ComponentProducedfromRawMaterial[c] == ComponentPerRawMaterial[c] * RawMaterialPurchased,\n            f\"RawMaterialProduction_{c}\"\n        )\n\n    # Constraint 5: Production constraint - Engine Block\n    model.addConstr(\n        ComponentSold[0] == ComponentProducedfromRawMaterial[0] - Engine2TransmissionProduced - Engine2BrakeSystemProduced,\n        \"EngineBlockBalance\"\n    )\n\n    # Constraint 6: Production constraint - Transmission\n    model.addConstr(\n        ComponentSold[1] == ComponentProducedfromRawMaterial[1] + Engine2TransmissionProduced - Transmission2BrakeSystemProduced,\n        \"TransmissionBalance\"\n    )\n\n    # Constraint 7: Production constraint - Brake System\n    model.addConstr(\n        ComponentSold[2] == ComponentProducedfromRawMaterial[2] + Engine2BrakeSystemProduced + Transmission2BrakeSystemProduced,\n        \"BrakeSystemBalance\"\n    )\n\n    # Optimize the model\n    model.optimize()\n\n    # Return Results\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_component_manufacturing_optimization()\n    print(result)\n",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Production Planning",
        "modeling_type": "MILP",
        "industry_sector": "Manufacturing",
        "reason": "The problem involves determining the optimal production quantities of various automotive components to maximize profit, considering raw material processing, intermediate product transformations, machine time, and market demands. The solver program uses integer variables and linear constraints, making it a Mixed-Integer Linear Program (MILP)."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D014",
    "description": "A logistics company has a batch of goods to transport, and the packaging boxes are neatly arranged with the same side dimensions but different thicknesses and weights. The company has 12 trucks, and each truck has space for placing goods on both sides. The total weight capacity of each truck is 10 tons, and to ensure smooth driving, the weight difference of goods on both sides of the truck should not exceed 500 kg. The total thickness capacity of each truck is 5 meters. There are 100 pieces of goods to be loaded, with thicknesses (cm) of 108, 62, 121, 31, 37, 90, 49, 49, 53, 156, 37, 62, 85, 78, 110, 119, 58, 159, 62, 150, 97, 131, 88, 89, 146, 50, 69, 58, 106, 138, 105, 95, 131, 38, 38, 92, 41, 40, 76, 133, 101, 103, 82, 134, 36, 126, 73, 121, 30, 116, 104, 140, 116, 74, 59, 66, 80, 64, 124, 100, 65, 47, 96, 83, 146, 139, 36, 47, 58, 133, 93, 60, 41, 38, 105, 31, 119, 115, 98, 93, 37, 90, 121, 83, 92, 36, 32, 56, 74, 126, 117, 72, 43, 38, 78, 65, 112, 149, 33, 88, and weights(kg) of 469, 301, 673, 239, 451, 723, 513, 417, 397, 1715, 261, 578, 916, 736, 1024, 634, 346, 1038, 428, 1008, 709, 1396, 876, 694, 737, 398, 656, 356, 1165, 1112, 729, 1070, 1015, 224, 437, 917, 273, 303, 614, 738, 1069, 636, 686, 1035, 188, 1103, 647, 1269, 271, 1234, 631, 1577, 1201, 614, 435, 564, 695, 375, 1541, 693, 413, 270, 482, 979, 1461, 1251, 329, 389, 606, 1491, 445, 493, 357, 403, 706, 196, 1405, 571, 1097, 872, 279, 581, 973, 814, 585, 221, 235, 664, 817, 929, 951, 509, 434, 339, 525, 499, 1250, 1419, 140, 720. What is the minimum number of trucks needed to meet the transportation requirements?",
    "ground_truth": 9.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\ndef solve_truck_loading(\n    truck_num=12,\n    goods_num=100,\n    truck_max_capacity_side=[5250, 4750],\n    truck_max_weight_difference=500,\n    truck_max_thickness=500,\n    goods_thickness=[\n        108, 62, 121, 31, 37, 90, 49, 49, 53, 156, 37, 62, 85, 78, 110, 119, 58,\n        159, 62, 150, 97, 131, 88, 89, 146, 50, 69, 58, 106, 138, 105, 95, 131, 38,\n        38, 92, 41, 40, 76, 133, 101, 103, 82, 134, 36, 126, 73, 121, 30, 116, 104,\n        140, 116, 74, 59, 66, 80, 64, 124, 100, 65, 47, 96, 83, 146, 139, 36, 47,\n        58, 133, 93, 60, 41, 38, 105, 31, 119, 115, 98, 93, 37, 90, 121, 83, 92,\n        36, 32, 56, 74, 126, 117, 72, 43, 38, 78, 65, 112, 149, 33, 88\n    ],\n    goods_weight=[\n        469, 301, 673, 239, 451, 723, 513, 417, 397, 1715, 261, 578, 916, 736,\n        1024, 634, 346, 1038, 428, 1008, 709, 1396, 876, 694, 737, 398, 656, 356,\n        1165, 1112, 729, 1070, 1015, 224, 437, 917, 273, 303, 614, 738, 1069, 636,\n        686, 1035, 188, 1103, 647, 1269, 271, 1234, 631, 1577, 1201, 614, 435, 564,\n        695, 375, 1541, 693, 413, 270, 482, 979, 1461, 1251, 329, 389, 606, 1491,\n        445, 493, 357, 403, 706, 196, 1405, 571, 1097, 872, 279, 581, 973, 814,\n        585, 221, 235, 664, 817, 929, 951, 509, 434, 339, 525, 499, 1250, 1419,\n        140, 720\n    ]\n):\n    \"\"\"\n    Solves the truck loading problem.\n    \"\"\"\n    model = gp.Model(\"TruckLoadingProblem\")\n\n    trucks = range(1, truck_num + 1)\n    goods = range(1, goods_num + 1)\n    sides = [0, 1]\n\n    x = {}\n    for g in goods:\n        for k in trucks:\n            for s in sides:\n                x[g, k, s] = model.addVar(vtype=GRB.BINARY, name=f\"x_{g}_{k}_{s}\")\n\n    y = {}\n    for k in trucks:\n        y[k] = model.addVar(vtype=GRB.BINARY, name=f\"y_{k}\")\n\n    objective = gp.quicksum(y[k] for k in trucks)\n    model.setObjective(objective, GRB.MINIMIZE)\n\n    for g in goods:\n        model.addConstr(gp.quicksum(x[g, k, s] for k in trucks for s in sides) == 1, name=f\"good_{g}_assigned_once\")\n\n    for k in trucks:\n        for s in sides:\n            model.addConstr(gp.quicksum(goods_weight[g - 1] * x[g, k, s] for g in goods) <= truck_max_capacity_side[s], name=f\"truck_{k}_side_{s}_capacity\")\n\n    for k in trucks:\n        model.addConstr(gp.quicksum(goods_weight[g - 1] * x[g, k, 0] for g in goods) - gp.quicksum(goods_weight[g - 1] * x[g, k, 1] for g in goods) <= truck_max_weight_difference, name=f\"truck_{k}_side_difference_upper\")\n        model.addConstr(gp.quicksum(goods_weight[g - 1] * x[g, k, 0] for g in goods) - gp.quicksum(goods_weight[g - 1] * x[g, k, 1] for g in goods) >= 0, name=f\"truck_{k}_side_difference_lower\")\n\n    for k in trucks:\n        for s in sides:\n            model.addConstr(gp.quicksum(goods_thickness[g - 1] * x[g, k, s] for g in goods) <= truck_max_thickness, name=f\"truck_{k}_side_{s}_thickness\")\n\n    for k in trucks:\n        model.addConstr(gp.quicksum(x[g, k, s] for g in goods for s in sides) >= y[k], name=f\"truck_{k}_used_if_loaded_1\")\n\n    for g in goods:\n        for k in trucks:\n            for s in sides:\n                model.addConstr(y[k] >= x[g, k, s], name=f\"truck_{k}_used_if_loaded_2_{g}_{s}\")\n\n    model.optimize()\n\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.objVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\nif __name__ == \"__main__\":\n    result = solve_truck_loading()\n    print(result)\n",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Bin Packing",
        "modeling_type": "MILP",
        "industry_sector": "Logistics",
        "reason": "The problem involves assigning goods (items) to trucks (bins) to minimize the number of trucks used, subject to weight, thickness, and weight balance constraints. This is a classic Bin Packing problem. The solver uses binary variables for assignment and truck usage, and linear constraints, making it a Mixed-Integer Linear Program (MILP). The application is clearly in the transportation and delivery of goods, which falls under the Logistics sector."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D071",
    "description": "A warehouse needs to distribute 5 types of products (A, B, C, D, E) to 3 retail stores (Store1, Store2, Store3) using delivery trucks. Each truck has a maximum capacity of 15 tons. The products have the following weights per unit: A=2 tons, B=3 tons, C=1 ton, D=4 tons, E=2 tons. The stores require the following quantities: Store1 needs 2A+1B+3C, Store2 needs 1A+2D+1E, Store3 needs 3B+2C+1E. The warehouse has 4 trucks available. The goal is to minimize the total number of trucks used while meeting all store demands without exceeding truck capacities.",
    "ground_truth": 3.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\ndef solve_warehouse_distribution(\n    products=['A', 'B', 'C', 'D', 'E'],\n    stores=['Store1', 'Store2', 'Store3'],\n    trucks=[1, 2, 3, 4],\n    product_weights={'A': 2, 'B': 3, 'C': 1, 'D': 4, 'E': 2},\n    truck_capacity=15,\n    store_demands={\n        'Store1': {'A': 2, 'B': 1, 'C': 3, 'D': 0, 'E': 0},\n        'Store2': {'A': 1, 'B': 0, 'C': 0, 'D': 2, 'E': 1},\n        'Store3': {'A': 0, 'B': 3, 'C': 2, 'D': 0, 'E': 1}\n    }\n):\n    \"\"\"\n    Solves the warehouse distribution problem using Gurobi.\n    Minimizes the number of trucks used to deliver products to stores while meeting demand and capacity constraints.\n    \"\"\"\n    # Create model\n    model = gp.Model(\"WarehouseDistribution\")\n\n    # Decision variables\n    # x[p,s,t]: quantity of product p delivered to store s using truck t\n    x = model.addVars(products, stores, trucks, vtype=GRB.INTEGER, name=\"ProductDelivery\")\n\n    # y[t]: binary variable indicating if truck t is used\n    y = model.addVars(trucks, vtype=GRB.BINARY, name=\"TruckUsed\")\n\n    # Objective: Minimize total trucks used\n    model.setObjective(y.sum(), GRB.MINIMIZE)\n\n    # Constraints\n    # 1. Meet all store demands\n    for s in stores:\n        for p in products:\n            model.addConstr(\n                gp.quicksum(x[p, s, t] for t in trucks) == store_demands[s][p],\n                name=f\"Demand_{s}_{p}\"\n            )\n\n    # 2. Truck capacity limit\n    for t in trucks:\n        model.addConstr(\n            gp.quicksum(product_weights[p] * x[p, s, t] for p in products for s in stores)\n            <= truck_capacity * y[t],\n            name=f\"Capacity_{t}\"\n        )\n\n    # 3. Logical constraint: if any product is delivered by truck t, y_t must be 1\n    # Using a large M (here M = max possible demand for any product)\n    M = max(max(demands.values()) for demands in store_demands.values())\n    for p in products:\n        for s in stores:\n            for t in trucks:\n                model.addConstr(\n                    x[p, s, t] <= M * y[t],\n                    name=f\"Logic_{p}_{s}_{t}\"\n                )\n\n    # Solve the model\n    model.optimize()\n\n    # Return results\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_warehouse_distribution()\n    print(result)",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MILP",
        "industry_sector": "Logistics",
        "reason": "The problem involves allocating products to trucks and then to stores, which is a classic resource allocation problem. The solver uses integer and binary variables with linear constraints and objective, making it a Mixed-Integer Linear Program. The context of distributing products from a warehouse to retail stores using trucks falls under the Logistics sector."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D089",
    "description": "A shared mobility company plans to deploy a fleet of 1,000 electric scooters across five key hotspot zones in a city. To ensure service stability and a positive user experience, the company aims to achieve a balanced deployment that aligns with the demand profile of each zone.\n\nThe company's goal is to minimize the network's imbalance. This imbalance is defined as the sum of the squared differences between the number of scooters deployed in each zone and an ideal, attractiveness-weighted deployment. The ideal deployment for a zone is calculated by distributing the total fleet proportionally to that zone's share of the total attractiveness.\n\nWhen planning the deployment, the following conditions must be met:\n1. The total number of scooters deployed across all zones must equal 1,000.\n2. To align operational capacity with potential demand, the number of scooters in each zone must not be less than a minimum quota. This quota is set at 10% of the total fleet size, weighted by the proportion of that zone's attractiveness relative to the total attractiveness of all zones.\n3. The 'Commercial Center' and 'Transit Hub' zones are geographically adjacent and frequently interact with each other. To ensure service continuity, the absolute difference in the number of scooters deployed in these two zones must not exceed 50.\n4. The company has divided the zones into two operational clusters: Cluster 1 (Commercial Center, Tourist Area) and Cluster 2 (University City, Tech Park, Transit Hub). Each cluster can deploy a maximum of 600 scooters to match the management capacity of local operational teams.\n\nThe attractiveness data for each zone is provided in the table below. Please devise a deployment plan that minimizes the network imbalance while satisfying all constraints.\n\nTable: Zonal Attractiveness Data\n\n| Hotspot Zone | Attractiveness (Predicted Daily Trips) |\n|:---|:---|\n| Commercial Center | 500 |\n| University City | 800 |\n| Tech Park | 700 |\n| Tourist Area | 600 |\n| Transit Hub | 900 |",
    "ground_truth": 6122.9795918367,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\nfrom typing import List, Dict\n\ndef solve_scooter_deployment(\n    zones: List[str] = ['Commercial Center', 'University City', 'Tech Park', 'Tourist Area', 'Transit Hub'],\n    attractiveness: Dict[str, int] = {\n        'Commercial Center': 500,\n        'University City': 800,\n        'Tech Park': 700,\n        'Tourist Area': 600,\n        'Transit Hub': 900\n    },\n    total_scooters: int = 1000,\n    min_quota_factor: float = 0.1,\n    adjacency_limit: int = 50,\n    cluster_capacity: int = 600\n):\n    \"\"\"\n    Solves the shared e-scooter network balancing problem using Gurobi.\n\n    Args:\n        zones (List[str]): A list of hotspot zone names.\n        attractiveness (Dict[str, int]): A dictionary mapping each zone to its attractiveness value.\n        total_scooters (int): The total number of scooters to be deployed.\n        min_quota_factor (float): The factor of the total fleet size used for calculating the minimum deployment quota.\n        adjacency_limit (int): The maximum allowed difference in deployment for adjacent key zones.\n        cluster_capacity (int): The maximum number of scooters an operational cluster can manage.\n    \"\"\"\n    # --- 1. Setup and Pre-calculation ---\n    num_zones = len(zones)\n    if num_zones == 0:\n        return {\"status\": \"error\", \"message\": \"The list of zones cannot be empty.\"}\n\n    total_attractiveness = sum(attractiveness.values())\n\n    # --- 2. Gurobi Model Initialization ---\n    model = gp.Model(\"ScooterDeployment_Complex\")\n\n    # --- 3. Define Decision Variables ---\n    # n[i]: number of scooters deployed in zone i\n    n = model.addVars(zones, name=\"deployment\", vtype=GRB.INTEGER, lb=0)\n\n    # --- 4. Set Objective Function ---\n    # Objective: Minimize the deviation from an ideal, attractiveness-weighted deployment.\n    target_deployments = {}\n    if total_attractiveness > 0:\n        for i in zones:\n            target_deployments[i] = total_scooters * (attractiveness[i] / total_attractiveness)\n    else: # Handle case of zero total attractiveness\n        avg_deployment = total_scooters / num_zones\n        for i in zones:\n            target_deployments[i] = avg_deployment\n\n    # The objective is the sum of squared differences from this new weighted target.\n    imbalance = gp.quicksum((n[i] - target_deployments[i]) * (n[i] - target_deployments[i]) for i in zones)\n    model.setObjective(imbalance, GRB.MINIMIZE)\n\n    # --- 5. Add Constraints ---\n    # Constraint 1: Total Deployment Constraint\n    model.addConstr(gp.quicksum(n[i] for i in zones) == total_scooters, \"TotalDeployment\")\n\n    # Constraint 2: Minimum Quota Constraint\n    if total_attractiveness > 0:\n        for i in zones:\n            min_quota = total_scooters * min_quota_factor * (attractiveness[i] / total_attractiveness)\n            model.addConstr(n[i] >= min_quota, f\"MinQuota_{i}\")\n\n    # Constraint 3: Adjacency Constraint\n    # The absolute difference between 'Commercial Center' and 'Transit Hub' must not exceed the limit.\n    model.addConstr(n['Commercial Center'] - n['Transit Hub'] <= adjacency_limit, \"Adjacency_Upper\")\n    model.addConstr(n['Commercial Center'] - n['Transit Hub'] >= -adjacency_limit, \"Adjacency_Lower\")\n\n    # Constraint 4: Operational Cluster Capacity Constraints\n    # Cluster 1: Commercial Center, Tourist Area\n    model.addConstr(n['Commercial Center'] + n['Tourist Area'] <= cluster_capacity, \"Cluster1_Capacity\")\n    # Cluster 2: University City, Tech Park, Transit Hub\n    model.addConstr(n['University City'] + n['Tech Park'] + n['Transit Hub'] <= cluster_capacity, \"Cluster2_Capacity\")\n    \n    # --- 6. Solve the Model ---\n    model.optimize()\n\n    # --- 7. Return Results ---\n    if model.Status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.Status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_scooter_deployment()\n    print(result)\n",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "QP",
        "industry_sector": "Transportation",
        "reason": "The problem involves allocating a fixed number of scooters (resources) to different zones to minimize an imbalance objective. The objective function is quadratic (sum of squared differences), and the constraints are linear, making it a Quadratic Programming problem. The application is clearly within the shared mobility and fleet deployment context, which falls under the transportation sector."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D054",
    "description": "A logistics company needs to optimize the loading of 5 different types of cargo items (A, B, C, D, E) onto a single truck with a maximum weight capacity of 2000 kg. Each item has a base profit value and weight, but certain item combinations generate additional synergy profits when transported together (e.g., perishable items with refrigeration equipment). The item characteristics and synergy matrix are given below:\n\nItem Data:\n| Item | Weight (kg) | Base Profit ($) |\n|------|------------|----------------|\n| A    | 400        | 120            |\n| B    | 600        | 180            |\n| C    | 300        | 90             |\n| D    | 500        | 150            |\n| E    | 700        | 210            |\n\nSynergy Profit Matrix ($):\n|   | A  | B  | C  | D  | E  |\n|---|---|---|---|---|---|\n| A | 0  | 25 | 15 | 0  | -10|\n| B | 25 | 0  | 30 | 20 | 0  |\n| C | 15 | 30 | 0  | 10 | 5  |\n| D | 0  | 20 | 10 | 0  | 15 |\n| E |-10 | 0  | 5  | 15 | 0  |\n\nNegative values indicate incompatibility costs (e.g., item A and E require separate storage space).",
    "ground_truth": 665.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_logistics_knapsack(\n    items=['A', 'B', 'C', 'D', 'E'],\n    weights={'A': 400, 'B': 600, 'C': 300, 'D': 500, 'E': 700},\n    base_profits={'A': 120, 'B': 180, 'C': 90, 'D': 150, 'E': 210},\n    synergy={\n        'A': {'A': 0, 'B': 25, 'C': 15, 'D': 0, 'E': -10},\n        'B': {'A': 25, 'B': 0, 'C': 30, 'D': 20, 'E': 0},\n        'C': {'A': 15, 'B': 30, 'C': 0, 'D': 10, 'E': 5},\n        'D': {'A': 0, 'B': 20, 'C': 10, 'D': 0, 'E': 15},\n        'E': {'A': -10, 'B': 0, 'C': 5, 'D': 15, 'E': 0}\n    },\n    truck_capacity=2000\n):\n    \"\"\"\n    Solves the logistics knapsack problem.\n    \"\"\"\n    # Create a new model\n    model = gp.Model(\"Logistics_Knapsack\")\n\n    # Create binary decision variables for each item\n    x = model.addVars(items, vtype=GRB.BINARY, name=\"select\")\n\n    # Set objective: maximize total profit (base + synergy)\n    base_profit = gp.quicksum(base_profits[i] * x[i] for i in items)\n    synergy_profit = gp.quicksum(synergy[i][j] * x[i] * x[j] for i in items for j in items if i <= j)\n    model.setObjective(base_profit + synergy_profit, GRB.MAXIMIZE)\n\n    # Add weight capacity constraint\n    model.addConstr(gp.quicksum(weights[i] * x[i] for i in items) <= truck_capacity, \"weight_limit\")\n\n    # Optimize model\n    model.optimize()\n\n    # Return results\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_logistics_knapsack()\n    print(result)\n",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Knapsack",
        "modeling_type": "QP",
        "industry_sector": "Logistics",
        "reason": "The problem involves selecting items to maximize profit within a weight capacity, which is a classic knapsack problem. The objective function includes quadratic terms for synergy profits (x[i]*x[j]), making it a Quadratic Program. The application is clearly in optimizing cargo loading for a logistics company."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D039",
    "description": "SupplyChain Logistics Co. is responsible for distributing two types of products, Product A and Product B. The company needs to meet the market demand for these two products across four quarters of the year (Q1, Q2, Q3, Q4) while aiming to minimize the total annual operating costs, which include labor costs and inventory holding costs. The demand for Product A in the four quarters is 800, 600, 700, and 900 units, respectively; the demand for Product B in the four quarters is 500, 400, 600, and 300 units, respectively.Workers operate on a fixed rotation schedule: each worker works for three consecutive quarters and then takes one quarter off. To ensure that workers take their leave in the same quarter each year, workers are divided into four groups, taking leave in Q1, Q2, Q3, and Q4, respectively. The company must decide the number of workers in each group, and this number remains constant throughout the year. Each on-duty worker, in a working quarter, can only choose to handle one type of product: either a maximum of 60 units of Product A or a maximum of 40 units of Product B. They cannot split their capacity to handle both products within the same quarter. The wage for each worker per working quarter is $600, so the annual wage for each worker is $1800.At the end of each quarter, an inventory holding cost of $70 per unit is incurred for any remaining product (either A or B) in the warehouse. It is assumed that at the beginning of the first quarter of the first year, the initial inventory for both Product A and Product B is 0 units. To simplify the model, it is assumed that at the end of the fourth quarter each year, the inventory for both Product A and Product B must be 0 units.The company's optimization objective is: to determine the number of workers in each rotation group and how to assign on-duty workers to produce Product A and Product B each quarter, in order to meet all quarterly product demands and minimize the total annual operating costs (including the total wages for all registered workers and the total inventory holding costs incurred at the end of all quarters).",
    "ground_truth": 59400.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_workforce_planning_optimization(\n    HandleProductPerWorkerPerQuarter=[60, 40],\n    WorkerCostPerYear=1800,\n    InventoryHoldingCost=70,\n    Demand=[[800, 600, 700, 900], [500, 400, 600, 300]]\n):\n    \"\"\"\n    Models and solves the supply chain logistics and workforce planning problem.\n    \"\"\"\n    # Create a new model\n    model = gp.Model(\"SupplyChain_Logistics_Workforce_Planning\")\n\n    # Sets\n    P = range(len(HandleProductPerWorkerPerQuarter))  # Products\n    Q = range(len(Demand[0]))  # Quarters\n    G = range(len(Demand[0]))  # Worker Groups\n\n    # Decision Variables\n    WorkersInGroup = model.addVars(G, vtype=GRB.INTEGER, lb=0, name=\"WorkersInGroup\")\n    ProductProduced = model.addVars(P, Q, vtype=GRB.INTEGER, lb=0, name=\"ProductProduced\")\n    ProductStorage = model.addVars(P, Q, vtype=GRB.INTEGER, lb=0, name=\"ProductStorage\")\n    WorkersOnDuty = model.addVars(G, P, Q, vtype=GRB.INTEGER, lb=0, name=\"WorkersOnDuty\")\n\n    # Objective Function: Minimize total cost\n    labor_cost = gp.quicksum(WorkersInGroup[g] * WorkerCostPerYear for g in G)\n    inventory_cost = gp.quicksum(ProductStorage[p, q] * InventoryHoldingCost for p in P for q in Q)\n    total_cost = labor_cost + inventory_cost\n\n    model.setObjective(total_cost, GRB.MINIMIZE)\n\n    # Constraints\n    # 1. Demand constraints\n    for p in P:\n        # First quarter (no previous inventory)\n        model.addConstr(\n            ProductProduced[p, 0] - ProductStorage[p, 0] >= Demand[p][0],\n            f\"Demand_P{p}_Q1\"\n        )\n\n        # Subsequent quarters\n        for q in range(1, 4):\n            model.addConstr(\n                ProductProduced[p, q] + ProductStorage[p, q - 1] - ProductStorage[p, q] >= Demand[p][q],\n                f\"Demand_P{p}_Q{q + 1}\"\n            )\n\n    # 2. Production handling constraints\n    for p in P:\n        for q in Q:\n            model.addConstr(\n                gp.quicksum(WorkersOnDuty[g, p, q] * HandleProductPerWorkerPerQuarter[p] for g in G) >= ProductProduced[p, q],\n                f\"Production_P{p}_Q{q + 1}\"\n            )\n\n    # 3. Worker group constraints\n    for g in G:\n        for q in Q:\n            # Workers in group g are off-duty in quarter (g+1)%4\n            if q == g:\n                # Workers in this group are on leave this quarter\n                for p in P:\n                    model.addConstr(WorkersOnDuty[g, p, q] == 0, f\"OffDuty_G{g + 1}_Q{q + 1}\")\n            else:\n                # Workers on duty can only handle one product type per quarter\n                model.addConstr(\n                    gp.quicksum(WorkersOnDuty[g, p, q] for p in P) <= WorkersInGroup[g],\n                    f\"WorkerCapacity_G{g + 1}_Q{q + 1}\"\n                )\n\n    # 4. End of year inventory must be zero\n    for p in P:\n        model.addConstr(ProductStorage[p, 3] == 0, f\"EndYearInventory_P{p}\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Return Results\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_workforce_planning_optimization()\n    print(result)\n",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Workforce Planning",
        "modeling_type": "MILP",
        "industry_sector": "Supply Chain",
        "reason": "The problem involves determining the number of workers in different groups and their assignments to products over time, which falls under workforce planning. It also includes managing product inventory and meeting demand, which are core supply chain activities. The solver uses integer variables for workers and products, linear constraints, and a linear objective function, making it a Mixed-Integer Linear Program (MILP)."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D060",
    "description": "A regional logistics company needs to optimize its cargo transportation network involving 3 supply points (S1, S2, S3), 2 transshipment hubs (H1, H2), and 4 demand points (D1, D2, D3, D4). The supply capacities are 200, 150, and 180 units respectively. Demand requirements are 120, 90, 110, and 130 units respectively. Transportation costs (per unit) between nodes are: S1-H1=5, S1-H2=7, S2-H1=6, S2-H2=8, S3-H1=4, S3-H2=5, H1-D1=3, H1-D2=4, H1-D3=5, H1-D4=6, H2-D1=4, H2-D2=3, H2-D3=6, H2-D4=5. All routes have unlimited capacity. The objective is to minimize total transportation costs while meeting all supply and demand constraints.",
    "ground_truth": 4190.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_transportation_problem(\n    supply_nodes=['S1', 'S2', 'S3'],\n    hub_nodes=['H1', 'H2'],\n    demand_nodes=['D1', 'D2', 'D3', 'D4'],\n    supply_capacity={'S1': 200, 'S2': 150, 'S3': 180},\n    demand_requirement={'D1': 120, 'D2': 90, 'D3': 110, 'D4': 130},\n    transport_cost={\n        ('S1', 'H1'): 5, ('S1', 'H2'): 7,\n        ('S2', 'H1'): 6, ('S2', 'H2'): 8,\n        ('S3', 'H1'): 4, ('S3', 'H2'): 5,\n        ('H1', 'D1'): 3, ('H1', 'D2'): 4, ('H1', 'D3'): 5, ('H1', 'D4'): 6,\n        ('H2', 'D1'): 4, ('H2', 'D2'): 3, ('H2', 'D3'): 6, ('H2', 'D4'): 5,\n    }\n):\n    \"\"\"Solve the cargo transportation network optimization problem.\"\"\"\n    model = gp.Model(\"CargoTransportation\")\n\n    flow = model.addVars(transport_cost.keys(), lb=0, vtype=GRB.CONTINUOUS, name=\"flow\")\n\n    model.setObjective(\n        gp.quicksum(flow[i, j] * transport_cost[i, j] for i, j in transport_cost.keys()),\n        GRB.MINIMIZE\n    )\n\n    for s in supply_nodes:\n        model.addConstr(gp.quicksum(flow[s, h] for h in hub_nodes) <= supply_capacity[s])\n\n    for h in hub_nodes:\n        model.addConstr(\n            gp.quicksum(flow[s, h] for s in supply_nodes) == gp.quicksum(flow[h, d] for d in demand_nodes)\n        )\n\n    for d in demand_nodes:\n        model.addConstr(gp.quicksum(flow[h, d] for h in hub_nodes) == demand_requirement[d])\n\n    model.optimize()\n\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_transportation_problem()\n    print(result)",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Network Flow",
        "modeling_type": "LP",
        "industry_sector": "Logistics",
        "reason": "The problem involves optimizing the flow of goods through a network of supply points, hubs, and demand points to minimize transportation costs, which is a classic network flow problem. The solver uses continuous variables and linear constraints, making it a Linear Program (LP). The application is directly related to cargo transportation and supply chain, fitting within the logistics sector."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D067",
    "description": "A manufacturing company needs to procure 5 key components (C1-C5, fractional procurement allowed) from 3 potential suppliers (S1-S3) for the next quarter. Each supplier has different pricing, reliability scores (0-1 scale), and maximum supply capacities. The company has forecasted component demands and wants to minimize total procurement cost while ensuring: (1) at least 60% of each component comes from suppliers with reliability ≥0.8, (2) no more than 40% of total spend goes to any single supplier, and (3) all demand is met. The quarterly demand is [1200, 800, 1500, 900, 600] units for C1-C5 respectively. Supplier data: S1 offers prices [12,15,18,20,22] $/unit with reliability 0.85 and capacity 2000 units; S2 offers [14,16,17,19,21] $/unit with reliability 0.75 and capacity 1800 units; S3 offers [13,14,19,18,20] $/unit with with reliability 0.90 and capacity 2500 units.",
    "ground_truth": 80740.21739,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_procurement_problem(\n    components=[1, 2, 3, 4, 5],\n    suppliers=[1, 2, 3],\n    demand={1: 1200, 2: 800, 3: 1500, 4: 900, 5: 600},\n    price_data=None,\n    reliability={1: 0.85, 2: 0.75, 3: 0.90},\n    capacity={1: 2000, 2: 1800, 3: 2500},\n    min_reliable_frac=0.6,\n    max_spend_frac=0.4\n):\n    \"\"\"Solve the supplier procurement optimization problem using Gurobi.\"\"\"\n    if price_data is None:\n        price = {\n            1: {1: 12, 2: 15, 3: 18, 4: 20, 5: 22},\n            2: {1: 14, 2: 16, 3: 17, 4: 19, 5: 21},\n            3: {1: 13, 2: 14, 3: 19, 4: 18, 5: 20}\n        }\n    else:\n        price = price_data\n\n    model = gp.Model(\"ComponentProcurement\")\n\n    q = model.addVars(suppliers, components, name=\"q\", lb=0)\n\n    total_cost = gp.quicksum(price[s][c] * q[s, c] for s in suppliers for c in components)\n    model.setObjective(total_cost, GRB.MINIMIZE)\n\n    for c in components:\n        model.addConstr(gp.quicksum(q[s, c] for s in suppliers) == demand[c])\n\n    for s in suppliers:\n        model.addConstr(gp.quicksum(q[s, c] for c in components) <= capacity[s])\n\n    reliable_suppliers = [s for s in suppliers if reliability[s] >= 0.8]\n    for c in components:\n        model.addConstr(gp.quicksum(q[s, c] for s in reliable_suppliers) >= min_reliable_frac * demand[c])\n\n    total_spend = gp.quicksum(price[s][c] * q[s, c] for s in suppliers for c in components)\n    for s in suppliers:\n        supplier_spend = gp.quicksum(price[s][c] * q[s, c] for c in components)\n        model.addConstr(supplier_spend <= max_spend_frac * total_spend)\n\n    model.optimize()\n\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_procurement_problem()\n    print(result)\n",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Manufacturing",
        "reason": "The problem involves allocating procurement quantities of components from various suppliers to meet demand and satisfy constraints, which is a classic resource allocation problem. Since fractional procurement is allowed and all relationships are linear, it's formulated as a Linear Program. The context of procuring components for production places it in the manufacturing sector."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D010",
    "description": "A city plans to establish a low-altitude drone delivery network covering a 100×100 area (with both horizontal and vertical coordinates ranging from [0, 100]). There are 8 demand points within this area, with coordinates at (10, 20), (25, 60), (40, 80), (65, 50), (80, 20), (15, 45), (70, 75), and (90, 90). The goal is to select 2 drone logistics hubs at arbitrary locations within the area. What is the minimum possible value of the maximum Euclidean distance from all demand points to their nearest drone logistics hub?",
    "ground_truth": 35.35170935,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_drone_hub_location(\n    demand_nodes=[(10, 20), (25, 60), (40, 80), (65, 50), (80, 20), (15, 45),\n                  (70, 75), (90, 90)],\n    num_hubs=2,\n    hub_coordinates_range=[[0, 100], [0, 100]],\n    big_m=20000\n):\n    \"\"\"\n    Models and solves the drone hub location problem (a type of P-Center problem\n    in a continuous space).\n    \"\"\"\n    # --- 1. Model Creation ---\n    model = gp.Model(\"DroneHubLocation\")\n    # This parameter is crucial for Gurobi to solve non-convex quadratic problems\n    model.Params.NonConvex = 2\n\n    # --- 2. Sets and Parameters ---\n    num_demands = len(demand_nodes)\n    hubs = range(num_hubs)\n    demands = range(num_demands)\n    xl, xu = hub_coordinates_range[0]\n    yl, yu = hub_coordinates_range[1]\n\n    # --- 3. Decision Variables ---\n    # hub_x, hub_y: coordinates of the selected hubs\n    hub_x = model.addVars(hubs, lb=xl, ub=xu, name=\"HubX\")\n    hub_y = model.addVars(hubs, lb=yl, ub=yu, name=\"HubY\")\n    # a[i,j]: 1 if demand node j is assigned to hub i, 0 otherwise\n    a = model.addVars(hubs, demands, vtype=GRB.BINARY, name=\"Assignment\")\n    # z: the maximum distance from any demand node to its assigned hub\n    z = model.addVar(vtype=GRB.CONTINUOUS, name=\"MaxDistance\")\n\n    # --- 4. Objective Function ---\n    # Minimize the maximum distance (z)\n    model.setObjective(z, GRB.MINIMIZE)\n\n    # --- 5. Constraints ---\n    # Constraint 1: Each demand node must be assigned to exactly one hub\n    for j in demands:\n        model.addConstr(gp.quicksum(a[i, j] for i in hubs) == 1, f\"Assign_{j}\")\n\n    # Constraint 2: Link the maximum distance 'z' to the hub locations.\n    # This is a non-convex quadratic constraint of the form:\n    # (distance_squared) <= z^2, which only applies if a[i,j] = 1.\n    for i in hubs:\n        for j in demands:\n            x_j, y_j = demand_nodes[j]\n            dx = hub_x[i] - x_j\n            dy = hub_y[i] - y_j\n            model.addConstr(dx * dx + dy * dy <= z * z + big_m * (1 - a[i, j]),\n                            f\"Distance_{i}_{j}\")\n\n    # --- 6. Solve the Model ---\n    model.setParam(\"OutputFlag\", 0)  # Suppress Gurobi output\n    model.optimize()\n\n    # --- 7. Return Results ---\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\n# Run the solver function\nif __name__ == \"__main__\":\n    result = solve_drone_hub_location()\n    print(result)\n",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Facility Location",
        "modeling_type": "MINLP",
        "industry_sector": "Logistics",
        "reason": "The problem involves selecting optimal locations for drone logistics hubs to minimize the maximum distance to demand points, which is a classic P-Center Facility Location problem. The formulation includes continuous variables for hub coordinates, binary variables for assignments, and quadratic constraints, making it a Mixed-Integer Non-Linear Program (MINLP)."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D032",
    "description": "A fruit processing company, NatureBounty, specializes in producing two product lines: packaged fresh apples and bottled apple juice. NatureBounty grades apples on a scale of 1 (poor) to 10 (excellent). The company currently has 90,000 lbs of grade 7 apples and 110,000 lbs of grade 4 apples in inventory. To maintain product quality, the average grade of apples sold in packages must be at least 5, and the average grade of apples used for juice production must be at least 6. Additionally, the company has a production capacity constraint: it can process no more than 150,000 lbs of apples in total due to equipment limitations. Each pound of apples used for juice generates a revenue of $1.10 and incurs a variable cost of $0.80. Each pound of apples sold in packages generates a revenue of $0.35 and incurs a variable cost of $0.12. The company also has a marketing constraint: at least 20% of the total processed apples must be sold in packages to meet market demand. How to help NatureBounty maximize its profit while adhering to all constraints.",
    "ground_truth": 42900.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_apple_processing_optimization(\n    Inventory=[90000, 110000],\n    Revenue=[0.35, 1.10],\n    VariableCost=[0.12, 0.80],\n    AverageGrade=[5, 6],\n    MaxProcessingCapacity=150000,\n    MinPackagePercentage=0.20,\n    Grades=[7, 4]\n):\n    # Create a new model\n    model = gp.Model(\"Apple Processing Optimization\")\n\n    # Sets\n    Products = range(len(Revenue))\n\n    # Profit per unit for each product\n    Profit = [Revenue[p] - VariableCost[p] for p in Products]\n\n    # Create decision variables dictionary\n    ProcessedAmount = {}\n    for p in Products:\n        for g_idx, g in enumerate(Grades):\n            ProcessedAmount[p, g_idx] = model.addVar(\n                vtype=GRB.CONTINUOUS,\n                name=f\"ProcessedAmount_{p+1}_{g}\"\n            )\n\n    # Objective: Maximize profit\n    obj = gp.quicksum(\n        Profit[p] * ProcessedAmount[p, g_idx]\n        for p in Products\n        for g_idx in range(len(Grades))\n    )\n    model.setObjective(obj, GRB.MAXIMIZE)\n\n    # Constraint 1: Inventory constraint\n    for g_idx in range(len(Grades)):\n        model.addConstr(\n            gp.quicksum(ProcessedAmount[p, g_idx] for p in Products) <= Inventory[g_idx],\n            f\"Inventory_{Grades[g_idx]}\"\n        )\n\n    # Constraint 2: Average grade constraint\n    for p in Products:\n        model.addConstr(\n            AverageGrade[p] * gp.quicksum(ProcessedAmount[p, g_idx] for g_idx in range(len(Grades))) <=\n            gp.quicksum(Grades[g_idx] * ProcessedAmount[p, g_idx] for g_idx in range(len(Grades))),\n            f\"AverageGrade_{p+1}\"\n        )\n\n    # Constraint 3: Processing capacity constraint\n    model.addConstr(\n        gp.quicksum(ProcessedAmount[p, g_idx] for p in Products for g_idx in range(len(Grades))) <= MaxProcessingCapacity,\n        \"ProcessingCapacity\"\n    )\n\n    # Constraint 4: Marketing constraint\n    model.addConstr(\n        gp.quicksum(ProcessedAmount[0, g_idx] for g_idx in range(len(Grades))) >=\n        MinPackagePercentage * gp.quicksum(ProcessedAmount[p, g_idx]\n                                           for p in Products\n                                           for g_idx in range(len(Grades))),\n        \"Marketing\"\n    )\n\n    # Optimize the model\n    model.optimize()\n\n    # Return results\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.objVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_apple_processing_optimization()\n    print(result)",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Food Processing",
        "reason": "The problem involves allocating different grades of apples to two product lines (packaged fresh apples and bottled apple juice) to maximize profit, subject to inventory, quality, capacity, and marketing constraints. All variables are continuous, and the objective and constraints are linear, fitting the characteristics of a Linear Program."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D076",
    "description": "A regional grocery chain is launching a new energy drink product and needs to optimally allocate initial stock to its stores. There are 6 stores (S1-S6) with varying characteristics. Each store has a known customer traffic (daily visits: S1-1200, S2-800, S3-1500, S4-900, S5-1100, S6-700), shelf space allocation (units: S1-50, S2-30, S3-60, S4-35, S5-45, S6-25), and historical sales similarity score for similar products (0-1 scale: S1-0.8, S2-0.6, S3-0.9, S4-0.7, S5-0.75, S6-0.5). The warehouse has 300 units available for initial distribution. There are two types of display setups: standard (costs $5 per store) and promotional (costs $15 per store but increases effective shelf space by 20%). The total display budget is $120. The goal is to maximize expected product exposure, calculated as: (customer traffic) × (units allocated) × (sales similarity score).",
    "ground_truth": 253590.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_energy_drink_allocation(\n    stores=['S1', 'S2', 'S3', 'S4', 'S5', 'S6'],\n    customer_traffic={\n        'S1': 1200,\n        'S2': 800,\n        'S3': 1500,\n        'S4': 900,\n        'S5': 1100,\n        'S6': 700\n    },\n    shelf_space={\n        'S1': 50,\n        'S2': 30,\n        'S3': 60,\n        'S4': 35,\n        'S5': 45,\n        'S6': 25\n    },\n    similarity_score={\n        'S1': 0.8,\n        'S2': 0.6,\n        'S3': 0.9,\n        'S4': 0.7,\n        'S5': 0.75,\n        'S6': 0.5\n    },\n    total_inventory=300,\n    budget=120,\n    standard_cost=5,\n    promotional_cost=15,\n    space_multiplier=1.2\n):\n    \"\"\"\n    Solves the energy drink allocation problem using Gurobi optimizer.\n    Maximizes expected product exposure under inventory, budget, and shelf space constraints.\n    \"\"\"\n    # Create model\n    model = gp.Model(\"EnergyDrinkAllocation\")\n\n    # Decision variables\n    allocate_units = model.addVars(stores, vtype=GRB.INTEGER, name=\"units\")\n    display_type = model.addVars(stores, vtype=GRB.BINARY, name=\"display\")\n\n    # Objective: Maximize expected exposure\n    exposure = gp.quicksum(customer_traffic[s] * allocate_units[s] *\n                           similarity_score[s] for s in stores)\n    model.setObjective(exposure, GRB.MAXIMIZE)\n\n    # Constraints\n    # Inventory limit\n    model.addConstr(\n        gp.quicksum(allocate_units[s] for s in stores) <= total_inventory,\n        \"inventory_limit\")\n\n    # Budget constraint\n    model.addConstr(\n        gp.quicksum(standard_cost * (1 - display_type[s]) +\n                    promotional_cost * display_type[s]\n                    for s in stores) <= budget, \"budget_limit\")\n\n    # Shelf space constraints\n    for s in stores:\n        model.addConstr(\n            allocate_units[s] <= shelf_space[s] *\n            (1 + (space_multiplier - 1) * display_type[s]),\n            f\"shelf_space_{s}\")\n\n    # Optimize model\n    model.optimize()\n\n    # Return results\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\n# Execute the function\nif __name__ == \"__main__\":\n    result = solve_energy_drink_allocation()\n    print(result)\n",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MILP",
        "industry_sector": "Retail",
        "reason": "The problem involves allocating a limited number of energy drink units and a display budget across multiple stores to maximize exposure. The decision variables include integer units to allocate and binary choices for display types, leading to a Mixed-Integer Linear Programming (MILP) formulation. The application is clearly within the retail sector, specifically for a grocery chain."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D016",
    "description": "The Health Bureau of a city, in order to strengthen primary healthcare services, has equipped a mobile medical vehicle to regularly provide basic medical check-ups and medicines to various communities in the suburbs. To improve service efficiency, it is necessary to optimize the route of the mobile medical vehicle. The starting point of the medical vehicle is the Central City Hospital, located at coordinates (0, 0). The location information of the 10 communities to be served is as follows:\n\n| COMMUNITY ID | (x, y)      |\n|--------------|-------------|\n| C1           | (3.5, 4.2)  |\n| C2           | (-2.1, 5.6) |\n| C3           | (4.8, -3.2) |\n| C4           | (-3.6, -2.8)|\n| C5           | (5.2, 2.4)  |\n| C6           | (-4.1, 3.7) |\n| C7           | (2.8, -4.5) |\n| C8           | (6.3, -2.1) |\n| C9           | (-5.2, -1.8)|\n| C10          | (3.9, 5.8)  |\n\nWhat is the shortest travel distance for the medical vehicle to start from the Central City Hospital, visit all communities, and return to the Central City Hospital? (Distance is calculated as the straight-line distance.)",
    "ground_truth": 39.1214741163,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\nimport math\n\n\ndef solve_tsp(\n    coordinates=[(0, 0), (3.5, 4.2), (-2.1, 5.6), (4.8, -3.2), (-3.6, -2.8),\n                 (5.2, 2.4), (-4.1, 3.7), (2.8, -4.5), (6.3, -2.1),\n                 (-5.2, -1.8), (3.9, 5.8)]):\n    \"\"\"\n    Solves the Traveling Salesperson Problem (TSP) for community health services.\n    \"\"\"\n    community_num = len(coordinates) - 1\n    nodes = range(community_num + 1\n                  )  # 0 is the central hospital, 1-10 are communities\n\n    # Calculate distance matrix\n    def calculate_distance(coord1, coord2):\n        return math.sqrt((coord1[0] - coord2[0])**2 +\n                         (coord1[1] - coord2[1])**2)\n\n    distance = {}\n    for i in nodes:\n        for j in nodes:\n            if i != j:\n                distance[i,\n                         j] = calculate_distance(coordinates[i], coordinates[j])\n\n    # Create a new model\n    model = gp.Model(\"TSP\")\n\n    # Decision variables: x[i,j] = 1 if the path goes from i to j\n    x = {}\n    for i in nodes:\n        for j in nodes:\n            if i != j:\n                x[i, j] = model.addVar(vtype=GRB.BINARY, name=f'x_{i}_{j}')\n\n    # Set objective: minimize total distance\n    objective = gp.quicksum(distance[i, j] * x[i, j] for i in nodes\n                            for j in nodes if i != j)\n    model.setObjective(objective, GRB.MINIMIZE)\n\n    # Constraint 1: Each node must be visited exactly once\n    for j in nodes:\n        model.addConstr(gp.quicksum(x[i, j] for i in nodes if i != j) == 1,\n                        name=f'visit_to_{j}')\n\n    # Constraint 2: Must leave each node exactly once\n    for i in nodes:\n        model.addConstr(gp.quicksum(x[i, j] for j in nodes if i != j) == 1,\n                        name=f'leave_from_{i}')\n\n    # Constraint 3: Subtour elimination using subset constraints\n    def find_subtours(edges):\n        # Create adjacency list\n        adj = {i: [] for i in nodes}\n        for i, j in edges:\n            adj[i].append(j)\n\n        # Find all subtours\n        unvisited = set(nodes)\n        subtours = []\n        while unvisited:\n            # Start from any unvisited node\n            current = next(iter(unvisited))\n            subtour = []\n            while current in unvisited:\n                unvisited.remove(current)\n                subtour.append(current)\n                # Move to next node in path\n                next_nodes = adj.get(current, [])\n                if not next_nodes:\n                    break\n                current = next_nodes[0]\n            if len(subtour) < len(nodes):\n                subtours.append(subtour)\n        return subtours\n\n    # Callback function for lazy constraints\n    def subtour_cb(model, where):\n        if where == GRB.Callback.MIPSOL:\n            # Get values of decision variables\n            x_vals = model.cbGetSolution(model._vars)\n            edges = [(i, j) for i in nodes for j in nodes\n                     if i != j and x_vals[i, j] > 0.5]\n\n            # Find subtours\n            subtours = find_subtours(edges)\n\n            # Add subtour elimination constraints\n            for S in subtours:\n                if len(S) < len(nodes):\n                    model.cbLazy(\n                        gp.quicksum(x[i, j] for i in S for j in S\n                                    if i != j) <= len(S) - 1)\n\n    # Enable lazy constraints\n    model._vars = x\n    model.Params.lazyConstraints = 1\n\n    # Optimize model with callback\n    model.optimize(subtour_cb)\n\n    # Return results\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\n# Run the solver function\nif __name__ == \"__main__\":\n    result = solve_tsp()\n    print(result)\n",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Routing",
        "modeling_type": "MILP",
        "industry_sector": "Health",
        "reason": "The problem involves finding the shortest route for a mobile medical vehicle to visit multiple communities and return to its starting point, which is a classic Traveling Salesperson Problem (TSP), a type of routing problem. The solver uses binary decision variables and linear constraints, including lazy subtour elimination constraints, making it a Mixed-Integer Linear Program (MILP)."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D027",
    "description": "A small-scale bakery operates in four towns: Greenville, Springfield, Riverside, and Hilltop. The bakery produces fresh bread, which is then delivered to local stores located in Maplewood, Oakdale, Pineville, Cedarhurst, and Brookside. The number of loaves of bread available at each bakery is provided in Table 1. Each store requires a specific number of loaves to meet daily customer demand, as shown in Table 2. The distances (in kilometers) between the bakeries and stores are given in Table 3.  Assuming the delivery cost (in USD) for each loaf of bread is calculated as the square root of the distance between the origin and destination towns, determine the optimal delivery schedule that minimizes total transportation costs while meeting all store requirements.  \n\nTable 1: Bread Availability at Bakeries  \n| Bakery       | Loaves Available |  \n|--------------|------------------|  \n| Greenville   | 200              |  \n| Springfield  | 150              |  \n| Riverside    | 250              |  \n| Hilltop      | 180              |  \n\nTable 2: Bread Requirements at Stores  \n| Store        | Loaves Required |  \n|--------------|-----------------|  \n| Maplewood    | 120             |  \n| Oakdale      | 100             |  \n| Pineville    | 130             |  \n| Cedarhurst   | 90              |  \n| Brookside    | 80              |  \n\nTable 3: Distances Between Bakeries and Stores (km)  \n| From / To    | Maplewood | Oakdale | Pineville | Cedarhurst | Brookside |  \n|--------------|-----------|---------|-----------|------------|-----------|  \n| Greenville   | 10        | 15      | 20        | 25         | 30        |  \n| Springfield  | 12        | 8       | 18        | 22         | 28        |  \n| Riverside    | 14        | 10      | 16        | 20         | 26        |  \n| Hilltop      | 16        | 12      | 14        | 18         | 24        |",
    "ground_truth": 1947.6705256188,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\nimport math\n\n\ndef solve_bakery_distribution(\n    BakerySupply=[200, 150, 250, 180],\n    StoreDemand=[120, 100, 130, 90, 80],\n    ShippingDistance=[[10, 15, 20, 25, 30], [12, 8, 18, 22, 28],\n                      [14, 10, 16, 20, 26], [16, 12, 14, 18, 24]]):\n    \"\"\"\n    Solves the bakery distribution (transportation) problem.\n    \"\"\"\n    # --- 1. Model Creation ---\n    model = gp.Model(\"Bakery Distribution Optimization\")\n\n    # --- 2. Parameters & Sets ---\n    BakeryNum = len(BakerySupply)\n    StoreNum = len(StoreDemand)\n    Bakeries = range(BakeryNum)\n    Stores = range(StoreNum)\n\n    # Calculate shipping costs with square roots\n    ShippingCost = [[math.sqrt(dist) for dist in row]\n                    for row in ShippingDistance]\n\n    # --- 3. Decision Variables ---\n    ShipAmount = model.addVars(Bakeries,\n                               Stores,\n                               vtype=GRB.INTEGER,\n                               name=\"ShipAmount\")\n\n    # --- 4. Objective Function ---\n    # Minimize total transportation cost\n    model.setObjective(\n        gp.quicksum(ShippingCost[b][s] * ShipAmount[b, s] for b in Bakeries\n                    for s in Stores), GRB.MINIMIZE)\n\n    # --- 5. Constraints ---\n    # Constraint 1: Bakery supply constraint\n    model.addConstrs(\n        (gp.quicksum(ShipAmount[b, s] for s in Stores) <= BakerySupply[b]\n         for b in Bakeries),\n        name=\"BakerySupply\")\n\n    # Constraint 2: Store demand constraint\n    model.addConstrs(\n        (gp.quicksum(ShipAmount[b, s] for b in Bakeries) == StoreDemand[s]\n         for s in Stores),\n        name=\"StoreDemand\")\n\n    # --- 6. Solve the Model ---\n    model.optimize()\n\n    # --- 7. Return Results ---\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_bakery_distribution()\n    print(result)",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Transportation Problem",
        "modeling_type": "MILP",
        "industry_sector": "Food & Beverage",
        "reason": "The problem involves minimizing the cost of shipping goods (bread) from multiple origins (bakeries) to multiple destinations (stores) to meet demand while respecting supply limits, which is a classic transportation problem. The decision variables are integers (number of loaves), and the objective function is linear, making it a Mixed-Integer Linear Program. The application is clearly within the food production and distribution industry."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D022",
    "description": "HAPPY pharmaceutical produces the drug Panacea from four chemicals. Today they must produce 1,000 lb of the drug. The three active ingredients in Panacea are A, B, and C. By weight, at least 8% of Panacea must consist of A, at least 4% of B, and at least 2% of C. The cost per pound of each chemical and the amount of each active ingredient in 1 lb of each chemical are given in Table as follows:\n\n| Chemical | Cost ($ per Lb) | A    | B    | C    |\n|----------|-----------------|------|------|------|\n| 1        | 8               | .03  | .02  | .01  |\n| 2        | 10              | .06  | .04  | .01  |\n| 3        | 11              | .10  | .03  | .04  |\n| 4        | 14              | .12  | .09  | .04  |\n\nIt is necessary that at least 100 lb of chemical 2 be used. Find a solution would determine the cheapest way of producing today's batch of Panacea.",
    "ground_truth": 10637.5,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_chemical_mixing(\n    chemical_cost=[8, 10, 11, 14],\n    ingredient_content=[\n        [0.03, 0.02, 0.01],  # Chemical 1\n        [0.06, 0.04, 0.01],  # Chemical 2\n        [0.10, 0.03, 0.04],  # Chemical 3\n        [0.12, 0.09, 0.04]  # Chemical 4\n    ],\n    ingredient_min=[0.08, 0.04, 0.02],\n    chemical_min=[0, 100, 0, 0],\n    produce_target=1000):\n    \"\"\"\n    Solves the chemical mixing problem to minimize cost.\n    \"\"\"\n    # --- 1. Model Creation ---\n    model = gp.Model(\"ChemicalMixing\")\n\n    # --- 2. Parameters & Sets ---\n    chemicals = range(len(chemical_cost))\n    ingredients = range(len(ingredient_min))\n\n    # --- 3. Decision Variables ---\n    chemical_amount = model.addVars(chemicals, lb=0, name=\"ChemicalAmount\")\n\n    # --- 4. Objective Function ---\n    # Minimize the total cost\n    model.setObjective(chemical_amount.prod(chemical_cost), GRB.MINIMIZE)\n\n    # --- 5. Constraints ---\n    # Constraint 1: Ingredient minimum content\n    model.addConstrs(\n        (gp.quicksum(ingredient_content[i][j] * chemical_amount[i]\n                     for i in chemicals) >= ingredient_min[j] * produce_target\n         for j in ingredients), \"IngredientMin\")\n\n    # Constraint 2: Chemical minimum content\n    model.addConstrs((chemical_amount[i] >= chemical_min[i] for i in chemicals),\n                     \"ChemicalMin\")\n\n    # Constraint 3: Total amount constraint\n    model.addConstr(\n        chemical_amount.sum() == produce_target,\n        \"TotalAmount\")\n\n    # --- 6. Solve the Model ---\n    model.optimize()\n\n    # --- 7. Return Results ---\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\n# Run the solver function\nif __name__ == \"__main__\":\n    result = solve_chemical_mixing()\n    print(result)",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Blending",
        "modeling_type": "LP",
        "industry_sector": "Manufacturing",
        "reason": "The problem involves mixing different chemicals to produce a drug, satisfying specific ingredient percentages and minimum usage requirements, which is a classic blending problem. The objective is to minimize cost, and all relationships are linear, making it a Linear Program. The application is in pharmaceutical production, falling under manufacturing."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D082",
    "description": "A food delivery platform is facing a shortage of delivery capacity during peak hours. To address this, it plans to adopt a crowdsourcing model by recruiting gig workers (\"crowdsourced riders\") to complete a portion of the orders. The platform has found that the number of crowdsourced riders willing to accept orders is related to the compensation structure, which consists of a base delivery fee and an additional bonus per order. The specific relationship is modeled as:\n\nNumber of available riders = 0.8 * (base delivery fee)² + 17 * (additional bonus)\n\nDuring the peak period, there are 1,500 orders that need to be delivered by crowdsourced riders., and each available crowdsourced rider can complete an average of 12 orders. The platform earns an average revenue of $15 for each completed order. The platform has two key requirements: 1) A minimum of 1,000 orders must be completed; 2) The base delivery fee offered to riders must be at least $3. The platform needs to design an optimal \"base delivery fee + additional bonus\" compensation plan to maximize its profit, while ensuring the minimum order completion target is met.",
    "ground_truth": 7871.5480392157,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\nfrom typing import Dict\n\ndef solve_delivery_optimization(\n    TotalOrdersAvailable: int = 1500,\n    OrdersPerRider: int = 12,\n    RevenuePerOrder: float = 15.0,\n    MinOrdersRequired: int = 1000,\n    MinBaseFee: float = 3.0,\n    RiderModelCoeffs: Dict[str, float] = {'base_fee_sq': 0.8, 'bonus': 17.0}\n):\n    \"\"\"\n    Solves the food delivery platform's compensation optimization problem.\n\n    Args:\n        TotalOrdersAvailable (int): Total orders needing delivery.\n        OrdersPerRider (int): Average orders a rider can complete.\n        RevenuePerOrder (float): Revenue earned per completed order.\n        MinOrdersRequired (int): Minimum number of orders that must be completed.\n        MinBaseFee (float): Minimum allowed base delivery fee.\n        RiderModelCoeffs (Dict[str, float]): Coefficients for the rider availability model.\n    \"\"\"\n    \n    # --- Model Initialization ---\n    model = gp.Model(\"DeliveryPlatformOptimization\")\n\n    # --- Decision Variables ---\n    # base_fee (b): The base delivery fee per order.\n    base_fee = model.addVar(name=\"BaseFee\", vtype=GRB.CONTINUOUS, lb=MinBaseFee)\n    \n    # bonus (p): The additional bonus per order.\n    bonus = model.addVar(name=\"Bonus\", vtype=GRB.CONTINUOUS, lb=0.0)\n    \n    # orders_completed (c): The total number of orders completed.\n    orders_completed = model.addVar(\n        name=\"OrdersCompleted\", \n        vtype=GRB.INTEGER, \n        lb=MinOrdersRequired, \n        ub=TotalOrdersAvailable\n    )\n\n    # --- Objective Function ---\n    # Maximize: Total Revenue - Total Rider Payout\n    # Maximize: c * RevenuePerOrder - c * (base_fee + bonus)\n    total_profit = orders_completed * (RevenuePerOrder - base_fee - bonus)\n    model.setObjective(total_profit, GRB.MAXIMIZE)\n\n    # --- Constraints ---\n    # Rider Capacity Constraint:\n    # Completed orders <= Total rider capacity\n    # Rider capacity = (Number of riders) * (Orders per rider)\n    # Number of riders = 0.8 * b^2 + 15 * p\n    num_riders = RiderModelCoeffs['base_fee_sq'] * base_fee * base_fee + RiderModelCoeffs['bonus'] * bonus\n    rider_capacity = num_riders * OrdersPerRider\n    model.addConstr(orders_completed <= rider_capacity, \"RiderCapacity\")\n\n    # --- Solver Configuration ---\n    # This is a non-convex quadratic problem (objective and constraint).\n    # We must set the 'NonConvex' parameter to 2 for Gurobi to solve it.\n    model.setParam('NonConvex', 2)\n\n    # --- Solve the Model ---\n    model.optimize()\n\n    # --- Return Results ---\n    if model.Status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.Status}\"}\n\n\nif __name__ == \"__main__\":\n    # Call the function with the problem's default parameters.\n    result = solve_delivery_optimization()\n    print(result)\n",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Pricing",
        "modeling_type": "MINLP",
        "industry_sector": "Food Delivery",
        "reason": "The core problem is determining optimal compensation (base fee and bonus) to influence rider supply and maximize profit, which falls under pricing. The model includes integer variables (orders completed) and non-linear terms (base_fee squared) in both the objective and constraints, making it a Mixed-Integer Non-Linear Program."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D087",
    "description": "An urban shared e-bike company, \"E-Donkey Express,\" needs to create a nightly battery-swapping plan for its fleet, which is distributed across three zones using its two mobile maintenance vans. The company's objective is to minimize the total nightly cost, which consists of a fixed dispatch fee for each van used and a variable operational cost. This operational cost is uniquely challenging, as it is proportional to the square of the number of batteries replaced by a van in a given zone (Cost = Coefficient × N²), reflecting a diseconomy of scale due to on-site logistical complexities.\nThe plan must ensure that all e-bikes with low-power batteries are serviced, while also respecting the maximum number of new batteries each van can carry. The core decision is how to assign the battery-swapping workload—which zones each van should service, and how many batteries to replace in each—to meet all demands at the lowest possible total cost. All necessary operational data is provided below.\n\nTable 1: Zonal Demand Data\n\n| Zone | Total E-Bikes | Low Battery Percentage (%) |\n|:----:|:--------------:|:--------------------------:|\n|   A  |      200       |             60             |\n|   B  |      150       |             80             |\n|   C  |      180       |             50             |\n\nTable 2: Maintenance Station Parameters\n\n| Parameter                    | Van 1 | Van 2 |\n|:-----------------------------|:-----:|:-----:|\n| Dispatch Cost ($)            |  300  |  320  |\n| Max Battery Capacity (units) |  150  |  180  |\n| Operational Cost Coefficient | 0.08  | 0.07  |",
    "ground_truth": 1998.5,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\ndef solve_ebike_battery_swapping(\n    stations=[\"Van1\", \"Van2\"],\n    zones=[\"ZoneA\", \"ZoneB\", \"ZoneC\"],\n    dispatch_cost={\"Van1\": 300, \"Van2\": 320},\n    van_capacity={\"Van1\": 150, \"Van2\": 180},\n    op_cost_coeff={\"Van1\": 0.08, \"Van2\": 0.07},\n    battery_demand={\"ZoneA\": 120, \"ZoneB\": 120, \"ZoneC\": 90}\n):\n    \"\"\"\n    Solves the E-Donkey Express battery swapping optimization problem.\n    \"\"\"\n    # Create a new model\n    model = gp.Model(\"EbikeBatterySwapping\")\n\n    # --- Decision Variables ---\n    # Number of batteries replaced by station i in zone j\n    batteries_replaced = model.addVars(stations,\n                                       zones,\n                                       vtype=GRB.INTEGER,\n                                       name=\"BatteriesReplaced\",\n                                       lb=0)\n\n    # Whether station i is used (dispatched)\n    station_used = model.addVars(stations, vtype=GRB.BINARY, name=\"StationUsed\")\n\n    # --- Objective Function: Minimize Total Nightly Cost ---\n    total_dispatch_cost = gp.quicksum(dispatch_cost[i] * station_used[i]\n                                      for i in stations)\n\n    # The operational cost is a quadratic term (cost = k * x^2)\n    # Gurobi can handle quadratic objectives directly.\n    total_operational_cost = gp.quicksum(\n        op_cost_coeff[i] * batteries_replaced[i, j] * batteries_replaced[i, j]\n        for i in stations for j in zones)\n\n    model.setObjective(total_dispatch_cost + total_operational_cost,\n                       GRB.MINIMIZE)\n\n    # --- Constraints ---\n\n    # 1. Demand Fulfillment constraint: All low-power batteries in each zone must be replaced.\n    for j in zones:\n        model.addConstr(\n            gp.quicksum(batteries_replaced[i, j] for i in stations) ==\n            battery_demand[j],\n            name=f\"DemandFulfillment_{j}\")\n\n    # 2. Van Capacity constraint: The number of batteries handled by a van cannot exceed its capacity.\n    #    This constraint also links the station_used variable to the number of batteries replaced.\n    #    If a van is not used (y_i=0), it cannot replace any batteries.\n    for i in stations:\n        model.addConstr(\n            gp.quicksum(batteries_replaced[i, j] for j in zones) <=\n            van_capacity[i] * station_used[i],\n            name=f\"Capacity_{i}\")\n\n    # Optimize the model\n    # This is a Mixed-Integer Quadratically Constrained Program (MIQP).\n    # The objective function is convex, so Gurobi will find the global optimum.\n    model.optimize()\n\n    # --- Return Results ---\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.objVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\n# Run the solver function\nif __name__ == '__main__':\n    result = solve_ebike_battery_swapping()\n    print(result)",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MIQP",
        "industry_sector": "Transportation",
        "reason": "The problem involves allocating the battery swapping workload (resources) to maintenance vans to minimize cost. The objective function includes quadratic terms for operational costs and binary variables for van dispatch, making it a Mixed-Integer Quadratic Program. The application is clearly within the urban shared e-bike transportation sector."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D028",
    "description": "A company produces seven types of food containers, ranging in volume from 17 to 33 liters. The demand and size of each container are given in Table as follows: \n\n| Container Type | Volume (liters) | Demand (units) |\n|----------------|-----------------|----------------|\n| 1              | 17              | 500            |\n| 2              | 19              | 400            |\n| 3              | 21              | 300            |\n| 4              | 23              | 250            |\n| 5              | 25              | 200            |\n| 6              | 29              | 150            |\n| 7              | 33              | 100            |\n\nThe variable cost (in dollars) of producing each container is equal to its volume. A fixed cost of $1,000 is incurred to produce any of a particular container type. If the company desires, demand for a container may be satisfied by a container of larger size. Formulate and solve a shortest-path problem whose solution will minimize the cost of meeting the demand for food containers.",
    "ground_truth": 46700.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_container_optimization(\n    volumes=[17, 19, 21, 23, 25, 29, 33],\n    demands=[500, 400, 300, 250, 200, 150, 100],\n    fixed_cost=1000):\n    \"\"\"\n    Solves the container production and assignment optimization problem.\n    \"\"\"\n    # --- 1. Model Creation ---\n    model = gp.Model(\"Container_Optimization\")\n\n    # --- 2. Parameters & Sets ---\n    container_types = range(len(volumes))\n    variable_costs = volumes  # Variable cost equals volume\n\n    # --- 3. Decision Variables ---\n    # produce[j] = 1 if container type j is produced, 0 otherwise\n    produce = model.addVars(container_types, vtype=GRB.BINARY, name=\"Produce\")\n\n    # assign[i, j] = number of units of demand type i satisfied by container type j\n    assign_keys = [(i, j) for i in container_types for j in container_types\n                   if j >= i]\n    assign = model.addVars(assign_keys, vtype=GRB.INTEGER, name=\"Assign\")\n\n    # --- 4. Objective Function ---\n    # Minimize total cost (fixed production costs + variable assignment costs)\n    total_cost = gp.quicksum(fixed_cost * produce[j]\n                             for j in container_types) + \\\n                 gp.quicksum(variable_costs[j] * assign[i, j]\n                             for i, j in assign_keys)\n    model.setObjective(total_cost, GRB.MINIMIZE)\n\n    # --- 5. Constraints ---\n    # Demand satisfaction: All demand for type i must be met.\n    model.addConstrs(\n        (assign.sum(i, '*') == demands[i] for i in container_types),\n        name=\"Demand\")\n\n    # Production activation: If any containers of type j are used, we must incur the fixed cost.\n    M = sum(demands)  # Big-M: an upper bound on the total number of containers of one type\n    model.addConstrs(\n        (assign.sum('*', j) <= M * produce[j] for j in container_types),\n        name=\"Activation\")\n\n    # --- 6. Solve the Model ---\n    model.optimize()\n\n    # --- 7. Return Results ---\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_container_optimization()\n    print(result)",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Production Planning",
        "modeling_type": "MILP",
        "industry_sector": "Manufacturing",
        "reason": "The problem involves deciding which container types to produce and how to assign them to meet demand, which falls under production planning. The formulation uses binary and integer variables with linear constraints and objective, making it a Mixed-Integer Linear Program. The context of producing food containers directly relates to the manufacturing sector."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D029",
    "description": "LogiTrans operates two distribution centers to manage the shipment of three types of goods to various regional hubs. Each distribution center can be staffed by up to seven logistics coordinators at a time. Coordinators are paid $500 per week at distribution center 1 and $900 per week at distribution center 2. Activating a distribution center for a week incurs a fixed cost of $1,000 for center 1 and $2,000 for center 2. During a week at a distribution center, each coordinator can process the number of shipments of each type of goods as shown in Table as follows:\n\n| Goods Type \\ Distribution Center | Center 1 | Center 2 |\n|----------------------------------|----------|----------|\n| Type 1                           | 20       | 25       |\n| Type 2                           | 18       | 22       |\n| Type 3                           | 15       | 20       |\n\nEach week, LogiTrans must ensure that at least 120 shipments of goods type 1, at least 150 shipments of goods type 2, and at least 200 shipments of goods type 3 are processed. How to minimize the total cost of meeting weekly shipment demands?",
    "ground_truth": 11000.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_staffing_optimization(\n    FixedCost=[1000, 2000],\n    StaffCost=[500, 900],\n    MaxStaffNum=[7, 7],\n    ProcessRate=[[20, 25], [18, 22], [15, 20]],\n    Demand=[120, 150, 200]):\n    \"\"\"\n    Solves the distribution center staffing optimization problem.\n    \"\"\"\n    # --- 1. Model Creation ---\n    model = gp.Model(\"Distribution Center Staffing\")\n\n    # --- 2. Parameters & Sets ---\n    Centers = range(len(FixedCost))\n    GoodsTypes = range(len(Demand))\n\n    # --- 3. Decision Variables ---\n    # ActivatingCenter[c] = 1 if center c is activated, 0 otherwise\n    ActivatingCenter = model.addVars(Centers,\n                                     vtype=GRB.BINARY,\n                                     name=\"ActivatingCenter\")\n\n    # StaffNum[c] = number of staff at center c\n    StaffNum = model.addVars(Centers, vtype=GRB.INTEGER, name=\"StaffNum\")\n\n    # --- 4. Objective Function ---\n    # Minimize total cost (fixed costs + staff costs)\n    obj = gp.quicksum(FixedCost[c] * ActivatingCenter[c] +\n                      StaffCost[c] * StaffNum[c] for c in Centers)\n    model.setObjective(obj, GRB.MINIMIZE)\n\n    # --- 5. Constraints ---\n    # Constraint 1: Staff number constraint\n    model.addConstrs(\n        (StaffNum[c] <= MaxStaffNum[c] * ActivatingCenter[c] for c in Centers),\n        name=\"StaffLimit\")\n\n    # Constraint 2: Demand satisfaction constraint\n    model.addConstrs(\n        (gp.quicksum(ProcessRate[g][c] * StaffNum[c] for c in Centers) >=\n         Demand[g] for g in GoodsTypes),\n        name=\"DemandSatisfaction\")\n\n    # --- 6. Solve the Model ---\n    model.optimize()\n\n    # --- 7. Return Results ---\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_staffing_optimization()\n    print(result)",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MILP",
        "industry_sector": "Logistics",
        "reason": "The problem involves allocating staff resources to distribution centers to meet shipment demands at minimum cost, which is a classic resource allocation problem. The model uses both continuous (integer) and binary variables, and all constraints and the objective function are linear, classifying it as a Mixed-Integer Linear Program. The application directly relates to managing goods movement and distribution, fitting within the logistics sector."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D004",
    "description": "A company has three industries located in different locations and needs to deliver goods to five shops in different locations. The delivery costs from the first industry to the shops are 4, 9, 2, 6, and 5, respectively, with a storage capacity of 60. The delivery costs from the second industry to the shops are 2, 6, 1, 7, and 9, respectively, with a storage capacity of 30. The delivery costs from the third industry to the shops are 2, 4, 9, 8, and 3, respectively, with a storage capacity of 45. The demands of the five shops are 15, 35, 20, 5, and 40. How can the goods be transported to minimize the cost?",
    "ground_truth": 405.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_transportation_problem(\n    industry_storage=[60, 30, 45],\n    shop_demand=[15, 35, 20, 5, 40],\n    transportation_cost=[\n        [4, 9, 2, 6, 5],\n        [2, 6, 1, 7, 9],\n        [2, 4, 9, 8, 3]\n    ]\n):\n    \"\"\"\n    Models and solves the classic transportation problem.\n    \"\"\"\n    # --- 1. Model Creation ---\n    model = gp.Model(\"TransportationProblem\")\n\n    # --- 2. Sets and Parameters ---\n    # Derive dimensions from the input data for robustness\n    industries = range(len(industry_storage))\n    shops = range(len(shop_demand))\n\n    # --- 3. Decision Variables ---\n    # t[i, j] = amount transported from industry i to shop j\n    t = model.addVars(industries, shops, vtype=GRB.INTEGER, name=\"transport\")\n\n    # --- 4. Objective Function ---\n    # Minimize total transportation cost\n    model.setObjective(\n        gp.quicksum(transportation_cost[i][j] * t[i, j] for i in industries for j in shops),\n        GRB.MINIMIZE\n    )\n\n    # --- 5. Constraints ---\n    # Constraint 1: Supply constraint for each industry\n    for i in industries:\n        model.addConstr(gp.quicksum(t[i, j] for j in shops) <= industry_storage[i],\n                        name=f\"supply_{i}\")\n\n    # Constraint 2: Demand constraint for each shop\n    for j in shops:\n        model.addConstr(gp.quicksum(t[i, j] for i in industries) == shop_demand[j],\n                        name=f\"demand_{j}\")\n\n    # --- 6. Solve the Model ---\n    model.setParam(\"OutputFlag\", 0)  # Suppress Gurobi output\n    model.optimize()\n\n    # --- 7. Return Results ---\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\n# Run the solver function\nif __name__ == \"__main__\":\n    result = solve_transportation_problem()\n    print(result)",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Network Flow",
        "modeling_type": "MILP",
        "industry_sector": "Logistics",
        "reason": "The problem involves minimizing transportation costs from multiple sources (industries) to multiple destinations (shops) with given capacities and demands, which is a classic transportation problem, a specific type of network flow problem. The solver uses integer variables and linear constraints, making it a Mixed-Integer Linear Program (MILP)."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D066",
    "description": "A distribution company is planning its logistics network for the upcoming year to serve 15 retail stores from 5 potential hub locations. The company aims to minimize its total annual operational cost, which consists of fixed daily costs for opening hubs and variable transportation costs for delivering goods.\n\nThe core decisions are which of the 5 potential hubs to open and which open hub should be assigned to serve each of the 15 retail stores.\n\nEach potential hub has a specific daily operating cost, a maximum daily capacity, and an operational reliability score. The company has a strategic requirement that the average reliability of all opened hubs must be at least 90%. The transportation cost is fixed at $0.80 per unit per mile, and the planning horizon is a full year (365 days).\n\nThe plan must assign each store to exactly one hub, ensure that no hub's daily capacity is exceeded, meet the minimum average reliability standard, and minimize the total annual cost.\n\nHub Data:  \n\n| Hub ID | Daily Setup Cost | Daily Capacity (units) | Reliability |\n|:------:|:----------------:|:----------------------:|:-----------:|\n| 1      | $100,000         | 1000                   | 0.85        |\n| 2      | $80,000          | 800                    | 0.90        |\n| 3      | $120,000         | 1500                   | 0.70        |\n| 4      | $90,000          | 1200                   | 0.95        |\n| 5      | $110,000         | 900                    | 0.80        |\n\nStore Demand Data (units per day):  \n\n| Store | Demand | | Store | Demand | | Store | Demand |\n|:-----:|:------:| |:-----:|:------:| |:-----:|:------:|\n| 1     | 151    | | 6     | 187    | | 11    | 121    |\n| 2     | 188    | | 7     | 199    | | 12    | 173    |\n| 3     | 174    | | 8     | 104    | | 13    | 100    |\n| 4     | 161    | | 9     | 116    | | 14    | 187    |\n| 5     | 111    | | 10    | 88     | | 15    | 199    |\n\nDistance Matrix (Hub to Store, in miles):  \n\n| Hub | S1 | S2 | S3 | S4 | S5 | S6 | S7 | S8 | S9 | S10 | S11 | S12 | S13 | S14 | S15 |\n|:---:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:---:|:---:|:---:|:---:|:---:|:---:|\n|  1  | 18 | 45 | 42 | 38 | 18 | 44 | 47 | 12 | 20 | 10  | 23  | 41  | 10  | 44  | 47  |\n|  2  | 30 | 27 | 21 | 16 | 17 | 12 | 29 | 21 | 38 | 48  | 23  | 15  | 12  | 20  | 26  |\n|  3  | 16 | 13 | 21 | 31 | 30 | 39 | 44 | 44 | 18 | 12  | 13  | 16  | 42  | 49  | 11  |\n|  4  | 34 | 25 | 30 | 20 | 24 | 28 | 42 | 39 | 31 | 44  | 34  | 11  | 36  | 16  | 23  |\n|  5  | 49 | 41 | 17 | 34 | 16 | 49 | 49 | 28 | 42 | 18  | 46  | 23  | 29  | 21  | 49  |",
    "ground_truth": 110628288.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_hub_location(\n    H=[1, 2, 3, 4, 5],\n    S=list(range(1, 16)),\n    SetupCost={1: 100, 2: 80, 3: 120, 4: 90, 5: 110},\n    Capacity={1: 1000, 2: 800, 3: 1500, 4: 1200, 5: 900},\n    Reliability={1: 0.85, 2: 0.9, 3: 0.7, 4: 0.95, 5: 0.8},\n    TransportCost=0.8,\n    MinAvgReliability=0.9,\n    Days=365,\n    Demand_data=None,\n    Distance_data=None\n):\n    \"\"\"\n    Solve the hub location problem.\n    \"\"\"\n    if Demand_data is None:\n        Demand = {\n            1: 151, 2: 188, 3: 174, 4: 161, 5: 111, 6: 187, 7: 199, 8: 104,\n            9: 116, 10: 88, 11: 121, 12: 173, 13: 100, 14: 187, 15: 199\n        }\n    else:\n        Demand = Demand_data\n\n    if Distance_data is None:\n        Distance = {\n            (1, 1): 18, (1, 2): 45, (1, 3): 42, (1, 4): 38, (1, 5): 18, (1, 6): 44, (1, 7): 47, (1, 8): 12, (1, 9): 20, (1, 10): 10, (1, 11): 23, (1, 12): 41, (1, 13): 10, (1, 14): 44, (1, 15): 47,\n            (2, 1): 30, (2, 2): 27, (2, 3): 21, (2, 4): 16, (2, 5): 17, (2, 6): 12, (2, 7): 29, (2, 8): 21, (2, 9): 38, (2, 10): 48, (2, 11): 23, (2, 12): 15, (2, 13): 12, (2, 14): 20, (2, 15): 26,\n            (3, 1): 16, (3, 2): 13, (3, 3): 21, (3, 4): 31, (3, 5): 30, (3, 6): 39, (3, 7): 44, (3, 8): 44, (3, 9): 18, (3, 10): 12, (3, 11): 13, (3, 12): 16, (3, 13): 42, (3, 14): 49, (3, 15): 11,\n            (4, 1): 34, (4, 2): 25, (4, 3): 30, (4, 4): 20, (4, 5): 24, (4, 6): 28, (4, 7): 42, (4, 8): 39, (4, 9): 31, (4, 10): 44, (4, 11): 34, (4, 12): 11, (4, 13): 36, (4, 14): 16, (4, 15): 23,\n            (5, 1): 49, (5, 2): 41, (5, 3): 17, (5, 4): 34, (5, 5): 16, (5, 6): 49, (5, 7): 49, (5, 8): 28, (5, 9): 42, (5, 10): 18, (5, 11): 46, (5, 12): 23, (5, 13): 29, (5, 14): 21, (5, 15): 49\n        }\n    else:\n        Distance = Distance_data\n\n    model = gp.Model(\"HubLocationProblem\")\n\n    OpenHub = model.addVars(H, vtype=GRB.BINARY, name=\"OpenHub\")\n    AssignStore = model.addVars(H, S, vtype=GRB.BINARY, name=\"AssignStore\")\n\n    setup_cost = gp.quicksum(SetupCost[h] * 1000 * OpenHub[h] for h in H)\n    transport_cost = gp.quicksum(\n        TransportCost * Demand[s] * Distance[h, s] * AssignStore[h, s]\n        for h in H for s in S\n    )\n    model.setObjective(Days * (setup_cost + transport_cost), GRB.MINIMIZE)\n\n    model.addConstrs((gp.quicksum(AssignStore[h, s] for h in H) == 1 for s in S))\n    model.addConstrs((gp.quicksum(Demand[s] * AssignStore[h, s] for s in S) <= Capacity[h] * OpenHub[h] for h in H))\n    model.addConstr(gp.quicksum(Reliability[h] * OpenHub[h] for h in H) >= MinAvgReliability * gp.quicksum(OpenHub[h] for h in H))\n    model.addConstrs((AssignStore[h, s] <= OpenHub[h] for h in H for s in S))\n\n    model.optimize()\n\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_hub_location()\n    print(result)",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Facility Location",
        "modeling_type": "MILP",
        "industry_sector": "Logistics",
        "reason": "The problem involves deciding which potential hubs to open and assigning stores to these open hubs, which is a classic facility location problem. The formulation uses binary variables for opening hubs and assigning stores, along with linear constraints and an objective function, making it a Mixed-Integer Linear Program. The application is clearly within logistics and distribution for a company."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D041",
    "description": "LogiFlow Solutions manages the distribution of two types of packages: Standard and Express. Each package must be transported entirely by air freight or entirely by ground shipping. A total of 150 cubic meters of air freight capacity and 210 cubic meters of ground shipping capacity are available. A Standard package requires either 17 cubic meters of air freight or 30 cubic meters of ground shipping, while an Express package requires either 5 cubic meters of air freight or 13 cubic meters of ground shipping. Each Standard package generates $40 in revenue, and each Express package generates $15 in revenue. How to maximize LogiFlow Solutions' total revenue from package distribution?",
    "ground_truth": 730.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_package_shipping_optimization(\n    AirFreightCapacity=150,\n    GroundShippingCapacity=210,\n    AirFreightRequirement=[17, 5],\n    GroundShippingRequirement=[30, 13],\n    RevenuePerPackage=[40, 15]\n):\n    \"\"\"\n    Models and solves the package shipping optimization problem.\n    \"\"\"\n    # Create a new model\n    model = gp.Model(\"Package_Shipping_Optimization\")\n\n    # Sets\n    P = range(len(RevenuePerPackage))  # Package types\n    S = range(2)  # Shipping methods (0: Air freight, 1: Ground shipping)\n\n    # Decision Variables\n    PackagesShipped = model.addVars(P, S, vtype=GRB.INTEGER, lb=0, name=\"PackagesShipped\")\n\n    # Objective Function: Maximize total revenue\n    revenue = gp.quicksum(PackagesShipped[p, s] * RevenuePerPackage[p] for p in P for s in S)\n    model.setObjective(revenue, GRB.MAXIMIZE)\n\n    # Constraints\n    # 1. Air freight capacity constraint\n    model.addConstr(\n        gp.quicksum(PackagesShipped[p, 0] * AirFreightRequirement[p] for p in P) <= AirFreightCapacity,\n        \"AirFreightCapacity\"\n    )\n\n    # 2. Ground shipping capacity constraint\n    model.addConstr(\n        gp.quicksum(PackagesShipped[p, 1] * GroundShippingRequirement[p] for p in P) <= GroundShippingCapacity,\n        \"GroundShippingCapacity\"\n    )\n\n    # Optimize the model\n    model.optimize()\n\n    # Return Results\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_package_shipping_optimization()\n    print(result)\n",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MILP",
        "industry_sector": "Logistics",
        "reason": "The problem involves allocating limited air and ground shipping capacities to different package types to maximize total revenue. The solver uses integer variables for the number of packages and linear constraints, making it a Mixed-Integer Linear Program (MILP)."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D051",
    "description": "Problem Description:\nA city needs to place emergency response facilities to ensure that every residential area can be reached within 10 minutes. There are 5 potential facility locations (F1-F5) and 8 residential areas (R1-R8). The travel time (in minutes) between each facility location and residential area is given in the following table:\n\n| Facility\\Residential | R1 | R2 | R3 | R4 | R5 | R6 | R7 | R8 |\n|----------------------|----|----|----|----|----|----|----|----|\n| F1                   | 8  | 12 | 9  | 15 | 7  | 11 | 14 | 6  |\n| F2                   | 10 | 8  | 13 | 7  | 9  | 12 | 5  | 11 |\n| F3                   | 14 | 6  | 10 | 8  | 12 | 7  | 9  | 13 |\n| F4                   | 7  | 11 | 14 | 6  | 8  | 10 | 12 | 9  |\n| F5                   | 9  | 13 | 7  | 11 | 6  | 14 | 8  | 10 |\n\nThe goal is to select the minimum number of facilities such that every residential area is covered (reachable within 10 minutes) by at least one selected facility.",
    "ground_truth": 2.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_facility_location(\n    facilities=['F1', 'F2', 'F3', 'F4', 'F5'],\n    residentials=['R1', 'R2', 'R3', 'R4', 'R5', 'R6', 'R7', 'R8'],\n    travel_time={\n        'F1': [8, 12, 9, 15, 7, 11, 14, 6],\n        'F2': [10, 8, 13, 7, 9, 12, 5, 11],\n        'F3': [14, 6, 10, 8, 12, 7, 9, 13],\n        'F4': [7, 11, 14, 6, 8, 10, 12, 9],\n        'F5': [9, 13, 7, 11, 6, 14, 8, 10]\n    }\n):\n    \"\"\"\n    Solves the facility location problem.\n    \"\"\"\n    # Create coverage parameter a_fr (1 if travel time <=10, 0 otherwise)\n    coverage = {}\n    for f in facilities:\n        for i, r in enumerate(residentials):\n            coverage[(f, r)] = 1 if travel_time[f][i] <= 10 else 0\n\n    # Create model\n    model = gp.Model(\"Facility_Location\")\n\n    # Decision variables: x_f (whether facility f is selected)\n    x = model.addVars(facilities, vtype=GRB.BINARY, name=\"Select\")\n\n    # Objective: minimize number of selected facilities\n    model.setObjective(gp.quicksum(x[f] for f in facilities), GRB.MINIMIZE)\n\n    # Constraints: each residential area must be covered by at least one selected facility\n    for r in residentials:\n        model.addConstr(gp.quicksum(coverage[(f, r)] * x[f] for f in facilities) >= 1,\n                        f\"Cover_{r}\")\n\n    # Solve the model\n    model.optimize()\n\n    # Return results\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_facility_location()\n    print(result)",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Covering",
        "modeling_type": "IP",
        "industry_sector": "Public Services",
        "reason": "The problem aims to select a minimum number of facilities to 'cover' all residential areas within a specified time limit, which is a classic set covering problem. The solver uses binary decision variables and linear constraints, making it an Integer Program (IP). The application is related to emergency response, falling under public services."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D077",
    "description": "A shipping company operates a fleet of cargo ships to transport containers between three ports: PortA, PortB, and PortC. The company aims to allocate its ships across six possible shipping routes in a way that maximizes overall profit while satisfying all container demand and adhering to operational constraints.\n\nEach ship has a capacity of 8000 TEUs (Twenty-foot Equivalent Units) and consumes 200 tons of fuel per 1000 nautical miles traveled. Fuel costs 600 USD per ton. There are 12 ships available in total, but at least 2 must remain in reserve and cannot be assigned to any route. Each ship can only be assigned to one route per day.\n\nThe six possible shipping routes, along with their respective distances, are as follows:\n- Route1: PortA → PortB (1200 nautical miles)\n- Route2: PortA → PortC (1800 nautical miles)\n- Route3: PortB → PortC (900 nautical miles)\n- Route4: PortB → PortA (1200 nautical miles)\n- Route5: PortC → PortA (1800 nautical miles)\n- Route6: PortC → PortB (900 nautical miles)\n\nFor each route, the container demand in TEUs is:\n- Route1: 6500 TEUs\n- Route2: 7200 TEUs\n- Route3: 4800 TEUs\n- Route4: 5100 TEUs\n- Route5: 6200 TEUs\n- Route6: 3900 TEUs\n\nRevenue generated per TEU varies by route:\n- Route1: $120 per TEU\n- Route2: $150 per TEU\n- Route3: $90 per TEU\n- Route4: $110 per TEU\n- Route5: $140 per TEU\n- Route6: $80 per TEU\n\nOperational constraints include:\n- A ship assigned to a route must carry at least 70% of its capacity, i.e., at least 5600 TEUs.\n- The number of ships assigned to a route cannot exceed the ceiling of the ratio of demand to ship capacity (i.e., ceiling(demand / 8000)).\n- All container demand for each route must be fully satisfied.\n\nThe objective is to determine the optimal allocation of ships to routes that maximizes net profit (revenue from transported containers minus fuel costs), while respecting all constraints.",
    "ground_truth": 4584000.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\nimport math\n\n\ndef solve_shipping_problem(\n    routes=[1, 2, 3, 4, 5, 6],\n    ships=list(range(1, 11)),\n    RouteDemand={\n        1: 6500,\n        2: 7200,\n        3: 4800,\n        4: 5100,\n        5: 6200,\n        6: 3900\n    },\n    Revenue={\n        1: 120,\n        2: 150,\n        3: 90,\n        4: 110,\n        5: 140,\n        6: 80\n    },\n    Distance={\n        1: 1200,\n        2: 1800,\n        3: 900,\n        4: 1200,\n        5: 1800,\n        6: 900\n    },\n    ShipCapacity=8000,\n    FuelConsumptionRate=0.2,\n    FuelCost=600,\n    MinLoadPercentage=0.7\n):\n    # Create model\n    model = gp.Model(\"Shipping_Optimization\")\n\n    # Decision variables\n    # Binary variable: 1 if ship s is assigned to route r\n    x = model.addVars(ships, routes, vtype=GRB.BINARY, name=\"assign\")\n\n    # Continuous variable: total containers shipped on route r\n    y = model.addVars(routes, lb=0, vtype=GRB.CONTINUOUS, name=\"containers\")\n\n    # Objective function: maximize profit (revenue - fuel costs)\n    revenue = gp.quicksum(Revenue[r] * y[r] for r in routes)\n    fuel_cost = gp.quicksum(\n        x[s, r] * Distance[r] * FuelConsumptionRate * FuelCost\n        for s in ships for r in routes\n    )\n    model.setObjective(revenue - fuel_cost, GRB.MAXIMIZE)\n\n    # Constraints\n    # 1. Demand satisfaction\n    model.addConstrs(\n        (y[r] >= RouteDemand[r] for r in routes),\n        name=\"demand_satisfaction\"\n    )\n\n    # 2. Ship capacity constraints\n    model.addConstrs(\n        (y[r] <= gp.quicksum(x[s, r] for s in ships) * ShipCapacity for r in routes),\n        name=\"capacity_limit\"\n    )\n\n    # 3. Minimum loading requirement (70% of capacity)\n    model.addConstrs(\n        (y[r] >= gp.quicksum(x[s, r] for s in ships) * ShipCapacity * MinLoadPercentage for r in routes),\n        name=\"min_loading\"\n    )\n\n    # 4. Each ship can be assigned to at most 1 route\n    model.addConstrs(\n        (gp.quicksum(x[s, r] for r in routes) <= 1 for s in ships),\n        name=\"ship_assignment_limit\"\n    )\n\n    # 5. Maximum ships per route (ceil(demand/capacity))\n    max_ships_per_route = {\n        r: math.ceil(RouteDemand[r] / ShipCapacity) for r in routes\n    }\n    model.addConstrs(\n        (gp.quicksum(x[s, r] for s in ships) <= max_ships_per_route[r] for r in routes),\n        name=\"max_ships_per_route\"\n    )\n\n    # 6. Total ship usage cannot exceed available ships (10)\n    model.addConstr(\n        gp.quicksum(x[s, r] for s in ships for r in routes) <= 10,\n        name=\"total_ship_usage\"\n    )\n\n    # Optimize the model\n    model.optimize()\n\n    # Return results\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_shipping_problem()\n    print(result)",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MILP",
        "industry_sector": "Transportation",
        "reason": "The problem involves allocating a limited fleet of ships (resources) to various shipping routes to maximize profit, which is a classic resource allocation problem. The model uses both binary (ship assignment) and continuous (containers shipped) variables, and all constraints and the objective function are linear, classifying it as a Mixed-Integer Linear Program."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D064",
    "description": "A logistics company needs to deliver goods to 15 customers over a 5-day workweek (Monday to Friday). Each customer has specific delivery frequency requirements: 3 customers require daily deliveries, 5 require deliveries every other day, and 7 require weekly deliveries. The company has 3 available vehicles, each with a capacity of 200 units. The distances between customers and the depot are given in the following matrix (in km):\n\nDistance Table (depot = 0, customers = 1-15):\n\n| From\\To | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  | 11  | 12  | 13  | 14  | 15  |\n|---------|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|\n|   0     | 0   | 12  | 18  | 9   | 15  | 22  | 7   | 14  | 20  | 11  | 16  | 8   | 13  | 19  | 10  | 17  |\n|   1     | 12  | 0   | 6   | 15  | 21  | 8   | 17  | 23  | 10  | 19  | 4   | 16  | 5   | 11  | 18  | 7   |\n|   2     | 18  | 6   | 0   | 21  | 3   | 14  | 9   | 15  | 12  | 5   | 10  | 7   | 13  | 8   | 4   | 11  |\n|   3     | 9   | 15  | 21  | 0   | 18  | 11  | 16  | 22  | 7   | 14  | 20  | 3   | 19  | 10  | 17  | 6   |\n|   4     | 15  | 21  | 3   | 18  | 0   | 17  | 12  | 8   | 15  | 10  | 7   | 13  | 4   | 9   | 14  | 11  |\n|   5     | 22  | 8   | 14  | 11  | 17  | 0   | 19  | 5   | 12  | 7   | 14  | 10  | 17  | 6   | 13  | 8   |\n|   6     | 7   | 17  | 9   | 16  | 12  | 19  | 0   | 14  | 21  | 8   | 15  | 11  | 18  | 5   | 12  | 9   |\n|   7     | 14  | 23  | 15  | 22  | 8   | 5   | 14  | 0   | 17  | 12  | 9   | 15  | 6   | 11  | 16  | 13  |\n|   8     | 20  | 10  | 12  | 7   | 15  | 12  | 21  | 17  | 0   | 13  | 18  | 4   | 19  | 14  | 9   | 16  |\n|   9     | 11  | 19  | 5   | 14  | 10  | 7   | 8   | 12  | 13  | 0   | 15  | 11  | 6   | 17  | 12  | 9   |\n|   10    | 16  | 4   | 10  | 20  | 7   | 14  | 15  | 9   | 18  | 15  | 0   | 17  | 8   | 13  | 18  | 5   |\n|   11    | 8   | 16  | 7   | 3   | 13  | 10  | 11  | 15  | 4   | 11  | 17  | 0   | 14  | 9   | 16  | 7   |\n|   12    | 13  | 5   | 13  | 19  | 4   | 17  | 18  | 6   | 19  | 6   | 8   | 14  | 0   | 15  | 10  | 17  |\n|   13    | 19  | 11  | 8   | 10  | 9   | 6   | 5   | 11  | 14  | 17  | 13  | 9   | 15  | 0   | 7   | 12  |\n|   14    | 10  | 18  | 4   | 17  | 14  | 13  | 12  | 16  | 9   | 12  | 18  | 16  | 10  | 7   | 0   | 11  |\n|   15    | 17  | 7   | 11  | 6   | 11  | 8   | 9   | 13  | 16  | 9   | 5   | 7   | 17  | 12  | 11  | 0   |\n\nEach customer's daily demand (in units) is: [25, 30, 20, 15, 35, 40, 18, 22, 28, 32, 19, 21, 26, 24, 23]. The objective is to plan vehicle routes for each day of the week to satisfy all delivery requirements while minimizing total distance traveled.",
    "ground_truth": 352.0,
    "formulation": null,
    "correct_program": "import math\nimport gurobipy as gp\nfrom gurobipy import GRB\nimport numpy as np\nfrom rich.console import Console\nfrom rich.table import Table\nfrom rich.panel import Panel\n\n\ndef solve_daily_vrp(day, required_customers, demands, vehicle_capacity,\n                    num_vehicles, all_nodes, distance_matrix):\n    \"\"\"\n    Solves a single-day Capacitated VRP for a given set of customers\n    using a standard and robust flow-based formulation.\n    \"\"\"\n\n    # The nodes for today's problem include the depot and only the customers that need a visit.\n    daily_nodes = [0] + required_customers\n\n    model = gp.Model(f\"VRP_Day_{day}\")\n\n    # --- Decision Variables ---\n    # x[i, j, v]: 1 if vehicle v travels from node i to j.\n    # We create arcs only between the nodes relevant for the day.\n    vehicles = list(range(1, num_vehicles + 1))\n    arcs = [(i, j, v) for i in daily_nodes for j in daily_nodes\n            for v in vehicles if i != j]\n    x = model.addVars(arcs, vtype=GRB.BINARY, name=\"x\")\n\n    # --- Objective Function ---\n    # Minimize the total distance traveled for the day.\n    model.setObjective(\n        gp.quicksum(distance_matrix[i, j] * x[i, j, v] for i, j, v in arcs),\n        GRB.MINIMIZE)\n\n    # --- Constraints ---\n    # 1. Each required customer for the day is visited exactly once by some vehicle.\n    model.addConstrs((gp.quicksum(x[i, c, v] for i in daily_nodes\n                                  for v in vehicles if i != c) == 1\n                      for c in required_customers),\n                     name=\"visit_customer\")\n\n    # 2. Each vehicle leaves the depot at most once.\n    model.addConstrs((gp.quicksum(x[0, j, v] for j in required_customers) <= 1\n                      for v in vehicles),\n                     name=\"leave_depot\")\n\n    # 3. Flow conservation: if a vehicle enters a customer node, it must leave it.\n    model.addConstrs((gp.quicksum(x[i, c, v] for i in daily_nodes if i != c)\n                      == gp.quicksum(x[c, j, v] for j in daily_nodes if j != c)\n                      for c in required_customers for v in vehicles),\n                     name=\"flow_conservation\")\n\n    # 4. Vehicle capacity constraint.\n    model.addConstrs(\n        (gp.quicksum(demands[c] * gp.quicksum(x[i, c, v]\n                                              for i in daily_nodes if i != c)\n                     for c in required_customers) <= vehicle_capacity\n         for v in vehicles),\n        name=\"capacity\")\n\n    # 5. Subtour Elimination (MTZ formulation).\n    u = model.addVars(daily_nodes, vtype=GRB.CONTINUOUS)\n    for i in required_customers:\n        model.addConstr(u[i] >= demands[i])\n        model.addConstr(u[i] <= vehicle_capacity)\n        for j in required_customers:\n            if i != j:\n                model.addConstr(\n                    u[i] - u[j] +\n                    vehicle_capacity * gp.quicksum(x[i, j, v]\n                                                   for v in vehicles)\n                    <= vehicle_capacity - demands[j], f\"subtour_{i}_{j}\")\n\n    # --- Solve This Day's Model ---\n    model.Params.LogToConsole = 0  # Suppress solver output for daily runs\n    model.optimize()\n\n    # --- Extract and Return Results ---\n    if model.Status == GRB.OPTIMAL:\n        routes = []\n        for v in vehicles:\n            # Check if this vehicle is used by seeing if it leaves the depot\n            if gp.quicksum(x[0, j, v]\n                           for j in required_customers).getValue() > 0.5:\n                # Reconstruct the tour for this vehicle\n                tour = [0]\n                current_node = 0\n                while True:\n                    found_next = False\n                    for j in daily_nodes:\n                        if j != current_node and x[current_node, j, v].X > 0.5:\n                            if j == 0:  # Returned to depot\n                                break\n                            tour.append(j)\n                            current_node = j\n                            found_next = True\n                            break\n                    if not found_next:\n                        tour.append(0)  # Final return to depot\n                        break\n                routes.append({'vehicle': v, 'route': tour})\n        return model.ObjVal, routes\n    return float('inf'), []\n\n\ndef solve_weekly_delivery_routing():\n    \"\"\"Main function to set up and solve the weekly routing problem day-by-day.\"\"\"\n    console = Console()\n    console.print(\n        Panel(\n            \"[bold blue]Weekly Delivery Routing Optimizer (Day-by-Day Approach)[/bold blue]\"\n        ))\n\n    # ========== Problem Data ==========\n    days = list(range(1, 6))\n    customers = list(range(1, 16))\n    vehicles = list(range(1, 4))\n    depot = 0\n    all_nodes = [depot] + customers\n    vehicle_capacity = 200\n\n    dist_matrix = np.array(\n        [[0, 12, 18, 9, 15, 22, 7, 14, 20, 11, 16, 8, 13, 19, 10, 17],\n         [12, 0, 6, 15, 21, 8, 17, 23, 10, 19, 4, 16, 5, 11, 18, 7],\n         [18, 6, 0, 21, 3, 14, 9, 15, 12, 5, 10, 7, 13, 8, 4, 11],\n         [9, 15, 21, 0, 18, 11, 16, 22, 7, 14, 20, 3, 19, 10, 17, 6],\n         [15, 21, 3, 18, 0, 17, 12, 8, 15, 10, 7, 13, 4, 9, 14, 11],\n         [22, 8, 14, 11, 17, 0, 19, 5, 12, 7, 14, 10, 17, 6, 13, 8],\n         [7, 17, 9, 16, 12, 19, 0, 14, 21, 8, 15, 11, 18, 5, 12, 9],\n         [14, 23, 15, 22, 8, 5, 14, 0, 17, 12, 9, 15, 6, 11, 16, 13],\n         [20, 10, 12, 7, 15, 12, 21, 17, 0, 13, 18, 4, 19, 14, 9, 16],\n         [11, 19, 5, 14, 10, 7, 8, 12, 13, 0, 15, 11, 6, 17, 12, 9],\n         [16, 4, 10, 20, 7, 14, 15, 9, 18, 15, 0, 17, 8, 13, 18, 5],\n         [8, 16, 7, 3, 13, 10, 11, 15, 4, 11, 17, 0, 14, 9, 16, 7],\n         [13, 5, 13, 19, 4, 17, 18, 6, 19, 6, 8, 14, 0, 15, 10, 17],\n         [19, 11, 8, 10, 9, 6, 5, 11, 14, 17, 13, 9, 15, 0, 7, 12],\n         [10, 18, 4, 17, 14, 13, 12, 16, 9, 12, 18, 16, 10, 7, 0, 11],\n         [17, 7, 11, 6, 11, 8, 9, 13, 16, 9, 5, 7, 17, 12, 11, 0]])\n    demands = {\n        c: val\n        for c, val in enumerate(\n            [25, 30, 20, 15, 35, 40, 18, 22, 28, 32, 19, 21, 26, 24, 23], 1)\n    }\n\n    # Define which customers to visit on each day based on frequency\n    customers_by_day = {d: [] for d in days}\n    frequency_map = {\n        c: 1 if c <= 3 else (2 if c <= 8 else 3)\n        for c in customers\n    }  # Daily, Every Other, Weekly\n    for c in customers:\n        if frequency_map[c] == 1:  # Daily\n            for d in days:\n                customers_by_day[d].append(c)\n        elif frequency_map[c] == 2:  # Every other day (Mon, Wed, Fri)\n            customers_by_day[1].append(c)\n            customers_by_day[3].append(c)\n            customers_by_day[5].append(c)\n        else:  # Weekly (Wednesday)\n            customers_by_day[3].append(c)\n\n    # ========== Solve and Display Results ==========\n    total_weekly_distance = 0\n    results_table = Table(title=\"Weekly Delivery Route Summary\")\n    results_table.add_column(\"Day\", justify=\"center\", style=\"bold yellow\")\n    results_table.add_column(\"Vehicle\", justify=\"center\", style=\"cyan\")\n    results_table.add_column(\"Route\", justify=\"left\", style=\"magenta\")\n    results_table.add_column(\"Load\", justify=\"right\")\n    results_table.add_column(\"Distance\", justify=\"right\")\n\n    for day in days:\n        required_customers_today = customers_by_day[day]\n        if not required_customers_today:\n            continue\n\n        console.print(f\"\\n[yellow]Optimizing routes for Day {day}...[/yellow]\")\n        daily_dist, daily_routes = solve_daily_vrp(day,\n                                                   required_customers_today,\n                                                   demands, vehicle_capacity,\n                                                   len(vehicles), all_nodes,\n                                                   dist_matrix)\n\n        if daily_dist == float('inf'):\n            console.print(\n                f\"[bold red]Could not find a feasible solution for Day {day}.[/bold red]\"\n            )\n            continue\n\n        total_weekly_distance += daily_dist\n\n        for route_info in daily_routes:\n            v = route_info['vehicle']\n            route = route_info['route']\n            route_str = \" -> \".join([str(n) if n != 0 else 'D' for n in route])\n            route_load = sum(demands.get(c, 0) for c in route)\n            route_dist = sum(dist_matrix[route[i], route[i + 1]]\n                             for i in range(len(route) - 1))\n            results_table.add_row(str(day), str(v), route_str,\n                                  f\"{route_load}/{vehicle_capacity}\",\n                                  f\"{route_dist:.2f}\")\n\n    console.print(results_table)\n    console.print(\n        Panel(\n            f\"[bold green]Total Weekly Distance Traveled: {total_weekly_distance:.2f} km[/bold green]\"\n        ))\n\n\nif __name__ == \"__main__\":\n    solve_weekly_delivery_routing()\n",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Routing",
        "modeling_type": "MILP",
        "industry_sector": "Logistics",
        "reason": "The problem involves planning vehicle routes to deliver goods to customers while minimizing total distance, which is a classic Vehicle Routing Problem (VRP). The solver uses binary variables for arc selection and continuous variables for subtour elimination, making it a Mixed-Integer Linear Program (MILP). The application is directly in the context of a logistics company delivering goods, fitting the logistics sector."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D034",
    "description": "FreshFoods operates three farms (Farm A, Farm B, and Farm C) to grow and supply fresh produce to four grocery stores (Store 1, Store 2, Store 3, and Store 4). The production cost, yield capacity, water usage (per ton), and fertilizer usage (per ton) for each farm are given in the table below:\n\n| Farm | Production Cost ($/ton) | Yield Capacity (tons) | Water Usage (m³/ton) | Fertilizer Usage (kg/ton) |\n| ---- | ----------------------- | --------------------- | -------------------- | ------------------------- |\n| A    | 100                     | 500                   | 6                    | 5                         |\n| B    | 120                     | 400                   | 8                    | 4                         |\n| C    | 150                     | 600                   | 6                    | 3                         |\n\nThe demand (in tons) for each grocery store is as follows:\n\n| Store 1 | Store 2 | Store 3 | Store 4 |\n| ------- | ------- | ------- | ------- |\n| 200     | 300     | 400     | 500     |\n\nThe transportation cost (in $/ton) from each farm to each grocery store is given in the table below:\n\n| Farm | Store 1 | Store 2 | Store 3 | Store 4 |\n| ---- | ------- | ------- | ------- | ------- |\n| A    | 20      | 25      | 30      | 15      |\n| B    | 22      | 26      | 32      | 18      |\n| C    | 18      | 24      | 28      | 14      |\n\nTo meet sustainability goals, the total produce shipped must use no more than 7 m³ of water per ton and no more than 4 kg of fertilizer per ton. How to minimize the total cost while satisfying the demand and sustainability constraints?",
    "ground_truth": 203500.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_farm_production_optimization(\n    ProductionCost=[100, 120, 150],\n    YieldCapacity=[500, 400, 600],\n    WaterUsage=[6, 8, 6],\n    FertilizerUsage=[5, 4, 3],\n    Demand=[200, 300, 400, 500],\n    TransportationCost=[\n        [20, 25, 30, 15],\n        [22, 26, 32, 18],\n        [18, 24, 28, 14]\n    ],\n    MaxWaterUsageperTon=7,\n    MaxFertilizerUsageperTon=4\n):\n    \"\"\"\n    Models and solves the farm production and distribution optimization problem.\n    \"\"\"\n    # Create a new model\n    model = gp.Model(\"Farm Production and Distribution Optimization\")\n\n    # Sets\n    Farms = range(len(ProductionCost))\n    Stores = range(len(Demand))\n\n    # Decision Variables\n    AmountProduced = {}\n    for f in Farms:\n        for s in Stores:\n            AmountProduced[f, s] = model.addVar(\n                vtype=GRB.CONTINUOUS,\n                name=f\"AmountProduced_{f+1}_{s+1}\"\n            )\n\n    # Objective: Minimize total production and transportation costs\n    obj = gp.quicksum(\n        ProductionCost[f] * AmountProduced[f, s] + TransportationCost[f][s] * AmountProduced[f, s]\n        for f in Farms\n        for s in Stores\n    )\n    model.setObjective(obj, GRB.MINIMIZE)\n\n    # Constraint 1: Demand constraint - each store's demand must be met\n    for s in Stores:\n        model.addConstr(\n            gp.quicksum(AmountProduced[f, s] for f in Farms) >= Demand[s],\n            f\"Demand_{s+1}\"\n        )\n\n    # Constraint 2: Yield capacity constraint - each farm's production cannot exceed capacity\n    for f in Farms:\n        model.addConstr(\n            gp.quicksum(AmountProduced[f, s] for s in Stores) <= YieldCapacity[f],\n            f\"YieldCapacity_{f+1}\"\n        )\n\n    # Constraint 3: Water usage constraint - average water usage cannot exceed maximum\n    total_production = gp.quicksum(AmountProduced[f, s] for f in Farms for s in Stores)\n    total_water_usage = gp.quicksum(WaterUsage[f] * AmountProduced[f, s] for f in Farms for s in Stores)\n    model.addConstr(\n        total_water_usage <= MaxWaterUsageperTon * total_production,\n        \"WaterUsage\"\n    )\n\n    # Constraint 4: Fertilizer usage constraint - average fertilizer usage cannot exceed maximum\n    total_fertilizer_usage = gp.quicksum(FertilizerUsage[f] * AmountProduced[f, s] for f in Farms for s in Stores)\n    model.addConstr(\n        total_fertilizer_usage <= MaxFertilizerUsageperTon * total_production,\n        \"FertilizerUsage\"\n    )\n\n    # Optimize the model\n    model.optimize()\n\n    # Return Results\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_farm_production_optimization()\n    print(result)\n",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Supply Chain Optimization",
        "modeling_type": "LP",
        "industry_sector": "Agriculture",
        "reason": "The problem involves optimizing the flow of goods from farms (suppliers) to grocery stores (demand points) while considering production, transportation costs, and resource usage constraints, which falls under supply chain optimization. The model uses continuous variables and linear objective/constraints, making it a Linear Program. The context of farms and grocery stores clearly places it in the agriculture sector."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D008",
    "description": "In a city planning scenario, it is necessary to select locations for public transport stations to serve a set of 15 passenger demand points, with 5 potential station locations available. The distance from each demand point to each potential station is known, and a demand point is considered \"\"covered\"\" by a station only if the distance between them is no more than 300 meters. What is the minimum number of stations that need to be selected to ensure all demand points are covered?\nThe distance matrix between each demand point and each potential station is as follows:\n| demand node\\stop | 1    | 2    | 3    | 4    | 5    |\n|-----------|------|------|------|------|------|\n| 1         | 389  | 515  | 170  | 143  | 617  |\n| 2         | 562  | 678  | 265  | 640  | 629  |\n| 3         | 206  | 594  | 180  | 564  | 683  |\n| 4         | 574  | 105  | 311  | 99   | 550  |\n| 5         | 616  | 490  | 99   | 473  | 682  |\n| 6         | 571  | 258  | 494  | 749  | 61   |\n| 7         | 573  | 234  | 207  | 635  | 318  |\n| 8         | 70   | 53   | 399  | 740  | 494  |\n| 9         | 229  | 190  | 550  | 654  | 394  |\n| 10        | 50   | 56   | 459  | 143  | 478  |\n| 11        | 95   | 378  | 507  | 647  | 135  |\n| 12        | 767  | 200  | 569  | 689  | 621  |\n| 13        | 729  | 333  | 91   | 86   | 386  |\n| 14        | 633  | 163  | 562  | 184  | 384  |\n| 15        | 67   | 515  | 224  | 502  | 345  |",
    "ground_truth": 3.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_stop_location(\n    distance=[\n        [389, 515, 170, 143, 617], [562, 678, 265, 640, 629],\n        [206, 594, 180, 564, 683], [574, 105, 311, 99, 550],\n        [616, 490, 99, 473, 682], [571, 258, 494, 749, 61],\n        [573, 234, 207, 635, 318], [70, 53, 399, 740, 494],\n        [229, 190, 550, 654, 394], [50, 56, 459, 143, 478],\n        [95, 378, 507, 647, 135], [767, 200, 569, 689, 621],\n        [729, 333, 91, 86, 386], [633, 163, 562, 184, 384],\n        [67, 515, 224, 502, 345]\n    ],\n    coverage_distance=300\n):\n    \"\"\"\n    Models and solves the set covering problem for stop locations.\n    \"\"\"\n    # --- 1. Model Creation ---\n    model = gp.Model(\"StopLocationProblem\")\n\n    # --- 2. Sets and Parameters ---\n    # Derive sets from the dimensions of the input data\n    demand_nodes = range(len(distance))\n    stops = range(len(distance[0]))\n\n    # Create a coverage parameter: a[j, i] = 1 if stop i covers demand node j\n    a = {}\n    for j in demand_nodes:\n        for i in stops:\n            if distance[j][i] <= coverage_distance:\n                a[j, i] = 1\n            else:\n                a[j, i] = 0\n\n    # --- 3. Decision Variables ---\n    # x[i] = 1 if stop i is selected, 0 otherwise\n    x = model.addVars(stops, vtype=GRB.BINARY, name=\"select_stop\")\n\n    # --- 4. Objective Function ---\n    # Minimize the number of stops selected\n    model.setObjective(gp.quicksum(x[i] for i in stops), GRB.MINIMIZE)\n\n    # --- 5. Constraints ---\n    # Each demand node must be covered by at least one selected stop\n    for j in demand_nodes:\n        model.addConstr(gp.quicksum(a[j, i] * x[i] for i in stops) >= 1,\n                        name=f\"cover_demand_{j}\")\n\n    # --- 6. Solve the Model ---\n    model.setParam(\"OutputFlag\", 0)  # Suppress Gurobi output\n    model.optimize()\n\n    # --- 7. Return Results ---\n    if model.status == GRB.OPTIMAL:\n        # The objective value for this problem is an integer\n        return {\"status\": \"optimal\", \"obj\": int(model.ObjVal)}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\n# Run the solver function\nif __name__ == \"__main__\":\n    result = solve_stop_location()\n    print(result)\n",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Covering",
        "modeling_type": "MILP",
        "industry_sector": "Transportation",
        "reason": "The problem aims to select the minimum number of public transport stations to cover all demand points, which is a classic set covering problem. The solver uses binary decision variables and linear constraints, making it a Mixed-Integer Linear Program (MILP). The application context of selecting public transport stations clearly falls under the transportation sector."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D035",
    "description": "### Problem Description:\nChemCo produces two types of solvents: Standard and Premium. The solvents are produced by blending five raw materials: Alpha, Beta, Gamma, Delta, and Epsilon. Each raw material has four key properties:\n\n1.  Property 1: Viscosity Index (VI)\n2.  Property 2: Flash Point (°C)\n3.  Property 3: Boiling Point (°C)\n4.  Property 4: Density (g/cm³)\n\nThe properties, daily availability (in liters), and cost (in ¢/liter) of each raw material are given in Table 1.\n\nTable 1: Raw Materials' Properties, Daily Availability, and Costs\n\n| Raw Material | Availability (Liters) | Cost (¢/Liter) | VI  | Flash Point (°C) | Boiling Point (°C) | Density (g/cm³) |\n|--------------|-----------------------|----------------|-----|------------------|--------------------|-----------------|\n| Alpha        | 12,000                | 15.0           | 95  | 45               | 150                | 0.85            |\n| Beta         | 10,500                | 12.0           | 88  | 55               | 180                | 0.92            |\n| Gamma        | 8,000                 | 10.0           | 82  | 60               | 200                | 0.89            |\n| Delta        | 5,000                 | 18.0           | 105 | 40               | 130                | 0.87            |\n| Epsilon      | Unlimited             | 16.0           | 100 | 50               | 160                | 0.91            |\n\nThe final properties of the blended solvents are determined by the volume-weighted average of the properties of the raw materials used. The requirements for each solvent type are provided in Table 2. The Viscosity Index and Boiling Point requirements are minimums, while the Flash Point and Density requirements must be met exactly.\n\nTable 2: Solvent Requirements and Demand\n\n| Solvent  | Demand (Thousands of Liters) | VI (min) | Flash Point (°C) (exact) | Boiling Point (°C) (min) | Density (g/cm³) (exact) |\n|----------|-------------------------------|----------|--------------------------|--------------------------|------------------------|\n| Standard | 8.5                           | 85       | 50                       | 140                      | 0.88                   |\n| Premium  | 25                            | 92       | 50                       | 140                      | 0.88                   |\n\nThe daily demand (in thousands of liters) for each solvent must be met, but additional production beyond the demand is allowed. Standard solvent sells for 25.50¢/liter, while Premium solvent sells for 28.75¢/liter. Additionally, no more than 35% of the volume of each solvent type can consist of raw material Beta. How can ChemCo formulate its solvents using the available raw materials to maximize its total daily profit? Total daily profit is defined as total revenue from sales minus total raw material costs.",
    "ground_truth": 474250.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_solvent_blending_optimization(\n    Availability=[12000, 10500, 8000, 5000, 999999],\n    Cost=[15, 12, 10, 18, 16],\n    PropertyValue=[\n        [95, 45, 150, 0.85],\n        [88, 55, 180, 0.92],\n        [82, 60, 200, 0.89],\n        [105, 40, 130, 0.87],\n        [100, 50, 160, 0.91]\n    ],\n    SolventPropertyValue=[\n        [85, 50, 140, 0.88],\n        [92, 50, 140, 0.88]\n    ],\n    Demand=[8500, 25000],\n    SellingPrice=[25.50, 28.75],\n    MaxBetaPercentage=0.35\n):\n    \"\"\"\n    Models and solves the solvent blending optimization problem.\n    \"\"\"\n    # Create a new model\n    model = gp.Model(\"Solvent Blending Optimization\")\n\n    # Sets\n    Solvents = range(len(Demand))\n    RawMaterials = range(len(Cost))\n    Properties = range(len(PropertyValue[0]))\n\n    # Decision Variables\n    AmountProduced = {}\n    for s in Solvents:\n        for r in RawMaterials:\n            AmountProduced[s, r] = model.addVar(\n                vtype=GRB.CONTINUOUS,\n                name=f\"AmountProduced_{s+1}_{r+1}\"\n            )\n\n    # Objective: Maximize profit (revenue from demand only - total production cost)\n    total_revenue = gp.quicksum(SellingPrice[s] * Demand[s] for s in Solvents)\n    total_cost = gp.quicksum(\n        Cost[r] * gp.quicksum(AmountProduced[s, r] for s in Solvents)\n        for r in RawMaterials\n    )\n    model.setObjective(total_revenue - total_cost, GRB.MAXIMIZE)\n\n    # Constraint 1: Demand constraint (production must meet exactly the demand)\n    for s in Solvents:\n        model.addConstr(\n            gp.quicksum(AmountProduced[s, r] for r in RawMaterials) == Demand[s],\n            f\"Demand_{s+1}\"\n        )\n\n    # Constraint 2: Availability constraint\n    for r in RawMaterials:\n        model.addConstr(\n            gp.quicksum(AmountProduced[s, r] for s in Solvents) <= Availability[r],\n            f\"Availability_{r+1}\"\n        )\n\n    # Constraint 3: Property constraints\n    for s in Solvents:\n        # For properties 0 (VI) and 2 (Boiling Point) - minimum requirements\n        for p in [0, 2]:\n            model.addConstr(\n                gp.quicksum(PropertyValue[r][p] * AmountProduced[s, r] for r in RawMaterials) >=\n                SolventPropertyValue[s][p] * gp.quicksum(AmountProduced[s, r] for r in RawMaterials),\n                f\"MinProperty_{s+1}_{p+1}\"\n            )\n\n        # For properties 1 (Flash Point) and 3 (Density) - exact requirements\n        for p in [1, 3]:\n            model.addConstr(\n                gp.quicksum(PropertyValue[r][p] * AmountProduced[s, r] for r in RawMaterials) ==\n                SolventPropertyValue[s][p] * gp.quicksum(AmountProduced[s, r] for r in RawMaterials),\n                f\"ExactProperty_{s+1}_{p+1}\"\n            )\n\n    # Constraint 4: Beta constraint (raw material 1 is Beta)\n    for s in Solvents:\n        model.addConstr(\n            AmountProduced[s, 1] <= MaxBetaPercentage * gp.quicksum(AmountProduced[s, r] for r in RawMaterials),\n            f\"BetaLimit_{s+1}\"\n        )\n\n    # Optimize the model\n    model.optimize()\n\n    # Return Results\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_solvent_blending_optimization()\n    print(result)\n",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Blending",
        "modeling_type": "LP",
        "industry_sector": "Manufacturing",
        "reason": "The problem involves mixing different raw materials to produce various solvents while satisfying quality specifications and resource constraints, which is characteristic of a blending problem. The objective function and all constraints are linear, and variables are continuous, making it a Linear Program. The application is in chemical production, fitting the manufacturing sector."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D021",
    "description": "A manufacturing plant specializes in producing customized parts, where production is scheduled based on customer orders. The factory has five machines (M1-M5), each with distinct functions: M1 for cutting, M2 for drilling, M3 for welding, M4 for polishing, and M5 for final assembly. Currently, four orders (J1-J4) have been received, each requiring a fixed sequence of processing steps that must be completed on specific machines in a prescribed order. The processing steps, required machines, and execution times for each task are as follows:\n\nJ1: (1) Cutting on M1, taking 3 hours; (2) Drilling on M2, taking 2 hours; (3) Assembly on M5, taking 4 hours.  \nJ2: (1) Welding on M3, taking 4 hours; (2) Polishing on M4, taking 3 hours; (3) Assembly on M5, taking 2 hours.  \nJ3: (1) Drilling on M2, taking 3 hours; (2) Cutting on M1, taking 5 hours; (3) Polishing on M4, taking 2 hours.  \nJ4: (1) Cutting on M1, taking 2 hours; (2) Welding on M3, taking 3 hours; (3) Polishing on M4, taking 4 hours.  \n\nEach machine can only handle one task at a time and cannot process multiple tasks simultaneously. Once a step begins processing, it cannot be paused or interrupted midway. How should the order processing be scheduled to minimize the total completion time for all tasks?",
    "ground_truth": 13.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\nimport json\nimport os\nmachines = list(range(1, 6))  # M = {1, 2, 3, 4, 5}\njobs = list(range(1, 5))  # J = {1, 2, 3, 4}\n\n# JobProcess[j-1] contains a list of tuples (machine, process_time) for job j\njob_processes = [\n    [(1, 3), (2, 2), (5, 4)],  # Job 1 processes\n    [(3, 4), (4, 3), (5, 2)],  # Job 2 processes\n    [(2, 3), (1, 5), (4, 2)],  # Job 3 processes\n    [(1, 2), (3, 3), (4, 4)]  # Job 4 processes\n]\n\nmachine_id = ['M1', 'M2', 'M3', 'M4', 'M5']\njob_id = ['J1', 'J2', 'J3', 'J4']\n\ndef solve_job_shop_scheduling(job_processes=[[(1, 3), (2, 2), (5, 4)], [(3, 4), (4, 3), (5, 2)], [(2, 3), (1, 5), (4, 2)], [(1, 2), (3, 3), (4, 4)]]):\n    # Data\n    machines = list(range(1, 6))\n    jobs = list(range(1, 5))\n\n    # Create a new model\n    model = gp.Model(\"JobShopScheduling\")\n\n    # Calculate a big-M value (an upper bound on the makespan)\n    big_M = sum(duration for job in job_processes for _, duration in job)\n\n    # Create decision variables\n    start_times = {}\n    for j in range(len(jobs)):\n        for k in range(len(job_processes[j])):\n            start_times[j, k] = model.addVar(vtype=GRB.INTEGER,\n                                             lb=0,\n                                             name=f\"StartTime_{j+1}_{k+1}\")\n\n    # Create makespan variable\n    makespan = model.addVar(vtype=GRB.INTEGER, name=\"Makespan\")\n\n    # Set objective\n    model.setObjective(makespan, GRB.MINIMIZE)\n\n    # Constraint 1: The start time of the next process must be greater than or equal to the end time of the previous process\n    for j in range(len(jobs)):\n        for k in range(len(job_processes[j]) - 1):\n            model.addConstr(\n                start_times[j,\n                            k + 1] >= start_times[j, k] + job_processes[j][k][1],\n                f\"PrecedenceJob_{j+1}_Process_{k+1}_to_{k+2}\")\n\n    # Constraint 2: One machine can only process one job at a time\n    for m in machines:\n        # Find all processes that use this machine\n        processes_on_machine = []\n        for j in range(len(jobs)):\n            for k in range(len(job_processes[j])):\n                if job_processes[j][k][0] == m:\n                    processes_on_machine.append((j, k))\n\n        # Add non-overlap constraints for each pair of processes on this machine\n        for i in range(len(processes_on_machine)):\n            for j in range(i + 1, len(processes_on_machine)):\n                j1, k1 = processes_on_machine[i]\n                j2, k2 = processes_on_machine[j]\n\n                # Either j1,k1 finishes before j2,k2 starts OR j2,k2 finishes before j1,k1 starts\n                indicator = model.addVar(\n                    vtype=GRB.BINARY,\n                    name=f\"Indicator_{j1+1}_{k1+1}_{j2+1}_{k2+1}\")\n                model.addConstr(\n                    start_times[j1, k1] + job_processes[j1][k1][1]\n                    <= start_times[j2, k2] + big_M * (1 - indicator),\n                    f\"NoOverlap1_{j1+1}_{k1+1}_{j2+1}_{k2+1}\")\n                model.addConstr(\n                    start_times[j2, k2] + job_processes[j2][k2][1]\n                    <= start_times[j1, k1] + big_M * indicator,\n                    f\"NoOverlap2_{j1+1}_{k1+1}_{j2+1}_{k2+1}\")\n\n    # Constraint 3: The start time of the first process must be greater than or equal to 0\n    for j in range(len(jobs)):\n        model.addConstr(start_times[j, 0] >= 0, f\"NonNegativeStart_{j+1}\")\n\n    # Constraint for makespan: makespan is the maximum completion time among all jobs\n    for j in range(len(jobs)):\n        last_process = len(job_processes[j]) - 1\n        model.addConstr(\n            makespan\n            >= start_times[j, last_process] + job_processes[j][last_process][1],\n            f\"MakespanDef_{j+1}\")\n\n    # Solve the model\n    model.optimize()\n\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\nif __name__ == \"__main__\":\n    result = solve_job_shop_scheduling()\n    print(result)\n",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Scheduling",
        "modeling_type": "MILP",
        "industry_sector": "Manufacturing",
        "reason": "The problem involves sequencing tasks on machines to minimize the total completion time (makespan), which is a classic scheduling problem. The solver uses integer variables for start times and binary variables for precedence, along with linear constraints, making it a Mixed-Integer Linear Program."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D006",
    "description": "Now, from 6 individuals (A, B, C, D, E, F), 5 are to be selected to complete 5 tasks (1-5). The time each person takes to complete each task is shown in the table below:\n\n| task\\person | A | B | C | D | E | F |\n|---|---|---|---|---|---|---|\n| 1 | 5 | 2 | 3 | 15 | 9 | 10 |\n| 2 | 5 | 6 | 15 | 2 | 4 | 7 |\n| 3 | 15 | 5 | 14 | 7 | 15 | 6 |\n| 4 | 20 | 15 | 18 | 6 | 8 | 11 |\n| 5 | 8 | 11 | 18 | 10 | 15 | 6 |\n\nIt is stipulated that each person can only complete one task. Due to certain reasons, individual A must be assigned a task, and individual D cannot be assigned task 4. What is the minimum total time spent?",
    "ground_truth": 26.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_task_assignment(\n    complete_time=[\n        [5, 2, 3, 15, 9, 10],\n        [5, 6, 15, 2, 4, 7],\n        [15, 5, 14, 7, 15, 6],\n        [20, 15, 18, 6, 8, 11],\n        [8, 11, 18, 10, 15, 6],\n    ]\n):\n    \"\"\"\n    Models and solves the task assignment problem.\n    \"\"\"\n    # --- 1. Model Creation ---\n    model = gp.Model(\"TaskAssignment\")\n\n    # --- 2. Sets ---\n    # The number of tasks is the number of rows in complete_time.\n    # The number of persons is the number of columns.\n    num_tasks = len(complete_time)\n    num_persons = len(complete_time[0])\n    tasks = range(num_tasks)\n    persons = range(num_persons)\n\n    # --- 3. Decision Variables ---\n    # x[p, t] = 1 if person p is assigned to task t, 0 otherwise\n    x = model.addVars(persons, tasks, vtype=GRB.BINARY, name=\"assign\")\n\n    # --- 4. Objective Function ---\n    # Minimize total completion time. Note: complete_time is indexed by [task][person].\n    objective = gp.quicksum(complete_time[t][p] * x[p, t]\n                           for p in persons for t in tasks)\n    model.setObjective(objective, GRB.MINIMIZE)\n\n    # --- 5. Constraints ---\n    # Constraint 1: Each person can be assigned to at most one task.\n    for p in persons:\n        model.addConstr(gp.quicksum(x[p, t] for t in tasks) <= 1,\n                        name=f\"person_at_most_one_task_{p}\")\n\n    # Constraint 2: Each task must be assigned to exactly one person.\n    for t in tasks:\n        model.addConstr(gp.quicksum(x[p, t] for p in persons) == 1,\n                        name=f\"task_must_be_assigned_{t}\")\n\n    # Constraint 3: Person A (index 0) must be assigned to exactly one task.\n    # This makes the general constraint (<=1) redundant for Person A, but is included\n    # to match the problem's specific requirements.\n    model.addConstr(gp.quicksum(x[0, t] for t in tasks) == 1,\n                    name=\"person_A_must_work\")\n\n    # Constraint 4: Person D (index 3) cannot be assigned to task 4 (index 3).\n    model.addConstr(x[3, 3] == 0, name=\"person_D_task_4_restriction\")\n\n    # --- 6. Solve the Model ---\n    model.setParam(\"OutputFlag\", 0)  # Suppress Gurobi output\n    model.optimize()\n\n    # --- 7. Return Results ---\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\n# Run the solver function\nif __name__ == \"__main__\":\n    result = solve_task_assignment()\n    print(result)\n",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Assignment",
        "modeling_type": "MILP",
        "industry_sector": "General Operations",
        "reason": "The problem involves assigning individuals to tasks to minimize total time, which is a classic assignment problem. The formulation uses binary decision variables and linear constraints, making it a Mixed-Integer Linear Program. This type of problem is fundamental to general operational efficiency across various sectors."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D018",
    "description": "A fresh food e-commerce platform has one distribution center in the city and needs to use a fleet of refrigerated trucks to deliver fresh products to 12 supermarkets. Each supermarket has a specified time window for receiving goods and a specified unloading time. The distribution center has 5 identical refrigerated trucks, each with a maximum load of 3 tons and a speed of 40 km/h. The coordinates of the distribution center are (0, 0), and the information of the supermarkets is as follows:\n\n| SUPERMARKET ID | (x,y) | DEMAND(kg) | TIME WINDOW | UNLOADING TIME(min) |\n|---------|-----------|------------|--------------|--------------|\n| S1      | (-5, 4)   | 800        | [7:00-9:00]  | 20           |\n| S2      | (3, 6)    | 600        | [8:00-10:00] | 15           |\n| S3      | (-2, -3)  | 900        | [7:30-9:30]  | 25           |\n| S4      | (4, -2)   | 700        | [8:30-10:30] | 20           |\n| S5      | (-4, -5)  | 500        | [9:00-11:00] | 15           |\n| S6      | (6, 3)    | 850        | [7:00-9:00]  | 25           |\n| S7      | (-3, 5)   | 750        | [8:00-10:00] | 20           |\n| S8      | (5, -4)   | 600        | [9:30-11:30] | 15           |\n| S9      | (-6, -2)  | 450        | [8:00-10:00] | 15           |\n| S10     | (2, 7)    | 800        | [7:30-9:30]  | 20           |\n| S11     | (-1, -6)  | 550        | [9:00-11:00] | 15           |\n| S12     | (4, 5)    | 700        | [8:30-10:30] | 20           |\n\nThe 5 refrigerated trucks leave the distribution center after 6:30 AM to deliver fresh products to the designated supermarkets and must return to the distribution center before 12:00 PM. What is the shortest total travel distance for the refrigerated trucks? (Distances are calculated as straight-line distances in kilometers.)",
    "ground_truth": 78.7839681501,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\nimport math\n\n\ndef solve_vrptw(\n    coordinates=[(0, 0), (-5, 4), (3, 6), (-2, -3), (4, -2), (-4, -5), (6, 3),\n                 (-3, 5), (5, -4), (-6, -2), (2, 7), (-1, -6), (4, 5)],\n    time_windows=[(6.5, 12), (7, 9), (8, 10), (7.5, 9.5), (8.5, 10.5),\n                  (9, 11), (7, 9), (8, 10), (9.5, 11.5), (8, 10), (7.5, 9.5),\n                  (9, 11), (8.5, 10.5)],\n    demands=[0, 800, 600, 900, 700, 500, 850, 750, 600, 450, 800, 550, 700],\n    unloading_times=[0, 20, 15, 25, 20, 15, 25, 20, 15, 15, 20, 15, 20],\n    truck_num=5,\n    speed=40,\n    M=50000):\n    \"\"\"\n    Solves the Vehicle Routing Problem with Time Windows (VRPTW).\n    \"\"\"\n    supermarket_num = len(coordinates) - 1\n    nodes = range(supermarket_num + 1)  # 0 is DC, 1-12 are supermarkets\n    trucks = range(truck_num)  # 0-4 are trucks\n\n    # Calculate distance matrix\n    def calculate_distance(coord1, coord2):\n        return math.sqrt((coord1[0] - coord2[0])**2 +\n                         (coord1[1] - coord2[1])**2)\n\n    distance = {}\n    for i in nodes:\n        for j in nodes:\n            if i != j:\n                distance[i, j] = calculate_distance(coordinates[i],\n                                                    coordinates[j])\n\n    # --- Model Initialization ---\n    model = gp.Model(\"MultiVehicleTimeWindowedVRP\")\n\n    # --- Decision variables ---\n    # x[i,j,k] = 1 if truck k travels from i to j\n    x = {}\n    for i in nodes:\n        for j in nodes:\n            if i != j:\n                for k in trucks:\n                    x[i, j, k] = model.addVar(vtype=GRB.BINARY,\n                                              name=f'x_{i}_{j}_{k}')\n\n    # t_a[i] = arrival time at node i\n    t_a = model.addVars(nodes,\n                        lb=[time_windows[i][0] for i in nodes],\n                        ub=[time_windows[i][1] for i in nodes],\n                        name='t_a')\n\n    # t_d[i] = departure time from node i\n    t_d = model.addVars(nodes,\n                        lb=[time_windows[i][0] for i in nodes],\n                        ub=[time_windows[i][1] for i in nodes],\n                        name='t_d')\n\n    # --- Objective function ---\n    # Set objective: minimize total distance\n    objective = gp.quicksum(distance[i, j] * x[i, j, k] for i in nodes\n                            for j in nodes for k in trucks if i != j)\n    model.setObjective(objective, GRB.MINIMIZE)\n\n    # --- Constraints ---\n    # Constraint 1: Each supermarket must be visited exactly once by one truck\n    for j in nodes:\n        if j != 0:  # Skip DC\n            model.addConstr(\n                gp.quicksum(x[i, j, k] for i in nodes for k in trucks\n                            if i != j) == 1,\n                name=f'visit_to_{j}')\n\n    # Constraint 2: Each supermarket must be exited exactly once by one truck\n    for i in nodes:\n        if i != 0:  # Skip DC\n            model.addConstr(\n                gp.quicksum(x[i, j, k] for j in nodes for k in trucks\n                            if i != j) == 1,\n                name=f'leave_from_{i}')\n\n    # Constraint 3: Each truck must leave the DC once\n    for k in trucks:\n        model.addConstr(gp.quicksum(x[0, j, k] for j in nodes if j != 0) == 1,\n                        name=f'truck_{k}_leaves_dc')\n\n    # Constraint 4: Each truck must return to the DC once\n    for k in trucks:\n        model.addConstr(gp.quicksum(x[i, 0, k] for i in nodes if i != 0) == 1,\n                        name=f'truck_{k}_returns_dc')\n\n    # Flow conservation for each truck at each supermarket\n    for k in trucks:\n        for h in nodes:\n            if h != 0:  # Skip DC\n                model.addConstr(\n                    gp.quicksum(x[i, h, k] for i in nodes if i != h) ==\n                    gp.quicksum(x[h, j, k] for j in nodes if j != h),\n                    name=f'flow_cons_truck_{k}_node_{h}')\n\n    # Time window constraints\n    for i in nodes[1:]:  # Skip DC\n        # Departure time must be after arrival time plus unloading time\n        model.addConstr(t_d[i] >= t_a[i] + unloading_times[i] / 60,\n                        name=f'depart_after_unload_{i}')\n\n    # Time consistency constraints\n    for i in nodes:\n        for j in nodes:\n            if i != j:\n                for k in trucks:\n                    # If truck k goes from i to j, arrival time at j must be after\n                    # departure from i plus travel time\n                    model.addConstr(\n                        t_d[i] + distance[i, j] / speed - M *\n                        (1 - x[i, j, k]) <= t_a[j],\n                        name=f'time_cons_min_{i}_{j}_{k}')\n                    model.addConstr(\n                        t_d[i] + distance[i, j] / speed + M *\n                        (1 - x[i, j, k]) >= t_a[j],\n                        name=f'time_cons_max_{i}_{j}_{k}')\n\n    def find_subtours(edges):\n        # Create adjacency list\n        adj = {i: [] for i in nodes}\n        for i, j in edges:\n            adj[i].append(j)\n\n        # Find all subtours\n        unvisited = set(nodes)\n        subtours = []\n        while unvisited:\n            current = next(iter(unvisited))\n            subtour = []\n            while current in unvisited:\n                unvisited.remove(current)\n                subtour.append(current)\n                next_nodes = adj.get(current, [])\n                if not next_nodes:\n                    break\n                current = next_nodes[0]\n            if len(subtour) < len(nodes):\n                subtours.append(subtour)\n        return subtours\n\n    def subtour_cb(model, where):\n        if where == GRB.Callback.MIPSOL:\n            # Get values of binary variables\n            x_vals = model.cbGetSolution(model._vars)\n            edges = [(i, j, k) for i in nodes for j in nodes for k in trucks\n                     if i != j and x_vals[i, j, k] > 0.5]\n\n            # Find subtours for each truck\n            for k in trucks:\n                truck_edges = [(i, j) for i, j, k_idx in edges if k_idx == k]\n                subtours = find_subtours(truck_edges)\n\n                # Add subtour elimination constraints\n                for S in subtours:\n                    if len(S) < len(nodes) and 0 not in S:\n                        model.cbLazy(\n                            gp.quicksum(x[i, j, k] for i in S for j in S\n                                        if i != j) <= len(S) - 1)\n\n    # Enable lazy constraints\n    model._vars = x\n    model.Params.lazyConstraints = 1\n\n    # Optimize model with callback\n    model.optimize(subtour_cb)\n\n    # --- Return Results ---\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_vrptw()\n    print(result)\n",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Routing",
        "modeling_type": "MILP",
        "industry_sector": "Retail",
        "reason": "The problem involves optimizing routes for a fleet of trucks to deliver goods to multiple supermarkets, which is a classic Vehicle Routing Problem with Time Windows (VRPTW). The solver uses binary and continuous variables, linear constraints, and an objective function, making it a Mixed-Integer Linear Program. The application is for a fresh food e-commerce platform delivering to supermarkets, fitting the retail sector."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D068",
    "description": "A regional water distribution company needs to optimize its pipeline network to maximize the daily water supply from Reservoir A (source) to City D (sink). The network consists of 5 pumping stations (nodes B, C, E, F, G) connected by pipelines with the following capacities (in thousand cubic meters/day): A→B (15), A→C (10), B→C (5), B→D (10), C→E (8), C→F (12), E→D (7), F→D (20), G→D (0, currently inactive). Pumping station G is temporarily out of service. The system must maintain flow conservation at all intermediate nodes while respecting pipeline capacities.",
    "ground_truth": 25.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\ndef solve_max_flow(\n    nodes=['A', 'B', 'C', 'D', 'E', 'F', 'G'],\n    arcs={\n        ('A', 'B'): 15,\n        ('A', 'C'): 10,\n        ('B', 'C'): 5,\n        ('B', 'D'): 10,\n        ('C', 'E'): 8,\n        ('C', 'F'): 12,\n        ('E', 'D'): 7,\n        ('F', 'D'): 20,\n        ('G', 'D'): 0\n    }\n):\n    \"\"\"Solve the maximum flow problem for water distribution network.\"\"\"\n    \n    model = gp.Model(\"WaterDistributionMaxFlow\")\n    \n    active_arcs = {k: v for k, v in arcs.items() if v > 0}\n    \n    flow = model.addVars(active_arcs.keys(), name=\"flow\")\n    \n    model.setObjective(flow.sum('A', '*'), GRB.MAXIMIZE)\n    \n    model.addConstrs((flow[i,j] <= active_arcs[i,j] for i,j in active_arcs), \"capacity\")\n    \n    intermediate_nodes = [n for n in nodes if n not in ['A', 'D']]\n    \n    for node in intermediate_nodes:\n        inflow = gp.quicksum(flow[i,j] for i,j in active_arcs if j == node)\n        outflow = gp.quicksum(flow[i,j] for i,j in active_arcs if i == node)\n        model.addConstr(inflow == outflow, f\"flow_conserv_{node}\")\n    \n    model.optimize()\n    \n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.objVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\nif __name__ == \"__main__\":\n    result = solve_max_flow()\n    print(result)",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Network Flow",
        "modeling_type": "LP",
        "industry_sector": "Utilities",
        "reason": "The problem explicitly asks to maximize water supply through a pipeline network with given capacities, which is a classic maximum flow problem. The solver program uses linear constraints and an objective function, fitting the Linear Programming (LP) paradigm. The application is about water distribution, which falls under the Utilities sector."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D045",
    "description": "At the start of month 1, SupplyChain Dynamics has $50,000 in available funds. At the beginning of months 1, 2, 3, and 4, the company receives specific revenues from its logistics operations, after which it must pay operational expenses(see table below). Any remaining funds can be allocated to short-term investments with the following options (Interest is earned after paying operational expenses):  \n- Invest for one month at an interest rate of 0.2% per month.  \n- Invest for two months at an interest rate of 0.8% per month.  \n- Invest for three months at an interest rate of 1.5% per month.  \n- Invest for four months at an interest rate of 3% per month.  \n\nHow can SupplyChain Dynamics allocate its funds to maximize the cash on hand at the beginning of month 5 while meeting its operational obligations?\n\n| Month | Revenue ($) | Operational Expenses ($) |  \n|-------|-------------|---------------------------|  \n| 1     | 20,000      | 15,000                    |  \n| 2     | 25,000      | 35,000                    |  \n| 3     | 30,000      | 22,000                    |  \n| 4     | 35,000      | 28,000                    |",
    "ground_truth": 65542.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_fund_allocation(\n    initial_funds=50000.0,\n    revenues={1: 20000.0, 2: 25000.0, 3: 30000.0, 4: 35000.0},\n    expenses={1: 15000.0, 2: 35000.0, 3: 22000.0, 4: 28000.0},\n    monthly_interest_rates={\n        1: 0.002,\n        2: 0.008,\n        3: 0.015,\n        4: 0.030\n    }\n):\n    \"\"\"\n    Solves the SupplyChain Dynamics fund allocation problem.\n    \"\"\"\n    try:\n        # --- 1. Model Data ---\n        months_invest = [1, 2, 3, 4]\n        months_balance = [1, 2, 3, 4]\n        investment_durations = [1, 2, 3, 4]\n\n        # --- 2. Create Gurobi Model ---\n        model = gp.Model(\"SupplyChainFundAllocation\")\n        model.Params.LogToConsole = 0\n\n        # --- 3. Decision Variables ---\n        X = model.addVars([(t, d) for t in months_invest for d in investment_durations if t + d <= 5],\n                          name=\"InvestAmount\", lb=0.0, vtype=GRB.CONTINUOUS)\n        C = model.addVars(months_balance, name=\"CashOnHandEndOfMonth\", lb=0.0, vtype=GRB.CONTINUOUS)\n\n        # --- 4. Objective Function ---\n        cash_at_month_5_start = C[4] + gp.quicksum(\n            X[t, d] * (1 + d * monthly_interest_rates[d])\n            for t in months_invest for d in investment_durations if (t, d) in X and t + d == 5)\n        model.setObjective(cash_at_month_5_start, GRB.MAXIMIZE)\n\n        # --- 5. Constraints ---\n        for t in months_invest:\n            if t == 1:\n                funds_in = initial_funds + revenues[t] - expenses[t]\n            else:\n                cash_from_last_month = C[t - 1]\n                maturing_investments_value = gp.quicksum(\n                    X[t_invest, d_invest] * (1 + d_invest * monthly_interest_rates[d_invest])\n                    for t_invest in months_invest for d_invest in investment_durations\n                    if (t_invest, d_invest) in X and t_invest + d_invest == t)\n                funds_in = cash_from_last_month + maturing_investments_value + revenues[t] - expenses[t]\n\n            new_investments_made_this_month = gp.quicksum(X[t, d] for d in investment_durations if (t, d) in X)\n            cash_carried_over = C[t]\n            model.addConstr(funds_in == new_investments_made_this_month + cash_carried_over, name=f\"CashBalance_Month{t}\")\n            if t == 1:\n                model.addConstr(expenses[t] <= initial_funds + revenues[t], name=f\"Expenses_Month{t}\")\n            else:\n                model.addConstr(expenses[t] <= C[t - 1] + revenues[t], name=f\"Expenses_Month{t}\")\n\n        # --- 6. Solve Model ---\n        model.optimize()\n\n        # --- 7. Return Results ---\n        if model.Status == GRB.OPTIMAL:\n            return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n        else:\n            return {\"status\": f\"{model.Status}\"}\n\n    except gp.GurobiError as e:\n        return {\"status\": f\"Gurobi error: {e}\"}\n    except Exception as e:\n        return {\"status\": f\"An unexpected error occurred: {e}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_fund_allocation()\n    print(result)\n",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Cash Management",
        "modeling_type": "LP",
        "industry_sector": "Finance",
        "reason": "The problem involves allocating available funds over several months to maximize cash on hand, which is a classic cash management problem. The model uses continuous variables and linear constraints and objective function, making it a Linear Program. The context of managing company funds and investments falls under the finance sector."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D031",
    "description": "A manufacturing company operates three production facilities (1, 2, and 3) that produce two types of components (X and Y). Each facility generates waste during production, which can be treated to reduce environmental impact. Treating the waste incurs a cost and reduces the amount of pollutants emitted. It costs $12 to treat a ton of waste from facility 1, and each ton treated reduces the amount of pollutant X by 0.15 ton and the amount of pollutant Y by 0.35 ton. It costs $8 to treat a ton of waste from facility 2, and each ton treated reduces the amount of pollutant X by 0.25 ton and the amount of pollutant Y by 0.20 ton. It costs $18 to treat a ton of waste from facility 3, and each ton treated reduces the amount of pollutant X by 0.30 ton and the amount of pollutant Y by 0.40 ton. The company aims to reduce the amount of pollutant X by at least 25 tons and the amount of pollutant Y by at least 35 tons. How to minimize the total cost of treating waste while meeting the pollution reduction targets?",
    "ground_truth": 1269.5652173913,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\ndef solve_waste_treatment_optimization(\n    TreatmentCost=[12, 8, 18],\n    PollutantReduction=[\n        [0.15, 0.35],\n        [0.25, 0.20],\n        [0.30, 0.40]\n    ],\n    PollutionTarget=[25, 35]\n):\n    # Create a new model\n    model = gp.Model(\"Waste Treatment Optimization\")\n\n    # Sets\n    Facilities = range(len(TreatmentCost))\n    Pollutants = range(len(PollutionTarget))\n\n    # Decision Variables\n    TreatmentAmount = model.addVars(Facilities, vtype=GRB.CONTINUOUS, name=\"TreatmentAmount\")\n\n    # Objective: Minimize total treatment cost\n    obj = gp.quicksum(TreatmentCost[f] * TreatmentAmount[f] for f in Facilities)\n    model.setObjective(obj, GRB.MINIMIZE)\n\n    # Constraint 1: Pollution reduction constraint\n    for p in Pollutants:\n        model.addConstr(\n            gp.quicksum(PollutantReduction[f][p] * TreatmentAmount[f] for f in Facilities) >= PollutionTarget[p],\n            f\"PollutionReduction_{p+1}\"\n        )\n\n    # Optimize the model\n    model.optimize()\n\n    # Return Results\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_waste_treatment_optimization()\n    print(result)",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Manufacturing",
        "reason": "The problem involves allocating resources (waste treatment capacity at different facilities) to achieve specific targets (pollution reduction) at minimum cost, which is a classic resource allocation problem. The mathematical formulation uses continuous variables and linear constraints and objective, making it a Linear Program. The context of production facilities and waste treatment clearly places it within the manufacturing sector."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D086",
    "description": "You are in charge of a taxi company, managing its fleet during the evening peak hours. The company needs to dispatch its idle taxis from 3 areas to 3 passenger demand hotspots. To improve profitability, in addition to setting a dynamic surcharge for each hotspot to incentivize drivers, the company has also established a fixed base fare of ¥15 for every successful dispatch. The supply of drivers willing to go to a certain hotspot is proportional to the square of the surcharge, with a coefficient of 0.5. The company's objective is to set the surcharges and plan the vehicle dispatch to maximize total profit. Total profit is calculated as (total base fare revenue + total surcharge revenue - total deadheading costs). Through operational optimization, the company has reduced its deadheading costs by 20%. The number of available taxis in each area, the passenger demand at each hotspot, and the adjusted deadheading costs from each area to each hotspot are shown in the table below.\n\nTable 1: Adjusted Taxi Dispatch Data \n\n| Attribute | H1 | H2 | H3 | Available Taxis |\n|:---:|:---:|:---:|:---:|:---:|\n| Demand | 30  | 50  | 40  | - |\n| Deadheading Cost from A1 | 16 | 28 | 24 | 25  |\n| Deadheading Cost from A2 | 20 | 12 | 32 | 40  |\n| Deadheading Cost from A3 | 24 | 20 | 16 | 35  |\n\nHow can the taxi company set its dynamic surcharges and dispatch plan to maximize its total profit while satisfying all supply and demand constraints?",
    "ground_truth": 887.3785809835,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\nimport math\n\ndef solve_profitable_taxi_dispatch(\n    areas=[\"A1\", \"A2\", \"A3\"],\n    hotspots=[\"H1\", \"H2\", \"H3\"],\n    demand={\"H1\": 30, \"H2\": 50, \"H3\": 40},\n    available_taxis={\"A1\": 25, \"A2\": 40, \"A3\": 35},\n    base_fare=15.0,\n    deadheading_costs_data={\n        (\"A1\", \"H1\"): 16, (\"A1\", \"H2\"): 28, (\"A1\", \"H3\"): 24,\n        (\"A2\", \"H1\"): 20, (\"A2\", \"H2\"): 12, (\"A2\", \"H3\"): 32,\n        (\"A3\", \"H1\"): 24, (\"A3\", \"H2\"): 20, (\"A3\", \"H3\"): 16,\n    }\n):\n    \"\"\"\n    Solves the adjusted (profitable) taxi dispatch optimization problem using Gurobi.\n    This model includes a base fare and reduced deadheading costs.\n    \"\"\"\n    # Create a new model\n    model = gp.Model(\"ProfitableTaxiDispatch\")\n\n    deadheading_costs = gp.tupledict(deadheading_costs_data)\n\n    # --- Decision Variables ---\n    # dispatch_plan[i, j]: Number of taxis dispatched from area i to hotspot j\n    dispatch_plan = model.addVars(areas, hotspots, vtype=GRB.INTEGER, name=\"DispatchPlan\", lb=0)\n\n    # supply[j]: Total number of taxis arriving at hotspot j\n    supply = model.addVars(hotspots, name=\"Supply\", lb=0)\n    \n    # revenue_calc_surcharge[j]: Auxiliary variable for the non-linear surcharge revenue term, representing supply[j]^1.5\n    revenue_calc_surcharge = model.addVars(hotspots, name=\"SurchargeRevenueCalc\", lb=0)\n\n    # --- Objective Function: Maximize Total Profit ---\n    total_base_fare_revenue = base_fare * gp.quicksum(supply[j] for j in hotspots)\n    \n    total_surcharge_revenue = math.sqrt(2) * gp.quicksum(revenue_calc_surcharge[j] for j in hotspots)\n\n    total_revenue = total_base_fare_revenue + total_surcharge_revenue\n\n    total_deadheading_cost = dispatch_plan.prod(deadheading_costs)\n\n    model.setObjective(total_revenue - total_deadheading_cost, GRB.MAXIMIZE)\n\n    # --- Constraints ---\n    # 1. Supply definition constraint\n    for j in hotspots:\n        model.addConstr(supply[j] == gp.quicksum(dispatch_plan[i, j] for i in areas),\n                        name=f\"SupplyDef_{j}\")\n\n    # 2. Surcharge revenue calculation (non-linear power constraint)\n    for j in hotspots:\n        model.addGenConstrPow(supply[j], revenue_calc_surcharge[j], 1.5, name=f\"RevenuePow_{j}\")\n\n    # 3. Hotspot demand constraint\n    for j in hotspots:\n        model.addConstr(supply[j] <= demand[j], name=f\"Demand_{j}\")\n\n    # 4. Area availability constraint\n    for i in areas:\n        model.addConstr(dispatch_plan.sum(i, '*') <= available_taxis[i], name=f\"Availability_{i}\")\n    \n    # Optimize the model\n    model.optimize()\n\n    # --- Return Results ---\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.objVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\n# Run the solver function\nif __name__ == '__main__':\n    result = solve_profitable_taxi_dispatch()\n    print(result)",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MINLP",
        "industry_sector": "Transportation",
        "reason": "The problem involves allocating a limited supply of taxis (resources) from different areas to meet passenger demand at various hotspots. The objective function includes a non-linear term (surcharge revenue proportional to the square of supply, which is modeled as supply^1.5 in the solver due to the sqrt(2) coefficient) and integer decision variables for dispatch, classifying it as a Mixed-Integer Non-Linear Program. The application is clearly within the taxi industry, which falls under transportation."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D001",
    "description": "An airport has two available gates (G1, G2) and needs to assign three flights (F1: 10:00-11:00, F2: 10:30-11:30, F3: 11:15-12:30, F4: 10:45-11:45) to these gates. Flights assigned to the same gate must have non-overlapping time intervals, and the goal is to minimize flight delays, where each 1-minute delay beyond the scheduled departure time incurs a cost of 1 unit. How should the flights be assigned to the gates to achieve this objective?",
    "ground_truth": 30.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_flight_gate_assignment(\n    gates=[1, 2],\n    flights=[1, 2, 3, 4],\n    arrange_start_time={1: 600, 2: 630, 4: 645, 3: 675},\n    duration={1: 60, 2: 60, 3: 75, 4: 60},\n    cost_per_delay=1,\n    big_m=1500,\n):\n    \"\"\"\n    Models and solves the flight gate assignment problem to minimize total delay.\n    \"\"\"\n    # --- 1. Model Creation ---\n    model = gp.Model(\"FlightGateAssignment\")\n\n    # --- 2. Decision Variables ---\n    # x[f,g] = 1 if flight f is assigned to gate g, else 0\n    x = model.addVars([(f, g) for f in flights for g in gates], vtype=GRB.BINARY, name=\"x\")\n\n    # s[f] = actual start time of flight f\n    s = model.addVars(flights, vtype=GRB.INTEGER, name=\"s\")\n\n    # --- 3. Objective Function ---\n    # Minimize total delay cost\n    obj = gp.quicksum(cost_per_delay * (s[f] - arrange_start_time[f])\n                      for f in flights)\n    model.setObjective(obj, GRB.MINIMIZE)\n\n    # --- 4. Constraints ---\n    # Constraint 1: Actual start time should be greater than or equal to the scheduled start time\n    for f in flights:\n        model.addConstr(s[f] >= arrange_start_time[f], f\"start_time_constraint_{f}\")\n\n    # Constraint 2: Every flight should be assigned to exactly one gate\n    for f in flights:\n        model.addConstr(gp.quicksum(x[f, g] for g in gates) == 1, f\"one_gate_per_flight_{f}\")\n\n    # Constraint 3: The actual start time should be greater than or equal to the end time\n    # of the previous flight at the same gate (linearized using Big-M).\n    # This formulation imposes a fixed sequence f1 -> f2 if f1 < f2.\n    for g in gates:\n        for f1 in flights:\n            for f2 in flights:\n                if f1 < f2:  # for flights where f1 comes before f2\n                    # If both flights are assigned to the same gate g,\n                    # then f2 must start after f1 ends\n                    model.addConstr(\n                        s[f2] >= s[f1] + duration[f1] - big_m * (2 - x[f1, g] - x[f2, g]),\n                        f\"sequence_constraint_{f1}_{f2}_{g}\",\n                    )\n\n    # --- 5. Solve the Model ---\n    # model.setParam(\"OutputFlag\", 0) # Suppress Gurobi output\n    model.optimize()\n\n    # --- 6. Return Results ---\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\n# Run the solver function\nif __name__ == \"__main__\":\n    result = solve_flight_gate_assignment()\n    print(result)",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Scheduling",
        "modeling_type": "MILP",
        "industry_sector": "Transportation",
        "reason": "The problem involves assigning flights to gates over time, which is a classic scheduling problem. The solver uses binary and integer variables with linear constraints and an objective function, fitting the Mixed-Integer Linear Programming (MILP) paradigm. The application context of assigning flights to airport gates clearly falls under the transportation sector."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D046",
    "description": "Warehouse 24 operates around the clock to fulfill online orders. Workers are scheduled in two consecutive 6-hour shifts and are paid $12 per hour. The possible shifts are as follows: midnight–6 A.M., 6 A.M.–noon, noon–6 P.M., and 6 P.M.–midnight. During each shift, the following numbers of orders arrive: midnight–6 A.M., 150; 6 A.M.–noon, 250; noon–6 P.M., 400; 6 P.M.–midnight, 300. Each worker can process up to 60 orders per shift. To account for customer dissatisfaction due to delayed orders, any order that remains unprocessed at the end of a shift incurs a penalty of $1. The warehouse ensures that all orders received by midnight are processed by the start of the next day, so the midnight–6 A.M. shift begins with no pending orders. How can Warehouse 24 minimize the total cost of labor and customer dissatisfaction penalties while meeting its order processing requirements?\n\n| Shift              | Orders Received |  \n|--------------------|-----------------|  \n| Midnight–6 A.M.    | 150             |  \n| 6 A.M.–Noon        | 250             |  \n| Noon–6 P.M.        | 400             |  \n| 6 P.M.–Midnight    | 300             |",
    "ground_truth": 1378.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_warehouse_scheduling(\n    orders_received={'midnight_6am': 150, '6am_noon': 250, 'noon_6pm': 400, '6pm_midnight': 300},\n    hourly_wage=12,\n    shift_hours=6,\n    orders_per_worker=60,\n    penalty_per_unprocessed_order=1\n):\n    \"\"\"\n    Models and solves the warehouse scheduling problem.\n    \"\"\"\n    model = gp.Model(\"WarehouseScheduling\")\n    model.setParam('OutputFlag', 0)\n\n    # --- Parameters ---\n    shifts = ['midnight_6am', '6am_noon', 'noon_6pm', '6pm_midnight']\n    shift_wage = hourly_wage * shift_hours\n\n    # --- Decision Variables ---\n    workers = model.addVars(shifts, name=\"Workers\", vtype=GRB.INTEGER, lb=0)\n    orders_processed = model.addVars(shifts, name=\"OrdersProcessed\", vtype=GRB.CONTINUOUS, lb=0)\n    unprocessed = model.addVars(shifts, name=\"UnprocessedOrders\", vtype=GRB.CONTINUOUS, lb=0)\n\n    # --- Objective Function ---\n    total_cost = gp.LinExpr()\n    for shift in shifts:\n        total_cost += workers[shift] * shift_wage\n        total_cost += unprocessed[shift] * penalty_per_unprocessed_order\n    model.setObjective(total_cost, GRB.MINIMIZE)\n\n    # --- Constraints ---\n    for shift in shifts:\n        model.addConstr(orders_processed[shift] <= workers[shift] * orders_per_worker,\n                        name=f\"ProcessingCapacity_{shift}\")\n\n    shift_order = ['midnight_6am', '6am_noon', 'noon_6pm', '6pm_midnight']\n    for i, shift in enumerate(shift_order):\n        if shift == 'midnight_6am':\n            model.addConstr(orders_processed[shift] + unprocessed[shift] == orders_received[shift],\n                           name=f\"OrderBalance_{shift}\")\n        else:\n            prev_shift = shift_order[i-1]\n            model.addConstr(orders_processed[shift] + unprocessed[shift] ==\n                           orders_received[shift] + unprocessed[prev_shift],\n                           name=f\"OrderBalance_{shift}\")\n\n    model.addConstr(unprocessed['6pm_midnight'] == 0, name=\"AllOrdersProcessedByMidnight\")\n\n    # --- Solve ---\n    model.optimize()\n\n    # --- Return Results ---\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == '__main__':\n    result = solve_warehouse_scheduling()\n    print(result)",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Scheduling",
        "modeling_type": "MILP",
        "industry_sector": "Logistics",
        "reason": "The problem involves determining the number of workers to assign to different shifts to meet order processing demands, which is a classic scheduling problem. The model uses integer variables for workers and continuous variables for orders, with linear constraints and objective, making it a Mixed-Integer Linear Program. The application is focused on warehouse operations and order fulfillment, falling under logistics."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D055",
    "description": "A bus company needs to schedule departures for a specific route during the morning peak hours (7:00 AM to 9:00 AM) to minimize the total passenger waiting time. Each bus has a minimum departure interval of 5 minutes and a maximum departure interval of 10 minutes, with a round-trip time of 30 minutes including stops. The company has a maximum of 5 buses available for scheduling. Passengers arrive at the station uniformly at a constant rate during the morning rush hour. The objective is to determine the optimal departure schedule by formulating an integer programming model that minimizes the total passenger waiting time while satisfying the given constraints.",
    "ground_truth": 296730.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_bus_scheduling(\n    StartTime=0,\n    EndTime=120,\n    MinimumDepartureInterval=5,\n    MaximumDepartureInterval=10,\n    RoundtripTime=30,\n    MaximumBuses=5\n):\n    \"\"\"\n    Solves the bus scheduling problem to minimize passenger waiting time.\n    \"\"\"\n    # --- Sets ---\n    TimeSlots = range(StartTime, EndTime + 1)\n\n    # --- Model Initialization ---\n    model = gp.Model(\"BusScheduling\")\n\n    # --- Decision Variables ---\n    Departures = model.addVars(TimeSlots, vtype=GRB.BINARY, name=\"Departures\")\n\n    # --- Objective Function ---\n    obj = gp.quicksum(\n        (s - t)**2 * Departures[t] * Departures[s]\n        for t in TimeSlots for s in TimeSlots if s > t\n    )\n    model.setObjective(obj, GRB.MINIMIZE)\n\n    # --- Constraints ---\n    # Min departure interval\n    for t in TimeSlots:\n        if t + MinimumDepartureInterval - 1 <= EndTime:\n            model.addConstr(\n                gp.quicksum(Departures[i] for i in range(t, t + MinimumDepartureInterval)) <= 1\n            )\n\n    # Max departure interval\n    for t in TimeSlots:\n        if t + MaximumDepartureInterval - 1 <= EndTime:\n            model.addConstr(\n                Departures[t] <= gp.quicksum(\n                    Departures[s] for s in range(t + MinimumDepartureInterval, t + MaximumDepartureInterval)\n                )\n            )\n\n    # Max number of departures\n    max_departures = ((EndTime - StartTime) // RoundtripTime + 1) * MaximumBuses\n    model.addConstr(gp.quicksum(Departures[t] for t in TimeSlots) <= max_departures)\n\n    # Fixed departures at start and end\n    model.addConstr(Departures[StartTime] == 1)\n    model.addConstr(Departures[EndTime] == 1)\n\n    # --- Optimize the model ---\n    model.optimize()\n\n    # --- Results ---\n    if model.status == GRB.OPTIMAL:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_bus_scheduling()\n    print(result)\n",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Scheduling",
        "modeling_type": "QP",
        "industry_sector": "Transportation",
        "reason": "The problem involves determining optimal departure times for buses, which is a classic scheduling problem. The objective function minimizes the sum of squared differences between departure times, which is a quadratic form, and the decision variables are binary, making it a Quadratic Program (QP). The application is clearly within a bus company's operations, hence transportation."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D058",
    "description": "A logistics company needs to pack 6 heavy cylindrical containers into a specialized truck bed. The truck bed has a fixed width of 2.5 meters, and the company wants to find the minimum possible length required to fit all containers. The diameters of the 6 containers (in meters) are: [1.2, 1.1, 1.0, 0.9, 0.8, 0.7].\n\nThe containers must be placed flat on the truck bed according to the following rules:\n1.  Each container must be fully contained within the truck bed's boundaries.\n2.  No two containers can overlap.\n3.  The goal is to find an arrangement that minimizes the total length of the truck bed used.\n\nThe position of each container is determined by the (x, y) coordinates of its center. The x-axis runs along the length of the truck, and the y-axis runs along its fixed width.",
    "ground_truth": 2.373934757,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_nonlinear_container_packing(\n    container_ids=list(range(6)),\n    diameters={0: 1.2, 1: 1.1, 2: 1.0, 3: 0.9, 4: 0.8, 5: 0.7},\n    truck_width=2.5,\n    time_limit=60\n):\n    \"\"\"\n    Solves a non-linear container packing problem for a reduced number of containers.\n    This model is a Non-Convex Quadratically Constrained Program (QCQP).\n    \"\"\"\n    radii = {c: d / 2 for c, d in diameters.items()}\n\n    model = gp.Model(\"NonlinearContainerPacking\")\n\n    x = model.addVars(container_ids, name=\"x_coord\", lb=0.0)\n    y = model.addVars(container_ids, name=\"y_coord\", lb=0.0)\n    L = model.addVar(name=\"TruckLength\", lb=0.0)\n\n    model.setObjective(L, GRB.MINIMIZE)\n\n    for c in container_ids:\n        model.addConstr(y[c] - radii[c] >= 0, name=f\"width_lower_{c}\")\n        model.addConstr(y[c] + radii[c] <= truck_width, name=f\"width_upper_{c}\")\n        model.addConstr(x[c] - radii[c] >= 0, name=f\"length_lower_{c}\")\n        model.addConstr(x[c] + radii[c] <= L, name=f\"length_upper_{c}\")\n\n    for i in container_ids:\n        for j in container_ids:\n            if i < j:\n                model.addQConstr(\n                    (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]) >= (radii[i] + radii[j])**2,\n                    name=f\"no_overlap_{i}_{j}\"\n                )\n\n    model.Params.NonConvex = 2\n    model.Params.TimeLimit = time_limit\n    \n    model.optimize()\n\n    if model.Status == GRB.OPTIMAL or model.Status == GRB.TIME_LIMIT:\n        return {\"status\": \"optimal\", \"obj\": L.X}\n    else:\n        return {\"status\": f\"{model.Status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_nonlinear_container_packing()\n    print(result)\n",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Packing",
        "modeling_type": "QCQP",
        "industry_sector": "Logistics",
        "reason": "The problem involves arranging cylindrical containers within a fixed-width truck bed to minimize the required length, which is a classic packing problem. The solver uses quadratic constraints for non-overlap and a quadratic objective, classifying it as a Quadratically Constrained Quadratic Program (QCQP). The application context of packing items into a truck for transport falls under the logistics sector."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "D079",
    "description": "PharmaLogistics Inc. is planning the distribution network for its new temperature-sensitive drug, 'VitaBoost', for the upcoming 6 months (Month 1 to Month 6). The company has two manufacturing plants (P1 located in City A, P2 located in City B) and is considering opening and operating up to three potential distribution centers (DC1 in Region X, DC2 in Region Y, DC3 in Region Z) to serve four key demand regions (R1, R2, R3, R4). The primary objective is to minimize the total operational costs over the 6-month planning horizon. These costs include: the fixed monthly costs of operating any active DCs, transportation costs for shipping VitaBoost from plants to DCs and from DCs to demand regions, inventory holding costs for products stored at DCs, costs associated with product expiry and disposal, and shortage costs incurred for any unmet demand in the regions.\n\nVitaBoost has a strict shelf life of 2 months. This means that any product manufactured in a given month (say, Month `m`) must be used to satisfy demand by the end of the following month (Month `m+1`). Product not used by this deadline expires and must be disposed of.\n\nAt the beginning of Month 1, DC1 has an initial stock of VitaBoost, provided it is chosen to be operational in Month 1: 10 units that were produced in the immediately preceding month (referred to as 'Month 0' batch, thus being 1-month old at the start of Month 1) and 5 units that were produced two months prior (referred to as 'Month -1' batch, thus being 2-months old at the start of Month 1). This 'Month -1' batch must be used or discarded during Month 1. No other initial inventory exists at other potential DCs or plants.\n\nThe monthly production capacities for the manufacturing plants are as follows (in units, for Months 1 through 6 respectively):\n-   Plant P1: [250, 250, 260, 260, 270, 270]\n-   Plant P2: [200, 200, 210, 210, 220, 220]\n\nThe potential distribution centers have associated costs and capacities:\n-   Fixed monthly operating costs if active: DC1: $10,000; DC2: $12,000; DC3: $9,000.\n-   Storage capacities (max units): DC1: 300; DC2: 350; DC3: 280.\n\nTransportation costs per unit of VitaBoost are:\n-   From Plant P1 to DCs: DC1: $5, DC2: $7, DC3: $6.\n-   From Plant P2 to DCs: DC1: $8, DC2: $4, DC3: $7.\n-   From DC1 to Regions: R1: $3, R2: $4, R3: $5, R4: $6.\n-   From DC2 to Regions: R1: $5, R2: $3, R3: $4, R4: $5.\n-   From DC3 to Regions: R1: $4, R2: $5, R3: $3, R4: $4.\n\nOther relevant costs are:\n-   Monthly inventory holding cost per unit at DCs: DC1: $2.0; DC2: $2.5; DC3: $1.8.\n-   Disposal cost for expired product: $1 per unit at any DC.\n-   Shortage cost for unmet demand: $50 per unit, uniform across all regions and months.\n\nThe forecasted monthly demand for VitaBoost (in units) for each region over the 6-month horizon is:\n-   Region R1: [100, 110, 120, 130, 140, 150]\n-   Region R2: [80, 85, 90, 95, 100, 105]\n-   Region R3: [120, 125, 130, 135, 140, 145]\n-   Region R4: [60, 65, 70, 75, 80, 85]\n\nPharmaLogistics Inc. needs to determine an optimal plan that specifies: which DCs to operate in each month, the quantity of VitaBoost to produce at each plant monthly, and the detailed shipping and inventory quantities across the network. This plan must ensure that demand is met as effectively as possible while respecting the product's shelf life and minimizing total costs.",
    "ground_truth": 81060.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_pharma_distribution_corrected(\n    T=range(1, 7),\n    P=['P1', 'P2'],\n    D=['DC1', 'DC2', 'DC3'],\n    R=['R1', 'R2', 'R3', 'R4'],\n    B=range(-1, 7),\n    L=2,\n    BigM_flow=2400,\n    Demand={\n        ('R1', 1): 100,\n        ('R1', 2): 110,\n        ('R1', 3): 120,\n        ('R1', 4): 130,\n        ('R1', 5): 140,\n        ('R1', 6): 150,\n        ('R2', 1): 80,\n        ('R2', 2): 85,\n        ('R2', 3): 90,\n        ('R2', 4): 95,\n        ('R2', 5): 100,\n        ('R2', 6): 105,\n        ('R3', 1): 120,\n        ('R3', 2): 125,\n        ('R3', 3): 130,\n        ('R3', 4): 135,\n        ('R3', 5): 140,\n        ('R3', 6): 145,\n        ('R4', 1): 60,\n        ('R4', 2): 65,\n        ('R4', 3): 70,\n        ('R4', 4): 75,\n        ('R4', 5): 80,\n        ('R4', 6): 85\n    },\n    ProdCap={\n        ('P1', 1): 250,\n        ('P1', 2): 250,\n        ('P1', 3): 260,\n        ('P1', 4): 260,\n        ('P1', 5): 270,\n        ('P1', 6): 270,\n        ('P2', 1): 200,\n        ('P2', 2): 200,\n        ('P2', 3): 210,\n        ('P2', 4): 210,\n        ('P2', 5): 220,\n        ('P2', 6): 220\n    },\n    FixedDCost={'DC1': 10000, 'DC2': 12000, 'DC3': 9000},\n    DCStoreCap={'DC1': 300, 'DC2': 350, 'DC3': 280},\n    TransCostPD={\n        ('P1', 'DC1'): 5,\n        ('P1', 'DC2'): 7,\n        ('P1', 'DC3'): 6,\n        ('P2', 'DC1'): 8,\n        ('P2', 'DC2'): 4,\n        ('P2', 'DC3'): 7\n    },\n    TransCostDR={\n        ('DC1', 'R1'): 3,\n        ('DC1', 'R2'): 4,\n        ('DC1', 'R3'): 5,\n        ('DC1', 'R4'): 6,\n        ('DC2', 'R1'): 5,\n        ('DC2', 'R2'): 3,\n        ('DC2', 'R3'): 4,\n        ('DC2', 'R4'): 5,\n        ('DC3', 'R1'): 4,\n        ('DC3', 'R2'): 5,\n        ('DC3', 'R3'): 3,\n        ('DC3', 'R4'): 4\n    },\n    InvHoldCost={'DC1': 2.0, 'DC2': 2.5, 'DC3': 1.8},\n    DisposalCost={'DC1': 1, 'DC2': 1, 'DC3': 1},\n    ShortageCost={'R1': 50, 'R2': 50, 'R3': 50, 'R4': 50},\n    InitialInv={('DC1', -1): 5, ('DC1', 0): 10}\n):\n    \"\"\"\n    Solves a corrected and robust version of the PharmaLogistics distribution network problem,\n    accurately handling inventory flow and shelf life.\n    \"\"\"\n    model = gp.Model(\"PharmaLogistics_Corrected\")\n\n    # ========== Decision Variables ==========\n    Y = model.addVars(D, T, vtype=GRB.BINARY, name=\"Y_dc_open\")\n    P_prod = model.addVars(P, T, lb=0, name=\"P_prod\")\n    Q_ship_pd = model.addVars(P, D, T, lb=0, name=\"Q_ship_plant_dc\")\n    S_ship_dr = model.addVars(B, D, R, T, lb=0, name=\"S_ship_dc_region\")\n    I_inv = model.addVars(B, D, T, lb=0, name=\"I_inventory\")\n    U_unmet = model.addVars(R, T, lb=0, name=\"U_unmet_demand\")\n    W_waste = model.addVars(B, D, T, lb=0, name=\"W_waste\")\n\n    # ========== Objective Function ==========\n    total_fixed_cost = gp.quicksum(FixedDCost[d] * Y[d, t] for d in D\n                                   for t in T)\n    total_transport_pd_cost = gp.quicksum(\n        TransCostPD[p, d] * Q_ship_pd[p, d, t] for p in P for d in D\n        for t in T)\n    total_transport_dr_cost = gp.quicksum(\n        TransCostDR[d, r] * S_ship_dr[b, d, r, t] for b in B for d in D\n        for r in R for t in T)\n    total_inventory_cost = gp.quicksum(InvHoldCost[d] * I_inv[b, d, t]\n                                       for b in B for d in D for t in T)\n    total_disposal_cost = gp.quicksum(DisposalCost[d] * W_waste[b, d, t]\n                                      for b in B for d in D for t in T)\n    total_shortage_cost = gp.quicksum(ShortageCost[r] * U_unmet[r, t]\n                                      for r in R for t in T)\n\n    model.setObjective(\n        total_fixed_cost + total_transport_pd_cost +\n        total_transport_dr_cost + total_inventory_cost +\n        total_disposal_cost + total_shortage_cost, GRB.MINIMIZE)\n\n    # ========== Constraints ==========\n    # DC Activation and Capacity\n    model.addConstrs((gp.quicksum(I_inv[b, d, t]\n                                  for b in B) <= DCStoreCap[d] * Y[d, t]\n                      for d in D for t in T),\n                     name=\"DC_Capacity\")\n    model.addConstrs((gp.quicksum(Q_ship_pd[p, d, t]\n                                  for p in P) <= BigM_flow * Y[d, t]\n                      for d in D for t in T),\n                     name=\"DC_Open_Inbound\")\n    model.addConstrs((gp.quicksum(S_ship_dr[b, d, r, t] for b in B\n                                  for r in R) <= BigM_flow * Y[d, t]\n                      for d in D for t in T),\n                     name=\"DC_Open_Outbound\")\n\n    # Production and Plant Flow\n    model.addConstrs((P_prod[p, t] <= ProdCap[p, t] for p in P for t in T),\n                     name=\"Production_Capacity\")\n    model.addConstrs((P_prod[p, t] == gp.quicksum(Q_ship_pd[p, d, t]\n                                                  for d in D) for p in P\n                      for t in T),\n                     name=\"Plant_Flow\")\n\n    # Inventory Balance and Shelf Life\n    for d in D:\n        for t in T:\n            for b in B:\n                # Previous inventory\n                if t == 1:\n                    prev_inv = InitialInv.get((d, b), 0)\n                else:\n                    prev_inv = I_inv[b, d, t - 1]\n\n                # Inflow from production\n                inflow = gp.quicksum(Q_ship_pd[p, d, t]\n                                     for p in P) if b == t else 0\n\n                # Outflow to customers\n                outflow = gp.quicksum(S_ship_dr[b, d, r, t] for r in R)\n\n                # Inventory Balance Equation\n                model.addConstr(I_inv[b, d, t] == prev_inv + inflow -\n                                outflow - W_waste[b, d, t],\n                                name=f\"Inv_Balance_{b}_{d}_{t}\")\n\n                # --- CORRECTED: Shelf-life constraints ---\n                # Product from batch 'b' expires at the end of period 'b + L - 1'\n                expiration_period = b + L - 1\n\n                # If the current period 't' is after the expiration period, inventory must be zero\n                if t > expiration_period:\n                    model.addConstr(I_inv[b, d, t] == 0,\n                                    f\"Expired_Inv_Zero_{b}_{d}_{t}\")\n\n                # Waste can only occur AT the expiration period.\n                if t == expiration_period:\n                    # Waste is whatever is left from the previous period that isn't shipped out\n                    model.addConstr(W_waste[b, d, t] == prev_inv - outflow,\n                                    f\"Waste_Calc_{b}_{d}_{t}\")\n                else:\n                    model.addConstr(W_waste[b, d, t] == 0,\n                                    f\"No_Waste_{b}_{d}_{t}\")\n\n    # Demand Satisfaction\n    for r in R:\n        for t in T:\n            # Sum of shipments from all DCs and all VALID (non-expired) batches\n            valid_shipments = gp.quicksum(S_ship_dr[b, d, r, t] for d in D\n                                          for b in B if t < b + L)\n            model.addConstr(valid_shipments + U_unmet[r, t] == Demand[r,\n                                                                      t],\n                            name=f\"Demand_{r}_{t}\")\n\n    # ========== Solve ==========\n    model.Params.TimeLimit = 120  # 2-minute time limit for this complex model\n    model.optimize()\n\n    # ========== Return Results ==========\n    if model.Status == GRB.OPTIMAL or model.Status == GRB.TIME_LIMIT:\n        return {\"status\": \"optimal\", \"obj\": model.ObjVal}\n    else:\n        return {\"status\": f\"{model.Status}\"}\n\n\nif __name__ == \"__main__\":\n    result = solve_pharma_distribution_corrected()\n    print(result)\n",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Supply Chain Design & Planning",
        "modeling_type": "MILP",
        "industry_sector": "Pharmaceuticals",
        "reason": "The problem involves designing and planning a distribution network for a pharmaceutical company, including facility location (DC activation), production, inventory, and transportation decisions over multiple periods with shelf-life constraints. The solver program uses binary variables for DC activation and continuous variables for flows and inventory, with linear constraints and objective, making it a Mixed-Integer Linear Program."
      }
    ],
    "cluster": null
  }
]