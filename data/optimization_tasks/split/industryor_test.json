[
  {
    "task_id": "B088",
    "description": "A company produces product A and product B. Each unit of product A sold generates a profit of £30, while each unit of product B sold generates a profit of £10. The company can allocate a maximum of 40 hours per week for production. Producing one unit of product A requires 6 hours, while producing one unit of product B requires 3 hours. Market demand requires that the quantity of product B produced must be at least three times the quantity of product A. The storage space occupied by product A is four times that of product B, and a maximum of four units of product A can be stored per week.\n\nFormulate a model for this problem.",
    "ground_truth": 150.0,
    "formulation": null,
    "correct_program": "def optimize_production(profit_A=30,\n                        profit_B=10,\n                        hours_per_A=6,\n                        hours_per_B=3,\n                        max_hours=40,\n                        min_B_ratio=3,\n                        max_A_storage=4):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"Production_Optimization\")\n\n    # Decision variables: number of units of A and B\n    x_A = model.addVar(vtype=GRB.INTEGER, name=\"x_A\", lb=0)\n    x_B = model.addVar(vtype=GRB.INTEGER, name=\"x_B\", lb=0)\n\n    # Set objective: maximize profit\n    model.setObjective(profit_A * x_A + profit_B * x_B, GRB.MAXIMIZE)\n\n    # Add constraints\n    # Production time constraint\n    model.addConstr(hours_per_A * x_A + hours_per_B * x_B <= max_hours,\n                    \"TimeLimit\")\n    # Market demand constraint for B\n    model.addConstr(x_B >= min_B_ratio * x_A, \"DemandB\")\n    # Storage space constraint for A\n    model.addConstr(x_A <= max_A_storage, \"StorageA\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        return model.objVal\n    else:\n        return None\nif __name__ == \"__main__\":  # pragma: no cover\n    result = optimize_production()\n    if result is not None:\n        print(f\"Optimal profit: {result}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Production Planning",
        "modeling_type": "IP",
        "industry_sector": "Manufacturing",
        "reason": "The problem involves determining optimal production quantities for two products to maximize profit under resource, demand, and storage constraints, which is a classic production planning scenario. The decision variables are integers (number of units), and the objective and constraints are linear, making it an Integer Program."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "B042",
    "description": "A production base needs to extract raw materials from warehouses A and B every day for production. The required raw materials are: at least 240 pieces of raw material A, at least 80 kg of raw material B, and at least 120 tons of raw material C. It is known that: Each truck from warehouse A can transport back to the production base 4 pieces of raw material A, 2 kg of raw material B, 6 tons of raw material C, with a freight cost of 200 yuan per truck; each truck from warehouse B can transport back to the production base 7 pieces of raw material A, 2 kg of raw material B, 2 tons of raw material C per day, with a freight cost of 160 yuan per truck. Question: In order to meet production needs, how many trucks should be dispatched daily from warehouse A and warehouse B to minimize the total freight cost?",
    "ground_truth": 6800.0,
    "formulation": null,
    "correct_program": "def optimize_truck_dispatch(\n        cost_A=200,  # freight cost per truck from warehouse A\n        cost_B=160,  # freight cost per truck from warehouse B\n        min_A=240,  # minimum raw material A pieces\n        min_B=80,  # minimum raw material B kg\n        min_C=120  # minimum raw material C tons\n):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"Truck_Dispatch_Optimization\")\n\n    # Decision variables: number of trucks from warehouses A and B\n    x_A = model.addVar(vtype=GRB.INTEGER, lb=0, name=\"x_A\")\n    x_B = model.addVar(vtype=GRB.INTEGER, lb=0, name=\"x_B\")\n\n    # Set objective: minimize total freight cost\n    model.setObjective(cost_A * x_A + cost_B * x_B, GRB.MINIMIZE)\n\n    # Add constraints for raw materials\n    # Raw material A\n    model.addConstr(4 * x_A + 7 * x_B >= min_A, \"Raw_A\")\n    # Raw material B\n    model.addConstr(2 * x_A + 2 * x_B >= min_B, \"Raw_B\")\n    # Raw material C\n    model.addConstr(6 * x_A + 2 * x_B >= min_C, \"Raw_C\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the optimal total freight cost\n        return model.objVal\n    else:\n        # No feasible solution found\n        return None\nif __name__ == \"__main__\":\n    result = optimize_truck_dispatch()\n    if result is not None:\n        print(f\"Optimal total freight cost: {result}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "IP",
        "industry_sector": "Manufacturing",
        "reason": "The problem involves allocating trucks from different warehouses to meet minimum raw material requirements at a production base while minimizing transportation costs. The decision variables are integers (number of trucks), and the objective and constraints are linear, classifying it as an Integer Program within the manufacturing sector."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "B075",
    "description": "A timber storage and transport company has a large warehouse for storing and transporting timber for sale. Due to seasonal price fluctuations, the company purchases timber at the beginning of each quarter, with part of it being sold within the quarter and part being stored for future sales. It is known that the maximum storage capacity of the company’s warehouse is 200,000 m³, and the storage cost is $(a+b u)$ yuan/m³, where $a=70$, $b=100$, and $u$ is the storage time (in quarters). The purchase and sale prices for each quarter and the estimated maximum sales volumes are shown in Table 1-18.\n\nTable 1-18\n| Quarter | Purchase Price (10,000 yuan/10,000 m²) | Sale Price (10,000 yuan/10,000 m²) | Estimated Maximum Sales Volume (10,000 m³) |\n|---------|----------------------------------------|------------------------------------|---------------------------------------------|\n| Winter  | 410                                    | 425                                | 100                                         |\n| Spring  | 430                                    | 440                                | 140                                         |\n| Summer  | 460                                    | 465                                | 200                                         |\n| Autumn  | 450                                    | 455                                | 160                                         |\n\nSince timber is not suitable for long-term storage, all inventory should be sold by the end of autumn. Try to establish a linear programming model for this problem to maximize the company's annual profit.",
    "ground_truth": 4700.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_timber_storage():\n    \"\"\"\n    Solves the timber storage and transport problem to maximize annual profit.\n    \"\"\"\n    try:\n        # --- Data ---\n        # Quarters: Winter (0), Spring (1), Summer (2), Autumn (3)\n        quarters = list(range(4))\n        quarter_names = ['Winter', 'Spring', 'Summer', 'Autumn']\n\n        # Prices and Sales Limits (Units: 10k yuan for price, 10k m^3 for volume)\n        purchase_prices = [410, 430, 460, 450]  # P_t\n        sale_prices = [425, 440, 465, 455]  # S_t\n        max_sales_volume = [100, 140, 200, 160]  # MaxSales_t\n\n        # Warehouse Capacity (Units: 10k m^3)\n        warehouse_capacity = 20\n\n        # Storage Cost (Units: 10k yuan per 10k m^3 per quarter)\n        # Calculated from (a+bu) yuan/m^3 with a=70, b=100, assuming u=1 for cost per quarter\n        storage_cost_per_unit_volume = 170  # H\n\n        # Initial Inventory (Units: 10k m^3)\n        initial_inventory = 0.0\n\n        # --- Create Gurobi Model ---\n        model = gp.Model(\"TimberStorageOptimization\")\n\n        # --- Decision Variables ---\n        # Buy[t]: Volume purchased at the beginning of quarter t\n        buy_vars = model.addVars(quarters,\n                                 name=\"Buy\",\n                                 lb=0.0,\n                                 vtype=GRB.CONTINUOUS)\n\n        # Sell[t]: Volume sold during quarter t\n        sell_vars = model.addVars(quarters,\n                                  name=\"Sell\",\n                                  lb=0.0,\n                                  vtype=GRB.CONTINUOUS)\n\n        # Inv[t]: Volume stored at the end of quarter t\n        inventory_vars = model.addVars(quarters,\n                                       name=\"Inventory\",\n                                       lb=0.0,\n                                       vtype=GRB.CONTINUOUS)\n\n        # --- Objective Function: Maximize Total Profit ---\n        # Profit = Sales Revenue - Purchase Cost - Holding Cost\n        total_sales_revenue = gp.quicksum(sale_prices[t] * sell_vars[t]\n                                          for t in quarters)\n        total_purchase_cost = gp.quicksum(purchase_prices[t] * buy_vars[t]\n                                          for t in quarters)\n        total_holding_cost = gp.quicksum(\n            storage_cost_per_unit_volume * inventory_vars[t] for t in quarters)\n\n        model.setObjective(\n            total_sales_revenue - total_purchase_cost - total_holding_cost,\n            GRB.MAXIMIZE)\n\n        # --- Constraints ---\n        for t in quarters:\n            # Inventory at the start of the current quarter t\n            prev_inventory = initial_inventory if t == 0 else inventory_vars[t\n                                                                             -\n                                                                             1]\n\n            # 1. Inventory Balance Constraint\n            # Inv[t] = Inv[t-1] + Buy[t] - Sell[t]\n            model.addConstr(inventory_vars[t] == prev_inventory + buy_vars[t] -\n                            sell_vars[t],\n                            name=f\"InventoryBalance_{quarter_names[t]}\")\n\n            # 2. Warehouse Capacity Constraint\n            # Inv[t] <= warehouse_capacity\n            model.addConstr(inventory_vars[t] <= warehouse_capacity,\n                            name=f\"WarehouseCapacity_{quarter_names[t]}\")\n\n            # 3. Sales Limit Constraint\n            # Sell[t] <= MaxSales[t]\n            model.addConstr(sell_vars[t] <= max_sales_volume[t],\n                            name=f\"MaxSales_{quarter_names[t]}\")\n\n            # 4. Availability for Sale Constraint\n            # Sell[t] <= Inv[t-1] + Buy[t]\n            model.addConstr(sell_vars[t] <= prev_inventory + buy_vars[t],\n                            name=f\"SalesAvailability_{quarter_names[t]}\")\n\n        # 5. End Condition: All inventory must be sold by the end of Autumn (t=3)\n        model.addConstr(inventory_vars[quarters[-1]] == 0,\n                        name=\"EndInventoryZero\")\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal storage and transport plan found.\")\n            print(f\"Maximum Annual Profit: {model.ObjVal * 10000:.2f} Yuan\"\n                  )  # Convert back to Yuan\n\n            print(\"\\nQuarterly Plan Details (Volumes in 10,000 m³):\")\n            header = f\"{'Quarter':<8} | {'Inv Start':<10} | {'Buy Qty':<10} | {'Sell Qty':<10} | {'Inv End':<10} | {'Holding Cost':<15}\"\n            print(header)\n            print(\"-\" * len(header))\n\n            current_inv = initial_inventory\n            for t in quarters:\n                holding_cost_t = storage_cost_per_unit_volume * inventory_vars[\n                    t].X\n                print(\n                    f\"{quarter_names[t]:<8} | {current_inv:<10.2f} | {buy_vars[t].X:<10.2f} | \"\n                    f\"{sell_vars[t].X:<10.2f} | {inventory_vars[t].X:<10.2f} | \"\n                    f\"{holding_cost_t * 10000:<15.2f}\"\n                )  # Convert cost back to Yuan\n                current_inv = inventory_vars[t].X\n            print(\"-\" * len(header))\n\n            print(\n                f\"\\nInitial Inventory (Start of Winter): {initial_inventory:.2f} (10k m³)\"\n            )\n            print(\n                f\"Final Inventory (End of Autumn): {inventory_vars[quarters[-1]].X:.2f} (10k m³)\"\n            )\n\n            # Cost breakdown\n            sales_rev_val = sum(sale_prices[t] * sell_vars[t].X\n                                for t in quarters) * 10000\n            purchase_cost_val = sum(purchase_prices[t] * buy_vars[t].X\n                                    for t in quarters) * 10000\n            holding_cost_val = sum(\n                storage_cost_per_unit_volume * inventory_vars[t].X\n                for t in quarters) * 10000\n            print(\"\\nFinancial Summary (Yuan):\")\n            print(f\"  Total Sales Revenue: {sales_rev_val:.2f}\")\n            print(f\"  Total Purchase Cost: {purchase_cost_val:.2f}\")\n            print(f\"  Total Holding Cost: {holding_cost_val:.2f}\")\n            print(\n                f\"  Calculated Profit: {(sales_rev_val - purchase_cost_val - holding_cost_val):.2f}\"\n            )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\n                \"Model is infeasible. Check constraints and data for contradictions.\"\n            )\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            # model.computeIIS()\n            # model.write(\"timber_storage_iis.ilp\")\n            # print(\"IIS written to timber_storage_iis.ilp.\")\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_timber_storage()",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Inventory Management",
        "modeling_type": "LP",
        "industry_sector": "Manufacturing",
        "reason": "The problem involves managing timber inventory over multiple quarters, making decisions on purchase and sales volumes to maximize profit, which is a classic inventory management problem. The formulation uses continuous variables and linear constraints and objective, classifying it as a Linear Program. The context of storing and transporting timber for sale falls under the broader manufacturing or raw material processing sector."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "B022",
    "description": "Hongdou Clothing Factory uses three special equipment to produce shirts, short-sleeved shirts, and casual clothes respectively. It is known that the labor, material usage, selling price, and variable cost of each of the above products are as shown in Table 5-10.\n\nTable 5-10\n\n| Product Name | Labor per unit | Material per unit | Selling Price | Variable Cost |\n|--------------|----------------|------------------|---------------|---------------|\n| Shirt        | 3              | 4                | 120           | 60            |\n| Short-sleeve | 2              | 3                | 80            | 40            |\n| Casual Cloth | 6              | 6                | 180           | 80            |\n\nIt is known that the available labor per week is 1500 units, the available material is 1600 units, and the weekly fixed costs for the three special equipment for producing shirts, short-sleeved shirts, and casual clothes are 2000, 1500, and 1000 respectively. Design a weekly production plan for the factory to maximize its profit.",
    "ground_truth": 21500.0,
    "formulation": null,
    "correct_program": "def hongdou_factory_optimization(labor_per_unit=[3, 2, 6],\n                                 material_per_unit=[4, 3, 6],\n                                 selling_price=[120, 80, 180],\n                                 variable_cost=[60, 40, 80],\n                                 labor_available=1500,\n                                 material_available=1600,\n                                 fixed_costs=[2000, 1500, 1000]):\n    from gurobipy import Model, GRB\n\n    n = 3  # number of products\n\n    # Net profit per unit for each product\n    profit_per_unit = [selling_price[i] - variable_cost[i] for i in range(n)]\n    total_fixed_cost = sum(fixed_costs)\n\n    try:\n        m = Model()\n        m.setParam('OutputFlag', 0)\n\n        # Decision variables: x[i] = number of units produced for product i\n        x = [\n            m.addVar(lb=0, vtype=GRB.CONTINUOUS, name=f\"x_{i+1}\")\n            for i in range(n)\n        ]\n\n        # Objective: maximize total profit\n        m.setObjective(\n            sum(profit_per_unit[i] * x[i]\n                for i in range(n)) - total_fixed_cost, GRB.MAXIMIZE)\n\n        # Labor constraint\n        m.addConstr(\n            sum(labor_per_unit[i] * x[i] for i in range(n)) <= labor_available,\n            \"Labor\")\n\n        # Material constraint\n        m.addConstr(\n            sum(material_per_unit[i] * x[i] for i in range(n))\n            <= material_available, \"Material\")\n\n        # Solve\n        m.optimize()\n\n        if m.status == GRB.OPTIMAL:\n            return m.objVal\n        else:\n            return None\n    except Exception:\n        return None\n\nprint(hongdou_factory_optimization())",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Production Planning",
        "modeling_type": "LP",
        "industry_sector": "Manufacturing",
        "reason": "The problem aims to determine the optimal quantity of each product to manufacture given resource constraints (labor, material) to maximize profit, which is a classic production planning problem. The model uses continuous variables and linear objective and constraints, classifying it as a Linear Program. The context of producing clothing in a factory clearly places it in the manufacturing sector."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "B043",
    "description": "Given that there are $m=2$ production points for a certain type of material, where the output at the $i$-th point $(i=1,2)$ is $a_i$, $a_1 = 100$, and $a_2 = 150$. This material is to be shipped to $n=2$ demand points, where the demand at the $j$-th point $(j=1, 2)$ is $b_j$, $b_1 = 80$, and $b_2 = 120$. It is known that $\\sum_i a_i \\geqslant \\sum_j b_j$. It is also known that when shipping from production points to demand points, it must pass through one of the $p=2$ intermediate marshaling stations. If the $k$-th $(k=1, 2)$ intermediate marshaling station is used, a fixed cost $f_k$ is incurred regardless of the transshipment volume, where $f_1 = 10$ and $f_2 = 15$. The $k$-th intermediate marshaling station has a maximum transshipment capacity limitation $q_k$, where $q_1 = 100$ and $q_2 = 100$. Let $c_{i k}$ and $c'_{k j}$ denote the unit transportation cost from $i$ to $k$ and from $k$ to $j$, respectively, where $c_{11}=2$, $c_{12}=3$, $c_{21}=4$, $c_{22}=1$, $c'_{11}=3$, $c'_{12}=2$, $c'_{21}=1$, and $c'_{22}=4$. Try to determine a transportation plan for this material that minimizes the total cost.",
    "ground_truth": 685.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_fixed_charge_transshipment():\n    \"\"\"\n    Solves a fixed-charge transshipment problem with intermediate marshaling stations.\n    The goal is to minimize total transportation and fixed operational costs.\n    \"\"\"\n    try:\n        # --- Data ---\n        # Production points (sources)\n        production_points = [1, 2]\n        supply = {1: 100, 2: 150}  # a_i\n\n        # Demand points (sinks)\n        demand_points = [1, 2]\n        demand = {1: 80, 2: 120}  # b_j\n\n        # Marshaling stations\n        marshaling_stations = [1, 2]\n        fixed_costs = {1: 10, 2: 15}  # f_k\n        station_capacities = {1: 100, 2: 100}  # q_k\n\n        # Unit transportation costs from production i to station k (c_ik)\n        cost_ik = {(1, 1): 2, (1, 2): 3, (2, 1): 4, (2, 2): 1}\n\n        # Unit transportation costs from station k to demand j (c'_kj)\n        cost_kj = {(1, 1): 3, (1, 2): 2, (2, 1): 1, (2, 2): 4}\n\n        # --- Create Gurobi Model ---\n        model = gp.Model(\"FixedChargeTransshipment\")\n\n        # --- Decision Variables ---\n        # x[i,k]: amount shipped from production point i to marshaling station k\n        x = model.addVars(production_points,\n                          marshaling_stations,\n                          name=\"x\",\n                          lb=0.0,\n                          vtype=GRB.CONTINUOUS)\n\n        # y[k,j]: amount shipped from marshaling station k to demand point j\n        y = model.addVars(marshaling_stations,\n                          demand_points,\n                          name=\"y\",\n                          lb=0.0,\n                          vtype=GRB.CONTINUOUS)\n\n        # u[k]: 1 if marshaling station k is used, 0 otherwise\n        u = model.addVars(marshaling_stations, name=\"u\", vtype=GRB.BINARY)\n\n        # --- Objective Function: Minimize Total Cost ---\n        var_cost_ik = gp.quicksum(cost_ik[i, k] * x[i, k]\n                                  for i in production_points\n                                  for k in marshaling_stations)\n        var_cost_kj = gp.quicksum(cost_kj[k, j] * y[k, j]\n                                  for k in marshaling_stations\n                                  for j in demand_points)\n        total_fixed_cost = gp.quicksum(fixed_costs[k] * u[k]\n                                       for k in marshaling_stations)\n\n        model.setObjective(var_cost_ik + var_cost_kj + total_fixed_cost,\n                           GRB.MINIMIZE)\n\n        # --- Constraints ---\n        # 1. Supply Constraints: sum_k x[i,k] <= supply[i] for each i\n        for i in production_points:\n            model.addConstr(gp.quicksum(x[i, k] for k in marshaling_stations)\n                            <= supply[i],\n                            name=f\"Supply_{i}\")\n\n        # 2. Demand Constraints: sum_k y[k,j] == demand[j] for each j\n        for j in demand_points:\n            model.addConstr(gp.quicksum(\n                y[k, j] for k in marshaling_stations) == demand[j],\n                            name=f\"Demand_{j}\")\n\n        # 3. Flow Conservation at Marshaling Stations: sum_i x[i,k] == sum_j y[k,j] for each k\n        for k in marshaling_stations:\n            model.addConstr(gp.quicksum(\n                x[i, k] for i in production_points) == gp.quicksum(\n                    y[k, j] for j in demand_points),\n                            name=f\"FlowCons_Station_{k}\")\n\n        # 4. Marshaling Station Capacity and Usage: sum_i x[i,k] <= capacity[k] * u[k] for each k\n        for k in marshaling_stations:\n            model.addConstr(gp.quicksum(x[i, k] for i in production_points)\n                            <= station_capacities[k] * u[k],\n                            name=f\"Capacity_Station_{k}\")\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal transportation plan found.\")\n            print(f\"Minimum Total Cost: {model.ObjVal:.2f}\")\n\n            print(\n                \"\\nShipments from Production Points to Marshaling Stations (x_ik):\"\n            )\n            for i in production_points:\n                for k in marshaling_stations:\n                    if x[i, k].X > 1e-6:  # Print only if flow is significant\n                        print(\n                            f\"  From Production {i} to Station {k}: {x[i,k].X:.2f} units\"\n                        )\n\n            print(\n                \"\\nShipments from Marshaling Stations to Demand Points (y_kj):\"\n            )\n            for k in marshaling_stations:\n                for j in demand_points:\n                    if y[k, j].X > 1e-6:  # Print only if flow is significant\n                        print(\n                            f\"  From Station {k} to Demand {j}: {y[k,j].X:.2f} units\"\n                        )\n\n            print(\"\\nMarshaling Station Usage (u_k):\")\n            total_flow_through_station = {}\n            for k in marshaling_stations:\n                flow = sum(x[i, k].X for i in production_points)\n                total_flow_through_station[k] = flow\n                if u[k].X > 0.5:  # If station is used\n                    print(\n                        f\"  Station {k}: Used (Fixed Cost: {fixed_costs[k]}). Flow: {flow:.2f} / Capacity: {station_capacities[k]}\"\n                    )\n                else:\n                    print(f\"  Station {k}: Not Used. Flow: {flow:.2f}\")\n\n            # Verification\n            print(\"\\nVerification:\")\n            print(\"  Supply Check:\")\n            for i in production_points:\n                shipped_from_i = sum(x[i, k].X for k in marshaling_stations)\n                print(\n                    f\"    Production {i}: Shipped {shipped_from_i:.2f}, Supply {supply[i]}\"\n                )\n\n            print(\"  Demand Check:\")\n            for j in demand_points:\n                received_at_j = sum(y[k, j].X for k in marshaling_stations)\n                print(\n                    f\"    Demand {j}: Received {received_at_j:.2f}, Demand {demand[j]}\"\n                )\n\n            print(\"  Station Flow Conservation Check:\")\n            for k in marshaling_stations:\n                inflow_k = sum(x[i, k].X for i in production_points)\n                outflow_k = sum(y[k, j].X for j in demand_points)\n                print(\n                    f\"    Station {k}: Inflow={inflow_k:.2f}, Outflow={outflow_k:.2f} (Difference: {inflow_k - outflow_k:.2f})\"\n                )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\"Model is infeasible. Check constraints and parameters.\")\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            # model.computeIIS()\n            # model.write(\"transshipment_iis.ilp\")\n            # print(\"IIS written to transshipment_iis.ilp.\")\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_fixed_charge_transshipment()",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Transshipment",
        "modeling_type": "MILP",
        "industry_sector": "Logistics",
        "reason": "The problem involves moving goods from production points to demand points via intermediate marshaling stations, which is a classic transshipment problem. The inclusion of fixed costs for using marshaling stations and binary decision variables makes it a Mixed-Integer Linear Program (MILP), and the application is clearly within the domain of managing material flow and transportation, hence logistics."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "B040",
    "description": "A person has a fund of 500,000 yuan and the following investment projects available in the next three years:\n\n(1) Investment can be made at the beginning of each year within three years, and the annual profit is 20% of the investment amount.\n\n(2) Investment is only allowed at the beginning of the first year, and can be recovered at the end of the second year, with the total principal and interest being 150% of the investment amount. However, this type of investment is limited to no more than 120,000 yuan.\n\n(3) Investment at the beginning of the second year, recoverable at the end of the second year, with the total principal and interest being 160% of the investment amount. This type of investment is limited to 150,000 yuan.\n\n(4) Investment is allowed at the beginning of the third year, recoverable in one year, with a profit of 40%, and the investment limit is 100,000 yuan.\n\nDetermine an investment plan for the person that maximizes the total principal and interest by the end of the third year.",
    "ground_truth": 964640.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_investment_problem_new_scenario():\n    \"\"\"\n    Solves the multi-period investment problem to maximize\n    the total principal and interest at the end of the third year.\n    \"\"\"\n    try:\n        # Initial capital\n        K0 = 500000.0\n\n        # Create a new model\n        model = gp.Model(\"MultiPeriodInvestment_NewScenario\")\n\n        # --- Decision Variables ---\n        # x_ij: amount invested in project i at the start of year j\n\n        # Project 1: Annual, 20% profit (return 1.2)\n        x11 = model.addVar(name=\"x11_P1_Y1\", lb=0.0,\n                           vtype=GRB.CONTINUOUS)  # P1, Start of Year 1\n        x12 = model.addVar(name=\"x12_P1_Y2\", lb=0.0,\n                           vtype=GRB.CONTINUOUS)  # P1, Start of Year 2\n        x13 = model.addVar(name=\"x13_P1_Y3\", lb=0.0,\n                           vtype=GRB.CONTINUOUS)  # P1, Start of Year 3\n\n        # Project 2: Start Y1, 2-year, 150% total return (factor 1.5), limit 120k\n        # Matures EOY2 (SOY3)\n        x21 = model.addVar(name=\"x21_P2_Y1\", lb=0.0, vtype=GRB.CONTINUOUS)\n\n        # Project 3: Start Y2, 1-year, 160% total return (factor 1.6), limit 150k\n        # Matures EOY2 (SOY3)\n        x32 = model.addVar(name=\"x32_P3_Y2\", lb=0.0, vtype=GRB.CONTINUOUS)\n\n        # Project 4: Start Y3, 1-year, 40% profit (return 1.4), limit 100k\n        # Matures EOY3\n        x43 = model.addVar(name=\"x43_P4_Y3\", lb=0.0, vtype=GRB.CONTINUOUS)\n\n        # --- Objective Function ---\n        # Maximize total principal and interest at the end of Year 3.\n        # Z = K0 + 0.2*x11 + 0.5*x21 + 0.2*x12 + 0.6*x32 + 0.2*x13 + 0.4*x43\n        objective = K0 + 0.2 * x11 + 0.5 * x21 + 0.2 * x12 + 0.6 * x32 + 0.2 * x13 + 0.4 * x43\n        model.setObjective(objective, GRB.MAXIMIZE)\n\n        # --- Constraints ---\n        # 1. Cash Availability at Start of Year 1\n        # Investments_SOY1 <= K0\n        model.addConstr(x11 + x21 <= K0, \"Cash_SOY1\")\n\n        # 2. Cash Availability at Start of Year 2\n        # Investments_SOY2 <= K0 + 0.2*x11 - x21\n        # x12 + x32 - 0.2*x11 + x21 <= K0\n        model.addConstr(x12 + x32 - 0.2 * x11 + x21 <= K0, \"Cash_SOY2\")\n\n        # 3. Cash Availability at Start of Year 3\n        # Investments_SOY3 <= K0 + 0.2*x11 + 0.5*x21 + 0.2*x12 + 0.6*x32\n        # x13 + x43 - 0.2*x11 - 0.5*x21 - 0.2*x12 - 0.6*x32 <= K0\n        model.addConstr(\n            x13 + x43 - 0.2 * x11 - 0.5 * x21 - 0.2 * x12 - 0.6 * x32 <= K0,\n            \"Cash_SOY3\")\n\n        # 4. Investment Limit for Project 2\n        model.addConstr(x21 <= 120000, \"Limit_P2\")\n\n        # 5. Investment Limit for Project 3\n        model.addConstr(x32 <= 150000, \"Limit_P3\")\n\n        # 6. Investment Limit for Project 4\n        model.addConstr(x43 <= 100000, \"Limit_P4\")\n\n        # Suppress Gurobi output to console\n        model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal investment plan found.\")\n            print(\n                f\"Maximum Principal and Interest at End of Year 3: {model.objVal:.2f} yuan\"\n            )\n\n            total_profit = model.objVal - K0\n            print(f\"Total Profit over 3 years: {total_profit:.2f} yuan\")\n\n            print(\"\\nInvestment Plan Details (yuan):\")\n            # Start of Year 1\n            print(\"  Start of Year 1:\")\n            print(f\"    Project 1 (Annual, 20% profit, x11): {x11.X:.2f}\")\n            print(\n                f\"    Project 2 (2-year, 150% return, limit 120k, x21): {x21.X:.2f}\"\n            )\n            cash_soy1_invested = x11.X + x21.X\n            cash_soy1_uninvested = K0 - cash_soy1_invested\n            print(f\"    Total invested at SOY1: {cash_soy1_invested:.2f}\")\n            print(\n                f\"    Uninvested cash carried from SOY1: {cash_soy1_uninvested:.2f}\"\n            )\n\n            # Start of Year 2\n            cash_available_soy2 = K0 + 0.2 * x11.X - x21.X\n            print(\n                f\"\\n  Cash available at Start of Year 2: {cash_available_soy2:.2f}\"\n            )\n            print(\"  Start of Year 2:\")\n            print(f\"    Project 1 (Annual, 20% profit, x12): {x12.X:.2f}\")\n            print(\n                f\"    Project 3 (1-year, 160% return, limit 150k, x32): {x32.X:.2f}\"\n            )\n            cash_soy2_invested = x12.X + x32.X\n            cash_soy2_uninvested = cash_available_soy2 - cash_soy2_invested\n            print(f\"    Total invested at SOY2: {cash_soy2_invested:.2f}\")\n            print(\n                f\"    Uninvested cash carried from SOY2: {cash_soy2_uninvested:.2f}\"\n            )\n\n            # Start of Year 3\n            cash_available_soy3 = K0 + 0.2 * x11.X + 0.5 * x21.X + 0.2 * x12.X + 0.6 * x32.X\n            print(\n                f\"\\n  Cash available at Start of Year 3: {cash_available_soy3:.2f}\"\n            )\n            print(\"  Start of Year 3:\")\n            print(f\"    Project 1 (Annual, 20% profit, x13): {x13.X:.2f}\")\n            print(\n                f\"    Project 4 (1-year, 40% profit, limit 100k, x43): {x43.X:.2f}\"\n            )\n            cash_soy3_invested = x13.X + x43.X\n            cash_soy3_uninvested = cash_available_soy3 - cash_soy3_invested\n            print(f\"    Total invested at SOY3: {cash_soy3_invested:.2f}\")\n            print(\n                f\"    Uninvested cash from SOY3 (forms part of EOY3 total): {cash_soy3_uninvested:.2f}\"\n            )\n\n        else:\n            print(\"No optimal solution found. Status code:\", model.status)\n\n    except gp.GurobiError as e:\n        print(f\"Error code {e.errno}: {e}\")\n    except AttributeError:\n        print(\n            \"Encountered an attribute error. Gurobi might not be installed or licensed correctly.\"\n        )\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_investment_problem_new_scenario()",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Finance",
        "reason": "The problem involves allocating a limited fund across various investment projects over multiple time periods to maximize total returns, which is a classic resource allocation problem. The solver uses continuous variables and linear constraints and objective function, making it a Linear Program. The context of funds, investments, and profits clearly places it within the finance sector."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "B005",
    "description": "The contract reservations for the next year for products I, II, and III of a certain factory in each quarter are shown in Table 1-10.\n\nTable 1-10\n| Product | 1    | 2    | 3    | 4    |\n|---------|------|------|------|------|\n| I       | 1500 | 1000 | 2000 | 1200 |\n| II      | 1500 | 1500 | 1200 | 1500 |\n| III     | 1000 | 2000 | 1500 | 2500 |\n\nAt the beginning of the first quarter, there is no inventory for these three products, and it is required to have 150 units in stock for each product by the end of the fourth quarter. It is known that the factory has 15,000 production hours per quarter, and each unit of products I, II, and III requires 2, 4, and 3 hours respectively. Due to a change in equipment, product I cannot be produced in the second quarter. It is stipulated that if the products cannot be delivered on time, a compensation of 20 yuan per unit per quarter delay is required for products I and II, while for product III, the compensation is 10 yuan. Additionally, for products produced but not delivered in the current quarter, the inventory cost is 5 yuan per unit per quarter. How should the factory schedule production to minimize the total cost of compensation and inventory?",
    "ground_truth": 10755.0,
    "formulation": null,
    "correct_program": "from gurobipy import Model, GRB, quicksum\n\n\ndef solve_factory_scheduling():\n    # --- 模型初始化 ---\n    model = Model(\"FactoryProductionScheduling\")\n\n    # --- 集合定义 ---\n    products = [\"I\", \"II\", \"III\"]\n    quarters = list(range(4))  # 0: Q1, 1: Q2, 2: Q3, 3: Q4\n\n    # --- 参数定义 ---\n    demand = {\n        (\"I\", 0): 1500,\n        (\"I\", 1): 1000,\n        (\"I\", 2): 2000,\n        (\"I\", 3): 1200,\n        (\"II\", 0): 1500,\n        (\"II\", 1): 1500,\n        (\"II\", 2): 1200,\n        (\"II\", 3): 1500,\n        (\"III\", 0): 1000,\n        (\"III\", 1): 2000,\n        (\"III\", 2): 1500,\n        (\"III\", 3): 2500,\n    }\n\n    initial_inventory = {prod: 0 for prod in products}  # 期初库存\n    ending_inventory_target = {prod: 150 for prod in products}  # 第四季度末库存目标\n\n    production_hours_per_quarter = 15000  # 每季度可用生产工时\n\n    hours_per_unit = {  # 每单位产品所需工时\n        \"I\": 2,\n        \"II\": 4,\n        \"III\": 3,\n    }\n\n    # 产品I在第二季度 (索引1) 不能生产\n    production_restriction_product = \"I\"\n    production_restriction_quarter = 1\n\n    backlog_cost_per_unit_per_quarter = { # 单位产品每季度延期赔偿\n        \"I\": 20,\n        \"II\": 20,\n        \"III\": 10,\n    }\n\n    inventory_cost_per_unit_per_quarter = 5  # 单位产品每季度库存成本\n\n    # --- 决策变量 ---\n    # P[p, q]: 在季度q生产产品p的数量\n    P = model.addVars(products,\n                      quarters,\n                      name=\"Production\",\n                    #   vtype=GRB.CONTINUOUS,\n                      vtype=GRB.INTEGER,\n                      lb=0)\n    # I[p, q]: 在季度q末产品p的库存量\n    I = model.addVars(products,\n                      quarters,\n                      name=\"Inventory\",\n                    #   vtype=GRB.CONTINUOUS,\n                      vtype=GRB.INTEGER,\n                      lb=0)\n    # B[p, q]: 在季度q末产品p的积压订单量\n    B = model.addVars(products,\n                      quarters,\n                      name=\"Backlog\",\n                    #   vtype=GRB.CONTINUOUS,\n                      vtype=GRB.INTEGER,\n                      lb=0)\n\n    # --- 目标函数: 最小化总成本 (赔偿成本 + 库存成本) ---\n    total_backlog_cost = quicksum(\n        B[p, q] * backlog_cost_per_unit_per_quarter[p] for p in products\n        for q in quarters)\n    total_inventory_cost = quicksum(\n        I[p, q] * inventory_cost_per_unit_per_quarter for p in products\n        for q in quarters)\n\n    model.setObjective(total_backlog_cost + total_inventory_cost, GRB.MINIMIZE)\n\n    # --- 约束条件 ---\n    for q in quarters:\n        # 1. 生产能力约束 (每季度总工时)\n        model.addConstr(quicksum(P[p, q] * hours_per_unit[p] for p in products)\n                        <= production_hours_per_quarter,\n                        name=f\"Capacity_Q{q+1}\")\n\n        for p in products:\n            # 2. 库存平衡约束\n            # 期初库存 (I_prev) + 本期生产 (P) - 本期需求 (D) = 期末库存 (I_curr) - 期末积压 (B_curr)\n            # I_prev - B_prev + P = D + I_curr - B_curr (如果B代表的是净效应)\n            # 我们使用: I[p,q-1] + P[p,q] - Demand[p,q] = I[p,q] - B[p,q]\n            # 这意味着 I[p,q] 和 B[p,q] 中至少一个为0 (或模型会趋向于此以最小化成本)\n\n            inventory_at_start_of_quarter = I[\n                p, q - 1] if q > 0 else initial_inventory[p]\n            # 积压订单是上期末的，本期需要优先满足\n            # 修正库存平衡方程：\n            # (上期末库存 - 上期末积压) + 本期生产 - 本期需求 = (本期末库存 - 本期末积压)\n            # I[p, q-1] - B[p, q-1] + P[p,q] - D[p,q] = I[p,q] - B[p,q]\n            # 整理为： I[p,q-1] + P[p,q] + B[p,q] = D[p,q] + I[p,q] + B[p,q-1]\n            # 这个形式更标准，表示 (可供量) + (新欠货) = (需求) + (结转库存) + (已满足的旧欠货或继续欠)\n\n            backlog_at_start_of_quarter = B[p, q - 1] if q > 0 else 0  # 初始无积压\n\n            model.addConstr(inventory_at_start_of_quarter + P[p, q] +\n                            B[p, q] == demand[p, q] + I[p, q] +\n                            backlog_at_start_of_quarter,\n                            name=f\"InventoryBalance_{p}_Q{q+1}\")\n\n    # 3. 特定生产限制: 产品I在第二季度 (索引1) 不能生产\n    model.addConstr(\n        P[production_restriction_product, production_restriction_quarter] == 0,\n        name=\n        f\"NoProduction_{production_restriction_product}_Q{production_restriction_quarter+1}\"\n    )\n\n    # 4. 期末库存要求: 第四季度末 (索引3)\n    for p in products:\n        model.addConstr(I[p, quarters[-1]] >= ending_inventory_target[p],\n                        name=f\"EndingInventory_{p}\")\n        # 确保第四季度末没有积压订单，虽然目标函数会尝试最小化积压，但这里可以明确要求\n        # 如果允许第四季度末有积压，则不需要此约束。题目未明确禁止，但通常目标是清零。\n        # 考虑到有期末库存目标，清零积压是合理的。\n        model.addConstr(B[p, quarters[-1]] == 0, name=f\"EndingBacklogZero_{p}\")\n\n    # --- 模型求解 ---\n    model.optimize()\n\n    # --- 打印结果 ---\n    if model.status == GRB.OPTIMAL:\n        print(f\"\\n找到最优生产计划! 最小总成本: {model.objVal:,.2f} 元\")\n        print(\"-\" * 100)\n        print(\n            f\"{'产品':<5} | {'季度':<5} | {'生产量':>10} | {'期末库存':>10} | {'期末积压':>10} | {'需求量':>10}\"\n        )\n        print(\"=\" * 100)\n        for q in quarters:\n            for p in products:\n                print(\n                    f\"{p:<5} | {q+1:<5} | {P[p,q].X:>10.1f} | {I[p,q].X:>10.1f} | {B[p,q].X:>10.1f} | {demand[p,q]:>10}\"\n                )\n            print(\"-\" * 100)\n\n        print(\"\\n成本构成:\")\n        calc_total_backlog_cost = sum(\n            B[p, q].X * backlog_cost_per_unit_per_quarter[p] for p in products\n            for q in quarters)\n        calc_total_inventory_cost = sum(\n            I[p, q].X * inventory_cost_per_unit_per_quarter for p in products\n            for q in quarters)\n        print(f\"  总延期赔偿成本: {calc_total_backlog_cost:,.2f} 元\")\n        print(f\"  总库存持有成本: {calc_total_inventory_cost:,.2f} 元\")\n        print(\n            f\"  计算得到的总成本: {calc_total_backlog_cost + calc_total_inventory_cost:,.2f} 元\"\n        )\n\n    elif model.status == GRB.INFEASIBLE:\n        print(\"模型不可行。请检查约束条件是否相互冲突。\")\n        print(\"正在计算不可行子系统 (IIS) 来帮助定位问题...\")\n        model.computeIIS()\n        model.write(\"factory_scheduling_iis.ilp\")\n        print(\"IIS 已写入 factory_scheduling_iis.ilp 文件。\")\n    elif model.status == GRB.UNBOUNDED:\n        print(\"模型无界。目标函数可以无限减小。\")\n    else:\n        print(f\"优化过程因状态码 {model.status} 而停止。\")\n\n\nif __name__ == '__main__':\n    solve_factory_scheduling()",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Production Planning",
        "modeling_type": "MILP",
        "industry_sector": "Manufacturing",
        "reason": "The problem involves determining optimal production quantities for multiple products over several time periods to meet demand while minimizing costs (inventory and backlog), subject to capacity and specific production constraints. This is a classic Production Planning problem. The solver uses integer variables for production, inventory, and backlog, and linear constraints and objective function, making it a Mixed-Integer Linear Program (MILP). The context of a factory producing products falls under the Manufacturing sector."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "B026",
    "description": "A factory produces three types of products: I, II, and III. Each product needs to go through two processing procedures, A and B. The factory has two pieces of equipment that can complete process A, denoted as A1 and A2; it has three pieces of equipment that complete process B, denoted as B1, B2, and B3. Product I can be processed on any equipment for A and B; Product II can be processed on any A equipment but only on B1 for process B; Product III can only be processed on A2 and B2. Given the unit processing time on various machines, raw material costs, product sale prices, effective machine hours, and the costs of operating the machines at full capacity as shown in Table 1-4, the task is to arrange the optimal production plan to maximize the factory's profit.\n\nTable 1-4\n| Equipment  | Product I | Product II | Product III | Effective Machine Hours | Operating Costs at Full Capacity (Yuan) |\n|------------|-----------|------------|-------------|--------------------------|------------------------------------------|\n| A1         | 5         | 10         |             | 6000                     | 300                                      |\n| A2         | 7         | 9          | 12          | 10000                    | 321                                      |\n| B1         | 6         | 8          |             | 4000                     | 250                                      |\n| B2         | 4         |            | 11          | 7000                     | 783                                      |\n| B3         | 7         |            |             | 4000                     | 200                                      |\n| Raw Material Cost (Yuan/Unit) | 0.25 | 0.35       | 0.50       |                          |                                          |\n| Unit Price (Yuan/Unit)        | 1.25 | 2.00       | 2.80       |                          |                                          |",
    "ground_truth": 1146.57,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_factory_production():\n    \"\"\"\n    Solves the factory production planning problem to maximize profit.\n    \"\"\"\n    try:\n        # Create a new model\n        model = gp.Model(\"FactoryProductionOptimization\")\n\n        # --- Data ---\n        # Processing times (hours/unit)\n        proc_times = {\n            ('I', 'A1'): 5,\n            ('I', 'A2'): 7,\n            ('II', 'A1'): 10,\n            ('II', 'A2'): 9,\n            ('III', 'A2'): 12,  # Product III only on A2 for Process A\n            ('I', 'B1'): 6,\n            ('I', 'B2'): 4,\n            ('I', 'B3'): 7,\n            ('II', 'B1'): 8,  # Product II only on B1 for Process B\n            ('III', 'B2'): 11  # Product III only on B2 for Process B\n        }\n\n        # Effective machine hours (capacity)\n        capacities = {\n            'A1': 6000,\n            'A2': 10000,\n            'B1': 4000,\n            'B2': 7000,\n            'B3': 4000\n        }\n\n        # Operating costs at full capacity (Yuan)\n        ocfc = {'A1': 300, 'A2': 321, 'B1': 250, 'B2': 783, 'B3': 200}\n\n        # Variable operating costs per hour (Yuan/hr)\n        voc = {m: ocfc[m] / capacities[m] for m in capacities}\n\n        # Raw material costs (Yuan/unit)\n        rmc = {'I': 0.25, 'II': 0.35, 'III': 0.50}\n\n        # Unit sale prices (Yuan/unit)\n        sp = {'I': 1.25, 'II': 2.00, 'III': 2.80}\n\n        products = ['I', 'II', 'III']\n        machines_A = ['A1', 'A2']\n        machines_B = ['B1', 'B2', 'B3']\n        all_machines = machines_A + machines_B\n\n        # --- Decision Variables ---\n        # X_p: Total units of product p to produce\n        X = model.addVars(products, name=\"X\", lb=0.0)\n\n        # x_pm: Quantity of product p processed on machine m\n        # For Process A machines\n        x_IA1 = model.addVar(name=\"x_I_A1\", lb=0.0)\n        x_IA2 = model.addVar(name=\"x_I_A2\", lb=0.0)\n        x_IIA1 = model.addVar(name=\"x_II_A1\", lb=0.0)\n        x_IIA2 = model.addVar(name=\"x_II_A2\", lb=0.0)\n        x_IIIA2 = model.addVar(name=\"x_III_A2\", lb=0.0)  # P-III only on A2\n\n        # For Process B machines\n        x_IB1 = model.addVar(name=\"x_I_B1\", lb=0.0)\n        x_IB2 = model.addVar(name=\"x_I_B2\", lb=0.0)\n        x_IB3 = model.addVar(name=\"x_I_B3\", lb=0.0)\n        x_IIB1 = model.addVar(name=\"x_II_B1\", lb=0.0)  # P-II only on B1\n        x_IIIB2 = model.addVar(name=\"x_III_B2\", lb=0.0)  # P-III only on B2\n\n        # --- Objective Function: Maximize Profit ---\n        total_revenue = gp.quicksum(sp[p] * X[p] for p in products)\n        total_rmc = gp.quicksum(rmc[p] * X[p] for p in products)\n\n        # Variable operating costs\n        op_cost_A1 = (proc_times[('I', 'A1')] * x_IA1 +\n                      proc_times[('II', 'A1')] * x_IIA1) * voc['A1']\n        op_cost_A2 = (proc_times[('I', 'A2')] * x_IA2 +\n                      proc_times[('II', 'A2')] * x_IIA2 +\n                      proc_times[('III', 'A2')] * x_IIIA2) * voc['A2']\n        op_cost_B1 = (proc_times[('I', 'B1')] * x_IB1 +\n                      proc_times[('II', 'B1')] * x_IIB1) * voc['B1']\n        op_cost_B2 = (proc_times[('I', 'B2')] * x_IB2 +\n                      proc_times[('III', 'B2')] * x_IIIB2) * voc['B2']\n        op_cost_B3 = (proc_times[('I', 'B3')] * x_IB3) * voc['B3']\n\n        total_variable_op_cost = op_cost_A1 + op_cost_A2 + op_cost_B1 + op_cost_B2 + op_cost_B3\n\n        profit = total_revenue - total_rmc - total_variable_op_cost\n        model.setObjective(profit, GRB.MAXIMIZE)\n\n        # --- Constraints ---\n        # 1. Machine Capacity Constraints\n        model.addConstr(\n            proc_times[('I', 'A1')] * x_IA1 + proc_times[('II', 'A1')] * x_IIA1\n            <= capacities['A1'], \"Cap_A1\")\n        model.addConstr(\n            proc_times[('I', 'A2')] * x_IA2 +\n            proc_times[('II', 'A2')] * x_IIA2 +\n            proc_times[('III', 'A2')] * x_IIIA2 <= capacities['A2'], \"Cap_A2\")\n        model.addConstr(\n            proc_times[('I', 'B1')] * x_IB1 + proc_times[('II', 'B1')] * x_IIB1\n            <= capacities['B1'], \"Cap_B1\")\n        model.addConstr(\n            proc_times[('I', 'B2')] * x_IB2 +\n            proc_times[('III', 'B2')] * x_IIIB2 <= capacities['B2'], \"Cap_B2\")\n        model.addConstr(proc_times[('I', 'B3')] * x_IB3 <= capacities['B3'],\n                        \"Cap_B3\")\n\n        # 2. Production Flow Conservation\n        # Product I\n        model.addConstr(x_IA1 + x_IA2 == X['I'], \"Flow_I_A\")\n        model.addConstr(x_IB1 + x_IB2 + x_IB3 == X['I'], \"Flow_I_B\")\n        # Product II\n        model.addConstr(x_IIA1 + x_IIA2 == X['II'], \"Flow_II_A\")\n        model.addConstr(x_IIB1 == X['II'], \"Flow_II_B\")  # P-II only on B1\n        # Product III\n        model.addConstr(x_IIIA2 == X['III'], \"Flow_III_A\")  # P-III only on A2\n        model.addConstr(x_IIIB2 == X['III'], \"Flow_III_B\")  # P-III only on B2\n\n        # Suppress Gurobi output to console\n        model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal production plan found.\")\n            print(f\"Maximum Profit: {model.objVal:.2f} Yuan\")\n            print(\"\\nTotal units of each product to produce:\")\n            for p in products:\n                print(f\"  Product {p}: {X[p].X:.2f} units\")\n\n            print(\"\\nProduction allocation (units on each machine):\")\n            print(\"  Process A:\")\n            print(f\"    Product I on A1 (x_I_A1): {x_IA1.X:.2f}\")\n            print(f\"    Product I on A2 (x_I_A2): {x_IA2.X:.2f}\")\n            print(f\"    Product II on A1 (x_II_A1): {x_IIA1.X:.2f}\")\n            print(f\"    Product II on A2 (x_II_A2): {x_IIA2.X:.2f}\")\n            print(f\"    Product III on A2 (x_III_A2): {x_IIIA2.X:.2f}\")\n            print(\"  Process B:\")\n            print(f\"    Product I on B1 (x_I_B1): {x_IB1.X:.2f}\")\n            print(f\"    Product I on B2 (x_I_B2): {x_IB2.X:.2f}\")\n            print(f\"    Product I on B3 (x_I_B3): {x_IB3.X:.2f}\")\n            print(f\"    Product II on B1 (x_II_B1): {x_IIB1.X:.2f}\")\n            print(f\"    Product III on B2 (x_III_B2): {x_IIIB2.X:.2f}\")\n\n            print(\"\\nMachine Utilization (Hours Used / Capacity):\")\n            hours_A1 = proc_times[('I', 'A1')] * x_IA1.X + proc_times[\n                ('II', 'A1')] * x_IIA1.X\n            hours_A2 = proc_times[('I', 'A2')] * x_IA2.X + proc_times[(\n                'II', 'A2')] * x_IIA2.X + proc_times[('III', 'A2')] * x_IIIA2.X\n            hours_B1 = proc_times[('I', 'B1')] * x_IB1.X + proc_times[\n                ('II', 'B1')] * x_IIB1.X\n            hours_B2 = proc_times[('I', 'B2')] * x_IB2.X + proc_times[\n                ('III', 'B2')] * x_IIIB2.X\n            hours_B3 = proc_times[('I', 'B3')] * x_IB3.X\n\n            print(\n                f\"  Machine A1: {hours_A1:.2f} / {capacities['A1']} hours ({hours_A1/capacities['A1']*100:.1f}%)\"\n            )\n            print(\n                f\"  Machine A2: {hours_A2:.2f} / {capacities['A2']} hours ({hours_A2/capacities['A2']*100:.1f}%)\"\n            )\n            print(\n                f\"  Machine B1: {hours_B1:.2f} / {capacities['B1']} hours ({hours_B1/capacities['B1']*100:.1f}%)\"\n            )\n            print(\n                f\"  Machine B2: {hours_B2:.2f} / {capacities['B2']} hours ({hours_B2/capacities['B2']*100:.1f}%)\"\n            )\n            print(\n                f\"  Machine B3: {hours_B3:.2f} / {capacities['B3']} hours ({hours_B3/capacities['B3']*100:.1f}%)\"\n            )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\"Model is infeasible. Check constraints and data.\")\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            # model.computeIIS()\n            # model.write(\"model_iis.ilp\")\n            # print(\"IIS written to model_iis.ilp\")\n        else:\n            print(f\"Optimization was stopped with status {model.status}\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_factory_production()",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Production Planning",
        "modeling_type": "LP",
        "industry_sector": "Manufacturing",
        "reason": "The task involves determining the optimal quantities of different products to produce and how to allocate them to various machines to maximize profit, which is a classic production planning problem. The solver program uses continuous variables and linear constraints and objective function, making it a Linear Program (LP). The context of producing goods in a factory directly points to the manufacturing sector."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "B059",
    "description": "A traveling salesman must visit 7 customers at 7 different locations, with the (symmetric) distance matrix as follows:\n\n|  | 1 | 2 | 3 | 4 | 5 | 6 | 7 |\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\n| 1 | - | 86 | 49 | 57 | 31 | 69 | 50 |\n| 2 |  | - | 68 | 79 | 93 | 24 | 5 |\n| 3 |  |  | - | 16 | 7 | 72 | 67 |\n| 4 |  |  |  | - | 90 | 69 | 1 |\n| 5 |  |  |  |  | - | 86 | 59 |\n| 6 |  |  |  |  |  | - | 81 |\n\nFormulate a mathematical program to determine the visiting order starting and ending at location 1 to minimize the travel distance, and solve it using COPTPY.",
    "ground_truth": 153.0,
    "formulation": null,
    "correct_program": "def solve_tsp(distance_matrix=None):\n    from gurobipy import Model, GRB, quicksum\n\n    # Default distance matrix based on the provided data\n    if distance_matrix is None:\n        distance_matrix = [[0, 86, 49, 57, 31, 69, 50],\n                           [86, 0, 68, 79, 93, 24, 5],\n                           [49, 68, 0, 16, 7, 72, 67],\n                           [57, 79, 16, 0, 90, 69, 1],\n                           [31, 93, 7, 90, 0, 86, 59],\n                           [69, 24, 72, 69, 86, 0, 81],\n                           [50, 5, 67, 1, 59, 81, 0]]\n\n    n = len(distance_matrix)\n    model = Model()\n\n    # Decision variables: x[i,j] binary\n    x = {}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                x[i, j] = model.addVar(vtype=GRB.BINARY, name=f\"x_{i}_{j}\")\n\n    # MTZ variables for subtour elimination\n    u = {}\n    for i in range(1, n):\n        u[i] = model.addVar(lb=2, ub=n, vtype=GRB.CONTINUOUS, name=f\"u_{i}\")\n\n    model.update()\n\n    # Objective: minimize total distance\n    model.setObjective(\n        quicksum(distance_matrix[i][j] * x[i, j] for i in range(n)\n                 for j in range(n) if i != j), GRB.MINIMIZE)\n\n    # Constraints:\n\n    # 1. From start location (0), exactly one outgoing edge\n    model.addConstr(quicksum(x[0, j] for j in range(1, n)) == 1,\n                    name=\"start_out\")\n\n    # 2. Each node (except start) has exactly one incoming edge\n    for j in range(1, n):\n        model.addConstr(quicksum(x[i, j] for i in range(n) if i != j) == 1,\n                        name=f\"node_in_{j}\")\n\n    # 3. Each node (except start) has exactly one outgoing edge\n    for i in range(1, n):\n        model.addConstr(quicksum(x[i, j] for j in range(n) if j != i) == 1,\n                        name=f\"node_out_{i}\")\n\n    # 4. Subtour elimination (MTZ)\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                model.addConstr(u[i] - u[j] + n * x[i, j] <= n - 1,\n                                name=f\"subtour_{i}_{j}\")\n\n    # Optimize\n    model.optimize()\n\n    # Check feasibility\n    if model.status == GRB.OPTIMAL:\n        return model.objVal\n    else:\n        return None\nif __name__ == \"__main__\":\n    result = solve_tsp()\n    if result is not None:\n        print(f\"Optimal total distance: {result}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Routing",
        "modeling_type": "MILP",
        "industry_sector": "Transportation",
        "reason": "The problem is a classic Traveling Salesman Problem (TSP), which falls under the Routing domain. The solver uses binary decision variables and linear constraints, including MTZ subtour elimination, making it a Mixed-Integer Linear Program (MILP). The context of a 'traveling salesman' visiting 'customers at different locations' directly relates to the Transportation sector."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "B012",
    "description": "Tom and Jerry just bought a farm in Sunshine Valley, and they are considering using it to plant corn, wheat, soybeans, and sorghum. The profit per acre for planting corn is $1500, the profit per acre for planting wheat is $1200, the profit per acre for planting soybeans is $1800, and the profit per acre for planting sorghum is $1600. To maximize their profit, how many acres of land should they allocate to each crop? Tom and Jerry’s farm has a total area of 100 acres.\n\nThe land area used for planting corn must be at least twice the land area used for planting wheat.\n\nThe land area used for planting soybeans must be at least half the land area used for planting sorghum.\n\nThe land area used for planting wheat must be three times the land area used for planting sorghum.",
    "ground_truth": 180000.0,
    "formulation": null,
    "correct_program": "def optimize_crop_allocation(total_land=100,\n                             profit_c=1500,\n                             profit_w=1200,\n                             profit_s=1800,\n                             profit_so=1600):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"Crop_Profit_Maximization\")\n\n    # Decision variables\n    x_c = model.addVar(name=\"corn\", lb=0)\n    x_w = model.addVar(name=\"wheat\", lb=0)\n    x_s = model.addVar(name=\"soybeans\", lb=0)\n    x_so = model.addVar(name=\"sorghum\", lb=0)\n\n    # Set objective: maximize profit\n    model.setObjective(\n        profit_c * x_c + profit_w * x_w + profit_s * x_s + profit_so * x_so,\n        GRB.MAXIMIZE)\n\n    # Add constraints\n    # Total land constraint\n    model.addConstr(x_c + x_w + x_s + x_so <= total_land, \"TotalLand\")\n    # Wheat equals three times sorghum\n    model.addConstr(x_w == 3 * x_so, \"WheatSorghumRatio\")\n    # Corn at least twice wheat\n    model.addConstr(x_c >= 2 * x_w, \"CornWheatRatio\")\n    # Soybeans at least half sorghum\n    model.addConstr(x_s >= 0.5 * x_so, \"SoySorghumRatio\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the total profit of the optimal solution\n        return model.objVal\n    else:\n        # No feasible solution found\n        return None\nif __name__ == \"__main__\":\n    result = optimize_crop_allocation()\n    if result is not None:\n        print(f\"Optimal total profit: {result}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Agriculture",
        "reason": "The problem involves allocating a limited resource (land) among competing activities (crop planting) to maximize profit, which is a classic resource allocation problem. The model uses linear objective and constraints with continuous variables, making it a Linear Program. The application is directly related to farming and crop production, hence 'Agriculture'."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "B084",
    "description": "A company is producing two products (X and Y). The resources required for the production of X and Y are divided into two parts: machine time for automated processing and craftsman time for manual finishing. The table below shows the number of minutes required for each product:\n\n| Item | Machine Time (minutes) | Craftsman Time (minutes) |\n| :---: | :---: | :---: |\n| X | 13 | 20 |\n| Y | 19 | 29 |\n\nThe company has 40 hours of machine time available in the next working week, but only 35 hours of craftsman time. The cost of machine time is £10 per hour, and the cost of craftsman time is £2 per hour. Idle time for machines and craftsmen incurs no cost. For each product produced (all products produced will be sold), the revenue for product X is £20, and the revenue for product Y is £30. The company has a specific contract that requires 10 units of product X to be produced for a customer each week. Formulate a model for this problem.",
    "ground_truth": 1861.466666667,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_production_profit_maximization():\n    \"\"\"\n    Solves the production planning problem to maximize weekly profit\n    for products X and Y, subject to time and contract constraints.\n    \"\"\"\n    try:\n        # --- Parameters ---\n        products = ['X', 'Y']\n\n        # Time requirements (minutes/unit)\n        machine_time_req = {'X': 13, 'Y': 19}\n        craftsman_time_req = {'X': 20, 'Y': 29}\n\n        # Time availability (minutes/week)\n        avail_machine_time = 40 * 60  # 2400 minutes\n        avail_craftsman_time = 35 * 60  # 2100 minutes\n\n        # Costs (per minute)\n        cost_machine_per_min = 10 / 60\n        cost_craftsman_per_min = 2 / 60\n\n        # Revenue (per unit)\n        revenue = {'X': 20, 'Y': 30}\n\n        # Contract requirement\n        min_production_X = 10\n\n        # Calculate profit per unit\n        profit_per_unit = {}\n        for p in products:\n            cost_machine = machine_time_req[p] * cost_machine_per_min\n            cost_craftsman = craftsman_time_req[p] * cost_craftsman_per_min\n            profit_per_unit[p] = revenue[p] - cost_machine - cost_craftsman\n            # print(f\"Profit per unit {p}: {profit_per_unit[p]:.4f}\") # For verification\n\n        # --- Create Gurobi Model ---\n        model = gp.Model(\"ProductionProfitMaximization\")\n\n        # --- Decision Variables ---\n        # N[p]: Number of units of product p produced per week\n        N = model.addVars(products, name=\"Produce\", vtype=GRB.INTEGER, lb=0)\n\n        # --- Objective Function: Maximize Total Profit ---\n        # Profit = Sum(Profit_per_unit[p] * N[p])\n        model.setObjective(\n            gp.quicksum(profit_per_unit[p] * N[p] for p in products),\n            GRB.MAXIMIZE)\n\n        # --- Constraints ---\n        # 1. Machine Time Constraint\n        model.addConstr(gp.quicksum(machine_time_req[p] * N[p]\n                                    for p in products) <= avail_machine_time,\n                        name=\"MachineTimeLimit\")\n\n        # 2. Craftsman Time Constraint\n        model.addConstr(gp.quicksum(craftsman_time_req[p] * N[p]\n                                    for p in products) <= avail_craftsman_time,\n                        name=\"CraftsmanTimeLimit\")\n\n        # 3. Contract Requirement for Product X\n        model.addConstr(N['X'] >= min_production_X, name=\"ContractX\")\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal production plan found.\")\n            print(f\"Maximum Weekly Profit: £{model.ObjVal:.2f}\")\n\n            print(\"\\nOptimal Production Quantities (units per week):\")\n            for p in products:\n                print(f\"  Product {p}: {N[p].X:.0f} units\")\n\n            print(\"\\nResource Utilization:\")\n            machine_time_used = sum(machine_time_req[p] * N[p].X\n                                    for p in products)\n            craftsman_time_used = sum(craftsman_time_req[p] * N[p].X\n                                      for p in products)\n            print(\n                f\"  Machine Time Used: {machine_time_used:.2f} / {avail_machine_time} minutes \"\n                f\"({(machine_time_used/avail_machine_time*100) if avail_machine_time > 0 else 0:.1f}%)\"\n            )\n            print(\n                f\"  Craftsman Time Used: {craftsman_time_used:.2f} / {avail_craftsman_time} minutes \"\n                f\"({(craftsman_time_used/avail_craftsman_time*100) if avail_craftsman_time > 0 else 0:.1f}%)\"\n            )\n\n            print(\"\\nContract Fulfillment:\")\n            print(\n                f\"  Product X Produced: {N['X'].X:.0f} (Min Required: {min_production_X})\"\n            )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\"Model is infeasible. Check constraints and requirements.\")\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            # model.computeIIS()\n            # model.write(\"production_profit_iis.ilp\")\n            # print(\"IIS written to production_profit_iis.ilp.\")\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n            if model.SolCount == 0:\n                print(\"No feasible solution found.\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_production_profit_maximization()",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Production Planning",
        "modeling_type": "MILP",
        "industry_sector": "Manufacturing",
        "reason": "The problem involves determining optimal production quantities for products given resource constraints and aims to maximize profit, which is characteristic of Production Planning. The model uses integer decision variables and linear constraints and objective, making it a Mixed-Integer Linear Program."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "B002",
    "description": "For the manufacturing industry, formulating an appropriate product production plan and human resource management scheme is very important for reducing operating costs, inventory costs, stockout costs, and labor costs. Specifically, for products with large demand fluctuations, companies need to accurately predict demand and formulate corresponding production plans. A certain company produces a type of foldable table, the raw material cost for each product is 90 Yuan, and the labor hours are 5 hours. The unit price of the product is 300 Yuan. The company has 1,000 workers at the beginning of January and holds an inventory of 15,000 units. The regular hourly wage for workers is 30 Yuan, with a normal daily working time of 8 hours. Any extra working time is considered overtime, with an overtime hourly wage of 40 Yuan. The number of working days per month is calculated as 20 days. Suppose the company's available production machines are sufficient, and the capacity is not limited by machine hours. Each worker's overtime hours do not exceed 20 hours per month. Holding inventory will generate corresponding inventory costs. If a stockout occurs due to insufficient capacity, there will be certain stockout costs. Additionally, the company can also make up for the stockout part through outsourcing. The outsourcing cost per product, monthly inventory cost, and monthly stockout cost are 200 Yuan, 15 Yuan, and 35 Yuan, respectively. The company's employees are temporary workers, and the company can flexibly decide the number of people to hire and fire each month. The cost of hiring and firing a single employee is 5,000 Yuan and 8,000 Yuan, respectively. Suppose the company has used the existing forecasting model to predict the demand from January to June, as shown in Table 4.1.\n\nTable 4.1: Demand Forecast\n\n| Month | 1   | 2   | 3   | 4   | 5   | 6   |\n|:-----:|:---:|:---:|:---:|:---:|:---:|:---:|\n| Demand Forecast | 20000 | 40000 | 42000 | 35000 | 19000 | 18500 |\n\nPlease formulate a production plan, worker work schedule, and hire/fire plan for the company to maximize the total net profit over 6 months while ensuring that the company holds at least 10,000 units of products by the end of June.",
    "ground_truth": 10349920.0,
    "formulation": null,
    "correct_program": "from gurobipy import Model, GRB, quicksum\n# import gurobipy # This line is redundant and has been removed\n\n\ndef solve_production_planning_revised():\n    # --- Model Initialization ---\n    # --- 模型初始化 ---\n    m = Model(\"FoldableTableProductionRevised\")\n\n    # --- Time Horizon ---\n    # --- 时间范围 ---\n    months = list(range(6))\n    month_names = [\"January\", \"February\", \"March\", \"April\", \"May\",\n                   \"June\"]  # 月份名称\n\n    # --- Parameters ---\n    # --- 参数 ---\n    raw_material_cost_per_unit = 90  # 原材料成本/单位 (元)\n    regular_hourly_wage = 30  # 正常时薪 (元)\n    overtime_hourly_wage = 40  # 加班时薪 (元)\n    inventory_cost_per_unit_per_month = 15  # 库存成本/单位/月 (元)\n    stockout_penalty_per_unmet_unit = 35  # 最终未满足需求的缺货成本/单位 (元)\n    outsourcing_cost_per_unit = 200  # 外包成本/单位 (元)\n    hiring_cost_per_worker = 5000  # 雇佣成本/人 (元)\n    firing_cost_per_worker = 8000  # 解雇成本/人 (元)\n\n    labor_hours_per_unit = 5  # 单位产品所需工时 (小时)\n    selling_price_per_unit = 300  # 单位产品售价 (元)\n\n    initial_workers = 1000  # 初始工人数\n    normal_daily_working_hours = 8  # 每日正常工作时长 (小时)\n    working_days_per_month = 20  # 每月工作天数\n    normal_hours_per_worker_per_month = normal_daily_working_hours * working_days_per_month  # 每人每月正常工作时长 (小时)\n    max_overtime_hours_per_worker_per_month = 20  # 每人每月最大加班时长 (小时)\n\n    initial_inventory = 15000  # 初始库存 (单位)\n    min_ending_inventory_june = 10000  # 六月底最低期末库存 (单位)\n\n    # Demand Forecast (units per month)\n    # 需求预测 (单位/月)\n    demand_forecast = {\n        0: 20000,  # January  (一月)\n        1: 40000,  # February (二月)\n        2: 42000,  # March    (三月)\n        3: 35000,  # April    (四月)\n        4: 19000,  # May      (五月)\n        5: 18500  # June     (六月)\n    }\n\n    # --- Decision Variables ---\n    # --- 决策变量 ---\n    # P[t]: Production quantity in month t\n    # P[t]: 月份 t 的生产数量\n    P = m.addVars(months, name=\"Production\", vtype=GRB.INTEGER, lb=0)\n    # W[t]: Number of workers during month t (after hiring/firing)\n    # W[t]: 月份 t 的工人数 (雇佣/解雇后)\n    W = m.addVars(months, name=\"Workers\", vtype=GRB.INTEGER, lb=0)\n    # H[t]: Number of workers hired at the start of month t\n    # H[t]: 月份 t 初雇佣的工人数\n    H = m.addVars(months, name=\"Hired\", vtype=GRB.INTEGER, lb=0)\n    # F[t]: Number of workers fired at the start of month t\n    # F[t]: 月份 t 初解雇的工人数\n    F = m.addVars(months, name=\"Fired\", vtype=GRB.INTEGER, lb=0)\n    # OT_total[t]: Total overtime hours in month t\n    # OT_total[t]: 月份 t 的总加班工时\n    OT_total = m.addVars(months,\n                         name=\"OvertimeHours\",\n                         vtype=GRB.CONTINUOUS,\n                         lb=0)\n    OT_total = m.addVars(months, name=\"OvertimeHours\", vtype=GRB.INTEGER, lb=0)\n    # Inv[t]: Inventory at the end of month t\n    # Inv[t]: 月份 t 的期末库存\n    Inv = m.addVars(months, name=\"Inventory\", vtype=GRB.INTEGER, lb=0)\n    # Outsource[t]: Units outsourced in month t\n    # Outsource[t]: 月份 t 的外包数量\n    Outsource = m.addVars(months, name=\"Outsourced\", vtype=GRB.INTEGER, lb=0)\n    # S[t]: Final unmet demand (stockout) in month t\n    # S[t]: 月份 t 的最终未满足需求 (缺货) 数量\n    S = m.addVars(months, name=\"StockoutUnmet\", vtype=GRB.INTEGER, lb=0)\n\n    # --- Objective Function: Maximize Total Net Profit ---\n    # --- 目标函数: 最大化总净利润 ---\n    # Revenue is based on units sold (Demand - Unmet Stockout)\n    # 收入基于销售数量 (需求 - 未满足的缺货)\n    total_revenue = quicksum(\n        (demand_forecast[t] - S[t]) * selling_price_per_unit for t in months)\n\n    total_raw_material_cost = quicksum(P[t] * raw_material_cost_per_unit\n                                       for t in months)\n    total_regular_labor_cost = quicksum(\n        W[t] * normal_hours_per_worker_per_month * regular_hourly_wage\n        for t in months)\n    total_overtime_labor_cost = quicksum(OT_total[t] * overtime_hourly_wage\n                                         for t in months)\n    total_inventory_cost = quicksum(Inv[t] * inventory_cost_per_unit_per_month\n                                    for t in months)\n    # Outsourcing cost is now separate\n    # 外包成本现在是分开的\n    total_outsourcing_cost = quicksum(Outsource[t] * outsourcing_cost_per_unit\n                                      for t in months)\n    # Stockout cost for final unmet demand\n    # 最终未满足需求的缺货成本\n    total_stockout_unmet_cost = quicksum(S[t] * stockout_penalty_per_unmet_unit\n                                         for t in months)\n    total_hiring_cost = quicksum(H[t] * hiring_cost_per_worker for t in months)\n    total_firing_cost = quicksum(F[t] * firing_cost_per_worker for t in months)\n\n    total_costs = (\n        total_raw_material_cost + total_regular_labor_cost +\n        total_overtime_labor_cost + total_inventory_cost +\n        total_outsourcing_cost + total_stockout_unmet_cost\n        +  # Added stockout cost for S[t] # 为S[t]添加了缺货成本\n        total_hiring_cost + total_firing_cost)\n\n    m.setObjective(total_revenue - total_costs, GRB.MAXIMIZE)\n\n    # --- Constraints ---\n    # --- 约束条件 ---\n    for t in months:\n        # 1. Worker Balance Constraint\n        # 1. 工人数量平衡约束\n        if t == 0:\n            m.addConstr(W[t] == initial_workers + H[t] - F[t],\n                        name=f\"WorkerBalance_Month{t}\")\n        else:\n            m.addConstr(W[t] == W[t - 1] + H[t] - F[t],\n                        name=f\"WorkerBalance_Month{t}\")\n\n        # 2. Production Labor Hours Constraint\n        # 2. 生产工时约束\n        m.addConstr(P[t] * labor_hours_per_unit\n                    <= (W[t] * normal_hours_per_worker_per_month) +\n                    OT_total[t],\n                    name=f\"ProductionCapacity_Month{t}\")\n\n        # 3. Overtime Limit Constraint\n        # 3. 加班上限约束\n        m.addConstr(OT_total[t]\n                    <= W[t] * max_overtime_hours_per_worker_per_month,\n                    name=f\"OvertimeLimit_Month{t}\")\n\n        # 4. Inventory Balance Constraint (Revised)\n        # 4. 库存平衡约束 (修订版)\n        # Inv[t] = Previous_Inv + P[t] + Outsource[t] - (Demand[t] - S[t])\n        # This means: Ending_Inv + Sold_Units = Starting_Inv + Produced_Units + Outsourced_Units\n        # 这意味着: 期末库存 + 销售数量 = 期初库存 + 生产数量 + 外包数量\n        sold_units_t = demand_forecast[t] - S[t]\n        if t == 0:\n            m.addConstr(Inv[t] == initial_inventory + P[t] + Outsource[t] -\n                        sold_units_t,\n                        name=f\"InventoryBalance_Month{t}\")\n        else:\n            m.addConstr(Inv[t] == Inv[t - 1] + P[t] + Outsource[t] -\n                        sold_units_t,\n                        name=f\"InventoryBalance_Month{t}\")\n\n        # 5. Stockout (Unmet Demand) Definition Constraints (Linearized max function)\n        # 5. 缺货 (未满足需求) 定义约束 (线性化的max函数)\n        # S[t] >= Demand[t] - Previous_Inv - P[t] - Outsource[t]\n        # S[t] >= 0 (handled by lb=0 on variable S) (通过变量S的lb=0处理)\n        if t == 0:\n            m.addConstr(S[t] >= demand_forecast[t] - initial_inventory - P[t] -\n                        Outsource[t],\n                        name=f\"StockoutDef_Month{t}\")\n        else:\n            m.addConstr(S[t] >= demand_forecast[t] - Inv[t - 1] - P[t] -\n                        Outsource[t],\n                        name=f\"StockoutDef_Month{t}\")\n\n    # 6. Minimum Ending Inventory Constraint (for June - month 5)\n    # 6. 最低期末库存约束 (六月份 - 月份5)\n    m.addConstr(Inv[months[-1]] >= min_ending_inventory_june,\n                name=\"MinEndingInventory\")\n\n    # --- Solve Model ---\n    # --- 求解模型 ---\n    m.optimize()\n\n    # --- Print Results ---\n    # --- 打印结果 ---\n    if m.status == GRB.OPTIMAL:\n        print(\n            f\"\\nOptimal Solution Found. Total Net Profit: {m.objVal:,.2f} Yuan\"\n        )\n        print(\"-\" * 60)\n        print(\"Monthly Plan:\")\n        print(\"-\" * 60)\n        header = (\n            f\"{'Month':<10} | {'Demand':>8} | {'Sold':>8} | {'Unmet (S)':>9} | {'Workers':>7} | {'Hired':>6} | {'Fired':>6} | \"\n            f\"{'Production':>10} | {'Outsourced':>10} | {'OvertimeH':>10} | {'Avg OT/W':>8} | {'End Inv':>10}\"\n        )\n        print(header)\n        print(\"=\" * len(header))\n\n        total_prod = 0\n        total_outs = 0\n        total_hired = 0\n        total_fired = 0\n        total_ot = 0\n        total_unmet_s = 0\n        total_sold = 0\n\n        for t in months:\n            workers_t = W[t].X\n            avg_ot_per_worker = (OT_total[t].X /\n                                 workers_t) if workers_t > 0 else 0\n            sold_t = demand_forecast[t] - S[t].X\n            total_sold += sold_t\n            total_unmet_s += S[t].X\n            print(\n                f\"{month_names[t]:<10} | {demand_forecast[t]:>8,.0f} | {sold_t:>8,.0f} | {S[t].X:>9,.2f} | \"\n                f\"{workers_t:>7,.0f} | {H[t].X:>6,.0f} | {F[t].X:>6,.0f} | \"\n                f\"{P[t].X:>10,.2f} | {Outsource[t].X:>10,.2f} | {OT_total[t].X:>10,.2f} | \"\n                f\"{avg_ot_per_worker:>8,.2f} | {Inv[t].X:>10,.2f}\")\n            total_prod += P[t].X\n            total_outs += Outsource[t].X\n            total_hired += H[t].X\n            total_fired += F[t].X\n            total_ot += OT_total[t].X\n\n        print(\"=\" * len(header))\n        print(\"Summary over 6 months:\")\n        print(f\"Total Demand: {sum(demand_forecast.values()):,.0f} units\")\n        print(f\"Total Sold: {total_sold:,.0f} units\")\n        print(f\"Total Unmet Demand (S): {total_unmet_s:,.2f} units\")\n        print(f\"Total Production: {total_prod:,.2f} units\")\n        print(f\"Total Outsourced: {total_outs:,.2f} units\")\n        print(f\"Total Hired: {total_hired:,.0f} workers\")\n        print(f\"Total Fired: {total_fired:,.0f} workers\")\n        print(f\"Total Overtime Hours: {total_ot:,.2f} hours\")\n        print(\n            f\"Ending Inventory (June): {Inv[months[-1]].X:,.2f} units (Min required: {min_ending_inventory_june:,})\"\n        )\n        print(\"-\" * 60)\n\n        # Recalculate costs and revenue for verification\n        # 重新计算成本和收入以进行验证\n        calc_revenue = sum(\n            (demand_forecast[t] - S[t].X) * selling_price_per_unit\n            for t in months)\n        calc_rm_cost = sum(P[t].X * raw_material_cost_per_unit for t in months)\n        calc_reg_labor_cost = sum(W[t].X * normal_hours_per_worker_per_month *\n                                  regular_hourly_wage for t in months)\n        calc_ot_labor_cost = sum(OT_total[t].X * overtime_hourly_wage\n                                 for t in months)\n        calc_inv_cost = sum(Inv[t].X * inventory_cost_per_unit_per_month\n                            for t in months)\n        calc_outs_cost = sum(Outsource[t].X * outsourcing_cost_per_unit\n                             for t in months)\n        calc_stockout_unmet_cost = sum(S[t].X * stockout_penalty_per_unmet_unit\n                                       for t in months)\n        calc_hir_cost = sum(H[t].X * hiring_cost_per_worker for t in months)\n        calc_fir_cost = sum(F[t].X * firing_cost_per_worker for t in months)\n        calc_total_costs = calc_rm_cost + calc_reg_labor_cost + calc_ot_labor_cost + calc_inv_cost + calc_outs_cost + calc_stockout_unmet_cost + calc_hir_cost + calc_fir_cost\n\n        print(\n            \"\\nBreakdown of Total Revenue and Costs (Calculated from solution):\"\n        )\n        print(f\"  Total Revenue (from sold units): {calc_revenue:,.2f} Yuan\")\n        print(f\"  Total Raw Material Cost: {calc_rm_cost:,.2f} Yuan\")\n        print(f\"  Total Regular Labor Cost: {calc_reg_labor_cost:,.2f} Yuan\")\n        print(f\"  Total Overtime Labor Cost: {calc_ot_labor_cost:,.2f} Yuan\")\n        print(f\"  Total Inventory Cost: {calc_inv_cost:,.2f} Yuan\")\n        print(f\"  Total Outsourcing Cost (base): {calc_outs_cost:,.2f} Yuan\")\n        print(\n            f\"  Total Stockout Unmet Cost (for S>0): {calc_stockout_unmet_cost:,.2f} Yuan\"\n        )\n        print(f\"  Total Hiring Cost: {calc_hir_cost:,.2f} Yuan\")\n        print(f\"  Total Firing Cost: {calc_fir_cost:,.2f} Yuan\")\n        print(f\"  Calculated Total Costs: {calc_total_costs:,.2f} Yuan\")\n        print(\n            f\"  Calculated Net Profit (Revenue - Costs): {calc_revenue - calc_total_costs:,.2f} Yuan (Should match Gurobi's m.objVal)\"\n        )\n\n    elif m.status == GRB.INFEASIBLE:\n        print(\"Model is infeasible. Check constraints.\")  # 模型不可行，请检查约束\n        m.computeIIS()\n        m.write(\"model_revised_iis.ilp\")\n        print(\"IIS written to model_revised_iis.ilp\"\n              )  # IIS已写入model_revised_iis.ilp\n    elif m.status == GRB.UNBOUNDED:\n        print(\"Model is unbounded.\")  # 模型无界\n    else:\n        print(\n            f\"Optimization was stopped with status {m.status}\")  # 优化已停止，状态为...\n\n\nif __name__ == '__main__':\n    solve_production_planning_revised()",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Production Planning",
        "modeling_type": "MILP",
        "industry_sector": "Manufacturing",
        "reason": "The problem involves determining production quantities, workforce levels (hiring/firing), and inventory over multiple periods to maximize profit, which is a classic production planning problem. The solver uses integer variables for production, workers, hiring, firing, inventory, outsourcing, and stockout, along with linear constraints and objective, making it a Mixed-Integer Linear Program."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "B063",
    "description": "A company needs to decide whether to hire some of the five candidates to join their R&D team. The salary requirements for candidates F, G, H, I, and J are $12,000, $15,000, $18,000, $5,000, and $10,000 respectively. The company wants to minimize the total amount paid to candidates without exceeding the budget.\n\nThe company's budget is $40,000 and they wish to hire a maximum of 4 new employees.\n\nThe skill levels of the candidates are as follows:\nCandidate F: Level 2\nCandidate G: Level 3\nCandidate H: Level 4\nCandidate I: Level 1\nCandidate J: Level 2\n\nThe company needs to ensure that the total skill level of the hired employees is at least 8.\n\nThe project management experience years of each candidate are as follows:\nCandidate F: 1 year\nCandidate G: 2 years\nCandidate H: 2 years\nCandidate I: 5 years\nCandidate J: 4 years\n\nThey hope the total project management experience of the team is at least 8 years.\n\nDue to the similar technical background of candidates G and J, the company can choose at most one of them.",
    "ground_truth": 38000.0,
    "formulation": null,
    "correct_program": "def optimize_candidate_selection(salaries={\n    'F': 12000,\n    'G': 15000,\n    'H': 18000,\n    'I': 5000,\n    'J': 10000\n},\n                                 skills={\n                                     'F': 2,\n                                     'G': 3,\n                                     'H': 4,\n                                     'I': 1,\n                                     'J': 2\n                                 },\n                                 experiences={\n                                     'F': 1,\n                                     'G': 2,\n                                     'H': 2,\n                                     'I': 5,\n                                     'J': 4\n                                 },\n                                 budget=40000,\n                                 max_candidates=4,\n                                 min_skill=8,\n                                 min_experience=8):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Initialize model\n    model = gp.Model(\"Candidate_Selection\")\n\n    # Decision variables\n    candidates = ['F', 'G', 'H', 'I', 'J']\n    y = model.addVars(candidates, vtype=GRB.BINARY, name='hire')\n\n    # Objective: Minimize total salary\n    model.setObjective(gp.quicksum(salaries[c] * y[c] for c in candidates),\n                       GRB.MINIMIZE)\n\n    # Budget constraint\n    model.addConstr(gp.quicksum(salaries[c] * y[c] for c in candidates)\n                    <= budget,\n                    name='Budget')\n\n    # Team size constraint\n    model.addConstr(gp.quicksum(y[c] for c in candidates) <= max_candidates,\n                    name='MaxTeamSize')\n\n    # Skill level constraint\n    model.addConstr(gp.quicksum(skills[c] * y[c] for c in candidates)\n                    >= min_skill,\n                    name='SkillLevel')\n\n    # Experience constraint\n    model.addConstr(gp.quicksum(experiences[c] * y[c] for c in candidates)\n                    >= min_experience,\n                    name='Experience')\n\n    # Mutual exclusivity of G and J\n    model.addConstr(y['G'] + y['J'] <= 1, name='G_J_Exclusion')\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        total_salary = model.objVal\n        return total_salary\n    else:\n        return None\n    \nif __name__ == \"__main__\":\n    result = optimize_candidate_selection()\n    if result is not None:\n        print(f\"Optimal total salary: {result}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Selection",
        "modeling_type": "MILP",
        "industry_sector": "Human Resources",
        "reason": "The problem involves selecting a subset of candidates based on various criteria and constraints, which is a classic selection problem. The use of binary decision variables and linear constraints with a linear objective function indicates a Mixed-Integer Linear Programming (MILP) model. The application is directly related to hiring decisions within a company, falling under Human Resources."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "B050",
    "description": "The number of nurses required in each time period over 24 hours at a certain hospital is as follows: 2:00-6:00 - 10 people, 6:00-10:00 - 15 people, 10:00-14:00 - 25 people, 14:00-18:00 - 20 people, 18:00-22:00 - 18 people, 22:00-2:00 - 12 people. Nurses start shifts in 6 batches at 2:00, 6:00, 10:00, 14:00, 18:00, and 22:00 and work continuously for 8 hours. Please determine: If the hospital can hire contract nurses with the same working hours as regular nurses, and if the pay for regular nurses is 10 yuan/hour and for contract nurses is 15 yuan/hour, should the hospital hire contract nurses and if so, how many?",
    "ground_truth": 4240.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_nurse_staffing_with_contract():\n    \"\"\"\n    Solves the nurse staffing problem with regular and contract nurses\n    to minimize total daily wage costs.\n    \"\"\"\n    try:\n        # Create a new model\n        model = gp.Model(\"NurseStaffingContract\")\n\n        # --- Data ---\n        # Demands for each 4-hour period (0 to 5)\n        # P0: 2:00-6:00, P1: 6:00-10:00, ..., P5: 22:00-2:00\n        demands = {\n            0: 10,  # 2:00 - 6:00\n            1: 15,  # 6:00 - 10:00\n            2: 25,  # 10:00 - 14:00\n            3: 20,  # 14:00 - 18:00\n            4: 18,  # 18:00 - 22:00\n            5: 12  # 22:00 - 2:00 (next day)\n        }\n        num_periods = len(demands)  # Should be 6\n\n        # Shift start times (represented by an index for variables)\n        # t=0 starts at 2:00, t=1 at 6:00, ..., t=5 at 22:00\n        shift_start_times_desc = [\n            \"2:00\", \"6:00\", \"10:00\", \"14:00\", \"18:00\", \"22:00\"\n        ]\n\n        # Costs\n        cost_regular_nurse_shift = 10 * 8  # 10 yuan/hour * 8 hours\n        cost_contract_nurse_shift = 15 * 8  # 15 yuan/hour * 8 hours\n\n        # --- Decision Variables ---\n        # xR[t]: number of regular nurses starting shift at time t\n        xR = model.addVars(num_periods, vtype=GRB.INTEGER, name=\"xR\", lb=0)\n        # xC[t]: number of contract nurses starting shift at time t\n        xC = model.addVars(num_periods, vtype=GRB.INTEGER, name=\"xC\", lb=0)\n\n        # --- Objective Function ---\n        # Minimize the total daily wage cost\n        total_cost = gp.quicksum(cost_regular_nurse_shift * xR[t] +\n                                 cost_contract_nurse_shift * xC[t]\n                                 for t in range(num_periods))\n        model.setObjective(total_cost, GRB.MINIMIZE)\n\n        # --- Constraints ---\n        # Demand coverage for each period.\n        # Each nurse works for 8 hours, covering two 4-hour periods.\n\n        # Period 0 (2:00-6:00): Covered by staff starting at 22:00 (t=5) and 2:00 (t=0)\n        model.addConstr((xR[5] + xC[5]) + (xR[0] + xC[0]) >= demands[0],\n                        \"Demand_P0\")\n\n        # Period 1 (6:00-10:00): Covered by staff starting at 2:00 (t=0) and 6:00 (t=1)\n        model.addConstr((xR[0] + xC[0]) + (xR[1] + xC[1]) >= demands[1],\n                        \"Demand_P1\")\n\n        # Period 2 (10:00-14:00): Covered by staff starting at 6:00 (t=1) and 10:00 (t=2)\n        model.addConstr((xR[1] + xC[1]) + (xR[2] + xC[2]) >= demands[2],\n                        \"Demand_P2\")\n\n        # Period 3 (14:00-18:00): Covered by staff starting at 10:00 (t=2) and 14:00 (t=3)\n        model.addConstr((xR[2] + xC[2]) + (xR[3] + xC[3]) >= demands[3],\n                        \"Demand_P3\")\n\n        # Period 4 (18:00-22:00): Covered by staff starting at 14:00 (t=3) and 18:00 (t=4)\n        model.addConstr((xR[3] + xC[3]) + (xR[4] + xC[4]) >= demands[4],\n                        \"Demand_P4\")\n\n        # Period 5 (22:00-2:00): Covered by staff starting at 18:00 (t=4) and 22:00 (t=5)\n        model.addConstr((xR[4] + xC[4]) + (xR[5] + xC[5]) >= demands[5],\n                        \"Demand_P5\")\n\n        # Suppress Gurobi output to console\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal staffing plan found.\")\n            print(f\"Minimum Total Daily Wage Cost: {model.objVal:.2f} Yuan\")\n\n            total_regular_nurses = sum(xR[t].X for t in range(num_periods))\n            total_contract_nurses = sum(xC[t].X for t in range(num_periods))\n\n            print(\n                f\"\\nTotal Regular Nurses to Hire: {total_regular_nurses:.0f}\")\n            print(\n                f\"Total Contract Nurses to Hire: {total_contract_nurses:.0f}\")\n\n            if total_contract_nurses > 0:\n                print(\"\\nDecision: The hospital SHOULD hire contract nurses.\")\n            else:\n                print(\n                    \"\\nDecision: The hospital does NOT need to hire contract nurses based on cost minimization.\"\n                )\n\n            print(\"\\nNumber of Nurses Starting at Each Shift:\")\n            print(f\"{'Start Time':<12} | {'Regular':<10} | {'Contract':<10}\")\n            print(\"-\" * 40)\n            for t in range(num_periods):\n                print(\n                    f\"{shift_start_times_desc[t]:<12} | {xR[t].X:<10.0f} | {xC[t].X:<10.0f}\"\n                )\n\n            print(\"\\nVerification of Coverage per Period:\")\n            coverage = [0] * num_periods\n            coverage[0] = (xR[5].X + xC[5].X) + (xR[0].X + xC[0].X)\n            coverage[1] = (xR[0].X + xC[0].X) + (xR[1].X + xC[1].X)\n            coverage[2] = (xR[1].X + xC[1].X) + (xR[2].X + xC[2].X)\n            coverage[3] = (xR[2].X + xC[2].X) + (xR[3].X + xC[3].X)\n            coverage[4] = (xR[3].X + xC[3].X) + (xR[4].X + xC[4].X)\n            coverage[5] = (xR[4].X + xC[4].X) + (xR[5].X + xC[5].X)\n\n            period_desc = [\n                \"2:00-6:00\", \"6:00-10:00\", \"10:00-14:00\", \"14:00-18:00\",\n                \"18:00-22:00\", \"22:00-2:00\"\n            ]\n            for p in range(num_periods):\n                print(\n                    f\"  Period {period_desc[p]} (Demand: {demands[p]}): Covered by {coverage[p]:.0f} nurses\"\n                )\n\n        else:\n            print(\"No optimal solution found. Status code:\", model.status)\n\n    except gp.GurobiError as e:\n        print(f\"Error code {e.errno}: {e}\")\n    except AttributeError:\n        print(\n            \"Encountered an attribute error, Gurobi might not be installed or licensed correctly.\"\n        )\n\n\nif __name__ == '__main__':\n    solve_nurse_staffing_with_contract()",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Scheduling",
        "modeling_type": "MILP",
        "industry_sector": "Health",
        "reason": "The problem involves determining the optimal number of nurses to start shifts at different times to meet demand, which is a classic scheduling problem. The model uses integer variables for the number of nurses and linear constraints, making it a Mixed-Integer Linear Program. The application is clearly within a hospital setting, hence 'Health'."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "B036",
    "description": "A factory produces two types of microcomputers, A and B. Each type of microcomputer requires the same two production processes. The processing time, profit from sales, and the maximum weekly processing capacity for each type are shown in Table 3.1.\n\nTable 3.1\n\n| Process | Model |  | Maximum Weekly Processing Capacity |\n| :---: | :---: | :---: | :---: |\n|  | $\\\\mathrm{A}$ | $\\\\mathrm{B}$ |  |\n| I (hours / unit) | 4 | 6 | 150 |\n| II (hours / unit) | 3 | 2 | 70 |\n| Profit ($ per unit) | 300 | 450 |  |\n\nThe expected values for the factory's operational goals are as follows:\n\n$p_{1}$: The total weekly profit must not be less than $10,000.\n\n$p_{2}$: Due to contractual requirements, at least 10 units of Model A and at least 15 units of Model B must be produced per week.\n\n$p_{3}$: The weekly production time for Process I should be exactly 150 hours, and the production time for Process II should be fully utilized, with potential overtime if necessary.\n\nTry to establish the mathematical programming model for this problem.",
    "ground_truth": 11250.0,
    "formulation": null,
    "correct_program": "def optimize_microcomputers():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"Microcomputers_Production\")\n\n    # Decision variables\n    x_A = m.addVar(name=\"x_A\", lb=10, ub=150)  # at least 10, at most 150\n    x_B = m.addVar(name=\"x_B\", lb=15, ub=70)  # at least 15, at most 70\n\n    # Set the objective: maximize profit\n    m.setObjective(300 * x_A + 450 * x_B, GRB.MAXIMIZE)\n\n    # Add constraints\n    # Process I: exactly 150 hours\n    m.addConstr(4 * x_A + 6 * x_B == 150, name=\"Process_I\")\n    # Process II: exactly 70 hours\n    m.addConstr(3 * x_A + 2 * x_B == 70, name=\"Process_II\")\n    # Profit constraint: at least $10,000\n    m.addConstr(300 * x_A + 450 * x_B >= 10000, name=\"Profit_minimum\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        return m.objVal\n    else:\n        return None\nif __name__ == \"__main__\":\n    result = optimize_microcomputers()\n    if result is not None:\n        print(f\"Optimal total profit: {result}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Production Planning",
        "modeling_type": "LP",
        "industry_sector": "Manufacturing",
        "reason": "The problem involves determining the optimal production quantities of two microcomputer models to maximize profit, subject to resource capacity and demand constraints, which is a classic production planning scenario. The model uses linear objective and constraints with continuous variables, fitting the Linear Programming (LP) paradigm. The context of producing microcomputers in a factory clearly places it within the manufacturing sector."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "B085",
    "description": "Healthy Pet Foods Company produces two types of dog food: Meaties and Yummies. Each pack of Meaties contains 2 pounds of grains and 3 pounds of meat; each pack of Yummies contains 3 pounds of grains and 1.5 pounds of meat. The company believes it can sell any quantity of dog food that it can produce. Meaties sell for $2.80 per pack, and Yummies sell for $2.00 per pack. The company's production is subject to several constraints. First, a maximum of 400,000 pounds of grains can be purchased each month at a price of $0.20 per pound of grains. A maximum of 300,000 pounds of meat can be purchased each month at a price of $0.50 per pound of meat. Additionally, a special machine is required to produce Meaties, with a monthly capacity of 90,000 packs. The variable costs for mixing and packaging dog food are $0.25 per pack (Meaties) and $0.20 per pack (Yummies). Detailed information is provided in Table B-1.\n\n**Table B-1 Healthy Pet Foods Data**\n\n|                    | Meaties      | Yummies    |\n|--------------------|--------------|------------|\n| Price per pack     | $2.80        | $2.00      |\n| Raw materials      |              |            |\n| - Grains           | 2.0 lbs      | 3.0 lbs    |\n| - Meat             | 3.0 lbs      | 1.5 lbs    |\n| Variable cost      | $0.25/pack   | $0.20/pack |\n| Resources          |              |            |\n| Meaties capacity   | 90,000 packs/month |       |\n| Monthly available grains | 400,000 lbs |      |\n| Monthly available meat | 300,000 lbs |        |\n\nAssume you are the manager of the dog food department at Healthy Pet Foods Company. Your salary is based on the department's profit, so you will try to maximize profit. How should you operate the department to maximize both the profit and your salary?",
    "ground_truth": 77500.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_healthy_pet_foods():\n    \"\"\"\n    Solves the production planning problem for Healthy Pet Foods\n    to maximize monthly profit.\n    \"\"\"\n    try:\n        # --- Parameters ---\n        products = ['Meaties', 'Yummies']\n\n        # Selling Price ($/pack)\n        selling_price = {'Meaties': 2.80, 'Yummies': 2.00}\n\n        # Raw Material Requirements (lbs/pack)\n        grains_req = {'Meaties': 2.0, 'Yummies': 3.0}\n        meat_req = {'Meaties': 3.0, 'Yummies': 1.5}\n\n        # Variable Costs ($/pack) - Mixing and Packaging\n        variable_cost = {'Meaties': 0.25, 'Yummies': 0.20}\n\n        # Raw Material Costs ($/lb)\n        cost_grains = 0.20\n        cost_meat = 0.50\n\n        # Resource Availability (per month)\n        max_grains = 400000  # lbs\n        max_meat = 300000  # lbs\n        max_meaties_capacity = 90000  # packs\n\n        # --- Calculate Profit per Pack ---\n        # Profit = Selling Price - Grain Cost - Meat Cost - Variable Cost\n        profit_per_pack = {}\n        for p in products:\n            cost_of_grains = grains_req[p] * cost_grains\n            cost_of_meat = meat_req[p] * cost_meat\n            profit_per_pack[p] = selling_price[\n                p] - cost_of_grains - cost_of_meat - variable_cost[p]\n            # print(f\"Calculated profit for {p}: ${profit_per_pack[p]:.2f}\") # For verification\n\n        # --- Create Gurobi Model ---\n        model = gp.Model(\"HealthyPetFoodsProfit\")\n\n        # --- Decision Variables ---\n        # Produce[p]: Number of packs of product p produced per month\n        Produce = model.addVars(products,\n                                name=\"Produce\",\n                                vtype=GRB.CONTINUOUS,\n                                lb=0)\n\n        # --- Objective Function: Maximize Total Profit ---\n        model.setObjective(\n            gp.quicksum(profit_per_pack[p] * Produce[p] for p in products),\n            GRB.MAXIMIZE)\n\n        # --- Constraints ---\n        # 1. Grain Availability Constraint\n        model.addConstr(gp.quicksum(grains_req[p] * Produce[p]\n                                    for p in products) <= max_grains,\n                        name=\"GrainLimit\")\n\n        # 2. Meat Availability Constraint\n        model.addConstr(gp.quicksum(meat_req[p] * Produce[p] for p in products)\n                        <= max_meat,\n                        name=\"MeatLimit\")\n\n        # 3. Meaties Production Capacity Constraint\n        model.addConstr(Produce['Meaties'] <= max_meaties_capacity,\n                        name=\"MeatiesCapacity\")\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal production plan found.\")\n            print(f\"Maximum Monthly Profit: ${model.ObjVal:.2f}\")\n\n            print(\"\\nOptimal Production Quantities (packs per month):\")\n            for p in products:\n                print(f\"  {p}: {Produce[p].X:.2f} packs\")\n\n            print(\"\\nResource Utilization:\")\n            grains_used = sum(grains_req[p] * Produce[p].X for p in products)\n            meat_used = sum(meat_req[p] * Produce[p].X for p in products)\n            meaties_produced = Produce['Meaties'].X\n\n            print(\n                f\"  Grains Used: {grains_used:.2f} / {max_grains} lbs \"\n                f\"({(grains_used/max_grains*100) if max_grains > 0 else 0:.1f}%)\"\n            )\n            print(f\"  Meat Used: {meat_used:.2f} / {max_meat} lbs \"\n                  f\"({(meat_used/max_meat*100) if max_meat > 0 else 0:.1f}%)\")\n            print(\n                f\"  Meaties Production: {meaties_produced:.2f} / {max_meaties_capacity} packs \"\n                f\"({(meaties_produced/max_meaties_capacity*100) if max_meaties_capacity > 0 else 0:.1f}%)\"\n            )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\"Model is infeasible. Check constraints and data.\")\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            # model.computeIIS()\n            # model.write(\"healthy_pet_foods_iis.ilp\")\n            # print(\"IIS written to healthy_pet_foods_iis.ilp.\")\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n            if model.SolCount == 0:\n                print(\"No feasible solution found.\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_healthy_pet_foods()",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Production Planning",
        "modeling_type": "LP",
        "industry_sector": "Manufacturing",
        "reason": "The task involves determining optimal production quantities of dog food types to maximize profit, subject to resource constraints (grains, meat, machine capacity). This is a classic production planning problem. The solver uses continuous variables and linear objective/constraints, fitting the Linear Programming (LP) paradigm. The context of producing physical goods (dog food) places it squarely in the manufacturing sector."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "B054",
    "description": "A master's student in Operations Research at a certain university is required to select two courses in mathematics, two in operations research, and two in computer science from a total of seven courses: Calculus, Operations Research, Data Structures, Management Statistics, Computer Simulation, Computer Programming, and Forecasting. Some courses belong to only one category: Calculus falls under Mathematics, Computer Programming under Computer Science. However, some courses fall under multiple categories: Operations Research can be considered both Operations Research and Mathematics, Data Structures both Computer Science and Mathematics, Management Statistics both Mathematics and Operations Research, Computer Simulation both Computer Science and Operations Research, and Forecasting both Operations Research and Mathematics. Courses that fall under multiple categories can fulfill the requirement of both categories simultaneously. Additionally, some courses have prerequisites: Computer Simulation or Data Structures requires Computer Programming first, Management Statistics requires Calculus first, and Forecasting requires Management Statistics first. The question is: What is the minimum number of courses a master's student must take, and which specific courses, to meet the above requirements?",
    "ground_truth": 4.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_course_selection():\n    \"\"\"\n    Solves the course selection problem to minimize the number of courses taken\n    while satisfying category and prerequisite requirements.\n    \"\"\"\n    try:\n        # --- Data ---\n        courses = ['Calc', 'OR', 'DS', 'MS', 'Sim', 'Prog', 'Fcst']\n        categories = ['Math', 'OpRes', 'CompSci']\n\n        # Requirements per category\n        category_requirements = {'Math': 2, 'OpRes': 2, 'CompSci': 2}\n\n        # Course-to-category mapping: course_category[course][category] = 1 if belongs, else 0 or not present\n        course_category_map = {\n            'Calc': {\n                'Math': 1\n            },\n            'OR': {\n                'OpRes': 1,\n                'Math': 1\n            },\n            'DS': {\n                'CompSci': 1,\n                'Math': 1\n            },\n            'MS': {\n                'Math': 1,\n                'OpRes': 1\n            },\n            'Sim': {\n                'CompSci': 1,\n                'OpRes': 1\n            },\n            'Prog': {\n                'CompSci': 1\n            },\n            'Fcst': {\n                'OpRes': 1,\n                'Math': 1\n            }\n        }\n\n        # Prerequisites: prereqs[course_requiring_prereq] = [list_of_prereqs]\n        prerequisites = {\n            'Sim': ['Prog'],\n            'DS': ['Prog'],\n            'MS': ['Calc'],\n            'Fcst': ['MS']\n        }\n\n        # --- Create Gurobi Model ---\n        model = gp.Model(\"CourseSelectionOptimization\")\n\n        # --- Decision Variables ---\n        # x[c]: 1 if course c is selected, 0 otherwise\n        x = model.addVars(courses, vtype=GRB.BINARY, name=\"x\")\n\n        # --- Objective Function: Minimize the total number of courses selected ---\n        model.setObjective(gp.quicksum(x[c] for c in courses), GRB.MINIMIZE)\n\n        # --- Constraints ---\n        # 1. Category Requirements\n        for cat in categories:\n            model.addConstr(gp.quicksum(\n                x[c] * course_category_map[c].get(cat, 0) for c in courses)\n                            >= category_requirements[cat],\n                            name=f\"Req_{cat}\")\n\n        # 2. Prerequisite Constraints\n        # If x[course_with_prereq] = 1, then x[prereq_course] must be 1.\n        # So, x[course_with_prereq] <= x[prereq_course]\n        for course, prereq_list in prerequisites.items():\n            for prereq_course in prereq_list:\n                if course in x and prereq_course in x:  # Ensure both courses are valid keys\n                    model.addConstr(\n                        x[course] <= x[prereq_course],\n                        name=f\"Prereq_{prereq_course}_for_{course}\")\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal course selection found.\")\n            print(f\"Minimum number of courses to take: {model.ObjVal:.0f}\")\n\n            print(\"\\nSelected Courses:\")\n            selected_courses_list = []\n            for c in courses:\n                if x[c].X > 0.5:  # If x[c] is 1\n                    selected_courses_list.append(c)\n                    print(f\"  - {c}\")\n\n            print(\"\\nVerification of Category Requirements:\")\n            for cat in categories:\n                courses_for_cat = 0\n                cat_courses_taken = []\n                for c_taken in selected_courses_list:\n                    if course_category_map[c_taken].get(cat, 0) == 1:\n                        courses_for_cat += 1\n                        cat_courses_taken.append(c_taken)\n                print(\n                    f\"  Category '{cat}': Required={category_requirements[cat]}, Taken={courses_for_cat} ({', '.join(cat_courses_taken)})\"\n                )\n\n            print(\"\\nVerification of Prerequisites:\")\n            all_prereqs_met = True\n            for course_taken in selected_courses_list:\n                if course_taken in prerequisites:\n                    for prereq_c in prerequisites[course_taken]:\n                        if prereq_c not in selected_courses_list:\n                            print(\n                                f\"  ERROR: Course '{course_taken}' taken, but its prerequisite '{prereq_c}' is NOT taken.\"\n                            )\n                            all_prereqs_met = False\n            if all_prereqs_met:\n                print(\n                    \"  All prerequisite conditions are met for the selected courses.\"\n                )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\n                \"Model is infeasible. The requirements cannot be met with the given courses and constraints.\"\n            )\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            # model.computeIIS()\n            # model.write(\"course_selection_iis.ilp\")\n            # print(\"IIS written to course_selection_iis.ilp.\")\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_course_selection()",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Selection",
        "modeling_type": "MILP",
        "industry_sector": "Education",
        "reason": "The problem involves selecting a subset of courses to satisfy various requirements (category counts, prerequisites) while minimizing the total number of selected courses. The solver uses binary decision variables and linear constraints, making it a Mixed-Integer Linear Program (specifically, an Integer Program since all variables are binary)."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "B038",
    "description": "A company plans to transport goods between the city and the suburb and needs to choose the most environmentally friendly transportation method. The company can choose from the following three methods: motorcycle, small truck, and large truck. Each motorcycle trip produces 40 units of pollution, each small truck trip produces 70 units of pollution, and each large truck trip produces 100 units of pollution. The company's goal is to minimize total pollution.\n\nThe company can only choose two out of these three transportation methods.\n\nDue to certain road restrictions, the number of motorcycle trips cannot exceed 8.\n\nEach motorcycle trip can transport 10 units of products, each small truck trip can transport 20 units of products, and each large truck trip can transport 50 units of products. The company needs to transport at least 300 units of products.\n\nThe total number of trips must be less than or equal to 20.",
    "ground_truth": 600.0,
    "formulation": null,
    "correct_program": "def minimize_pollution(M=20):\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    model = Model(\"Minimize Pollution\")\n\n    # Decision variables\n    y_m = model.addVar(vtype=GRB.BINARY, name=\"motorcycle_method\")\n    y_s = model.addVar(vtype=GRB.BINARY, name=\"small_truck_method\")\n    y_l = model.addVar(vtype=GRB.BINARY, name=\"large_truck_method\")\n\n    x_m = model.addVar(vtype=GRB.INTEGER, lb=0, name=\"motorcycle_trips\")\n    x_s = model.addVar(vtype=GRB.INTEGER, lb=0, name=\"small_truck_trips\")\n    x_l = model.addVar(vtype=GRB.INTEGER, lb=0, name=\"large_truck_trips\")\n\n    # Set objective: minimize total pollution\n    model.setObjective(40 * x_m + 70 * x_s + 100 * x_l, GRB.MINIMIZE)\n\n    # Constraints\n    model.addConstr(y_m + y_s + y_l == 2, \"Method_Selection\")\n    model.addConstr(x_m <= 8, \"Motorcycle_Trip_Limit\")\n    model.addConstr(x_m <= M * y_m, \"Motorcycle_Method_Activation\")\n    model.addConstr(x_s <= M * y_s, \"SmallTruck_Method_Activation\")\n    model.addConstr(x_l <= M * y_l, \"LargeTruck_Method_Activation\")\n    model.addConstr(10 * x_m + 20 * x_s + 50 * x_l >= 300,\n                    \"Transport_Requirement\")\n    model.addConstr(x_m + x_s + x_l <= 20, \"Total_Trips_Limit\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        return model.objVal\n    else:\n        return None\nif __name__ == \"__main__\":\n    result = minimize_pollution()\n    if result is not None:\n        print(f\"Optimal total pollution: {result}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Transportation Planning",
        "modeling_type": "MILP",
        "industry_sector": "Logistics",
        "reason": "The problem involves selecting transportation methods and determining trip quantities to minimize pollution while meeting demand and capacity constraints, which falls under transportation planning. The use of both integer and binary variables, along with linear constraints and objective, indicates a Mixed-Integer Linear Programming (MILP) model. The application context of moving goods between locations for a company clearly places it in the logistics sector."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "B051",
    "description": "For a certain 24-hour bus service, the number of drivers and crew members required during different time periods each day is shown in Table 1-2:\nTable 1-2\n\\begin{tabular}{|c|c|c||c|c|c|}\n\\hline Shift & Time & Required number & Shift & Time & Required number \\\\\n\\hline 1 & $6: 00 \\sim 10: 00$ & 60 & 4 & $18 ; 00 \\sim 22 ; 00$ & 50 \\\\\n\\hline 2 & $10 ; 00 \\sim 14 ; 00$ & 70 & 5 & $22 ; 00 \\sim 2 ; 00$ & 20 \\\\\n\\hline 3 & $14 ; 00 \\sim 18 ; 00$ & 60 & 6 & $2: 00 \\sim 6 ; 00$ & 30 \\\\\n\\hline\n\\end{tabular}\n\nAssuming that drivers and crew members start their shifts at the beginning of each time period and work continuously for 8 hours, determine the minimum number of drivers and crew members needed for this bus route. Formulate the linear programming model for this problem.",
    "ground_truth": 150.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_bus_staffing():\n    \"\"\"\n    Solves the bus service staffing problem to minimize the total number of\n    drivers and crew members needed.\n    \"\"\"\n    try:\n        # Create a new model\n        model = gp.Model(\"BusStaffingOptimization\")\n\n        # --- Data ---\n        # Demands for each 4-hour period, re-ordered chronologically\n        # Period 0: 2:00-6:00 (Original Shift 6)\n        # Period 1: 6:00-10:00 (Original Shift 1)\n        # Period 2: 10:00-14:00 (Original Shift 2)\n        # Period 3: 14:00-18:00 (Original Shift 3)\n        # Period 4: 18:00-22:00 (Original Shift 4)\n        # Period 5: 22:00-2:00 (Original Shift 5)\n        demands = {\n            0: 30,  # 2:00 - 6:00\n            1: 60,  # 6:00 - 10:00\n            2: 70,  # 10:00 - 14:00\n            3: 60,  # 14:00 - 18:00\n            4: 50,  # 18:00 - 22:00\n            5: 20  # 22:00 - 2:00 (next day)\n        }\n        num_periods = len(demands)  # Should be 6\n\n        # Shift start times descriptions for output\n        shift_start_times_desc = [\n            \"2:00\", \"6:00\", \"10:00\", \"14:00\", \"18:00\", \"22:00\"\n        ]\n        period_desc = [\n            \"2:00-6:00\", \"6:00-10:00\", \"10:00-14:00\", \"14:00-18:00\",\n            \"18:00-22:00\", \"22:00-2:00\"\n        ]\n\n        # --- Decision Variables ---\n        # x[t]: number of staff starting their 8-hour shift at the beginning of period t\n        x = model.addVars(num_periods, vtype=GRB.INTEGER, name=\"x\", lb=0)\n\n        # --- Objective Function ---\n        # Minimize the total number of staff members hired\n        model.setObjective(gp.quicksum(x[t] for t in range(num_periods)),\n                           GRB.MINIMIZE)\n\n        # --- Constraints ---\n        # Demand coverage for each period.\n        # Each staff member works for 8 hours, covering two 4-hour periods.\n\n        # Period 0 (2:00-6:00): Covered by staff starting at 22:00 (x[5]) and 2:00 (x[0])\n        model.addConstr(x[5] + x[0] >= demands[0], \"Demand_P0\")\n\n        # Period 1 (6:00-10:00): Covered by staff starting at 2:00 (x[0]) and 6:00 (x[1])\n        model.addConstr(x[0] + x[1] >= demands[1], \"Demand_P1\")\n\n        # Period 2 (10:00-14:00): Covered by staff starting at 6:00 (x[1]) and 10:00 (x[2])\n        model.addConstr(x[1] + x[2] >= demands[2], \"Demand_P2\")\n\n        # Period 3 (14:00-18:00): Covered by staff starting at 10:00 (x[2]) and 14:00 (x[3])\n        model.addConstr(x[2] + x[3] >= demands[3], \"Demand_P3\")\n\n        # Period 4 (18:00-22:00): Covered by staff starting at 14:00 (x[3]) and 18:00 (x[4])\n        model.addConstr(x[3] + x[4] >= demands[4], \"Demand_P4\")\n\n        # Period 5 (22:00-2:00): Covered by staff starting at 18:00 (x[4]) and 22:00 (x[5])\n        model.addConstr(x[4] + x[5] >= demands[5], \"Demand_P5\")\n\n        # Suppress Gurobi output to console\n        model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal staffing plan found.\")\n            print(\n                f\"Minimum total staff (drivers and crew) needed: {model.objVal:.0f}\"\n            )\n\n            print(\"\\nNumber of Staff Starting at Each Shift:\")\n            print(f\"{'Start Time':<12} | {'Number of Staff':<15}\")\n            print(\"-\" * 30)\n            for t in range(num_periods):\n                print(f\"{shift_start_times_desc[t]:<12} | {x[t].X:<15.0f}\")\n\n            print(\"\\nVerification of Coverage per Period:\")\n            coverage = [0] * num_periods\n            coverage[0] = x[5].X + x[0].X\n            coverage[1] = x[0].X + x[1].X\n            coverage[2] = x[1].X + x[2].X\n            coverage[3] = x[2].X + x[3].X\n            coverage[4] = x[3].X + x[4].X\n            coverage[5] = x[4].X + x[5].X\n\n            for p_idx in range(num_periods):\n                print(\n                    f\"  Period {period_desc[p_idx]} (Demand: {demands[p_idx]}): Covered by {coverage[p_idx]:.0f} staff\"\n                )\n\n        else:\n            print(\"No optimal solution found. Status code:\", model.status)\n\n    except gp.GurobiError as e:\n        print(f\"Error code {e.errno}: {e}\")\n    except AttributeError:\n        print(\n            \"Encountered an attribute error, Gurobi might not be installed or licensed correctly.\"\n        )\n\n\nif __name__ == '__main__':\n    solve_bus_staffing()",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Staffing",
        "modeling_type": "IP",
        "industry_sector": "Transportation",
        "reason": "The problem aims to determine the minimum number of drivers and crew members required for a bus service, which is a classic staffing problem. The solver uses integer variables and linear constraints to minimize the total staff, fitting the Integer Programming (IP) modeling type. The application context is a bus service, placing it in the transportation sector."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "B098",
    "description": "An electronic system is composed of 3 types of components. The system operates normally if all three components function properly. By installing one or more spare parts for any of the components, the reliability of the components can be improved. The system's operational reliability is the product of the reliabilities of each component, and the reliability of each component is a function of the number of spare parts installed. The first half of the table below shows the function relationship between the number of spare parts and the reliability of a specific component. The prices and weights of the 3 types of components are shown in rows 8 to 9 of the table. Given that the total budget for all spare parts is limited to 150 yuan, and the weight limit is 20 kg, how should spare parts be installed to maximize the system's operational reliability? \n\n\\begin{table}[h]\n\\centering\n\\begin{tabular}{|c|c|c|c|}\n\\hline\n\\textbf{Component Number} & \\textbf{1} & \\textbf{2} & \\textbf{3} \\\\ \\hline\n\\textbf{Number of Spares} &             &             &             \\\\ \\hline\n0                & 0.5         & 0.6         & 0.7         \\\\ \\hline\n1                & 0.6         & 0.75        & 0.9         \\\\ \\hline\n2                & 0.7         & 0.95        & 1.0         \\\\ \\hline\n3                & 0.8         & 1.0         & 1.0         \\\\ \\hline\n4                & 0.9         & 1.0         & 1.0         \\\\ \\hline\n5                & 1.0         & 1.0         & 1.0         \\\\ \\hline\n\\textbf{Unit Price (yuan)}  & 20           & 30           & 40           \\\\ \\hline\n\\textbf{Unit Weight (kg)}  & 2            & 4            & 6            \\\\ \\hline\n\\end{tabular}\n\\caption{Spare Component Data Table}\n\\end{table}",
    "ground_truth": 0.6075,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\nimport math  # For math.exp in results if needed\n\n\ndef solve_system_reliability():\n    \"\"\"\n    Solves the system reliability optimization problem to determine the optimal\n    number of spare parts for each component to maximize overall system reliability,\n    subject to budget and weight constraints.\n    Uses a log-transformed objective for Gurobi.\n    \"\"\"\n    try:\n        # --- Data ---\n        num_components = 3\n        components = range(\n            num_components)  # Indices 0, 1, 2 for Components 1, 2, 3\n\n        max_spares_per_component = 5\n        num_spare_options = max_spares_per_component + 1\n        spare_counts_options = range(num_spare_options)\n\n        reliability_data = [\n            [0.5, 0.6, 0.7, 0.8, 0.9, 1.0],  # Component 1\n            [0.6, 0.75, 0.95, 1.0, 1.0, 1.0],  # Component 2\n            [0.7, 0.9, 1.0, 1.0, 1.0, 1.0]  # Component 3\n        ]\n\n        prices = [20, 30, 40]  # yuan\n        weights = [2, 4, 6]  # kg\n\n        max_budget = 150  # yuan\n        max_weight = 20  # kg\n\n        # --- Create Gurobi Model ---\n        model = gp.Model(\"SystemReliabilityOptimization\")\n\n        # --- Decision Variables ---\n        # x[c,s]: 1 if component c has s spares installed, 0 otherwise\n        x = model.addVars(components,\n                          spare_counts_options,\n                          vtype=GRB.BINARY,\n                          name=\"x_spares_selection\")\n\n        # Rel[c]: Achieved reliability of component c\n        # Ensure Rel[c] is strictly positive for log function. Smallest reliability is 0.5.\n        Rel = model.addVars(components,\n                            name=\"Rel_component\",\n                            lb=0.0001,\n                            ub=1.0,\n                            vtype=GRB.CONTINUOUS)\n\n        # log_Rel[c]: Natural logarithm of Rel[c]\n        # Gurobi's log is natural log. The bounds for log_Rel depend on Rel's bounds.\n        # log(0.0001) approx -9.21, log(1) = 0\n        log_Rel = model.addVars(components,\n                                name=\"log_Rel_component\",\n                                lb=-10,\n                                ub=0.0,\n                                vtype=GRB.CONTINUOUS)\n\n        # --- Objective Function: Maximize Sum of Log(Reliabilities) ---\n        # This is equivalent to maximizing the product of reliabilities.\n        # Gurobi needs NonConvex=2 for general constraints like log.\n        model.Params.NonConvex = 2\n        model.setObjective(gp.quicksum(log_Rel[c] for c in components),\n                           GRB.MAXIMIZE)\n\n        # --- Constraints ---\n        # 1. Unique Spare Count Selection: For each component c, exactly one x[c,s] is 1\n        for c in components:\n            model.addConstr(gp.quicksum(\n                x[c, s_option] for s_option in spare_counts_options) == 1,\n                            name=f\"UniqueSpares_Comp{c+1}\")\n\n        # 2. Component Reliability Definition: Rel[c] = sum(Reliability_data[c][s_option] * x[c,s_option])\n        for c in components:\n            model.addConstr(Rel[c] == gp.quicksum(\n                reliability_data[c][s_option] * x[c, s_option]\n                for s_option in spare_counts_options),\n                            name=f\"DefineRel_Comp{c+1}\")\n\n        # 3. Link Rel[c] and log_Rel[c]: log_Rel[c] = log(Rel[c])\n        for c in components:\n            model.addGenConstrLog(Rel[c],\n                                  log_Rel[c],\n                                  name=f\"LogConstraint_Comp{c+1}\")\n\n        # 4. Budget Constraint: sum_c sum_s (price[c] * s * x[c,s]) <= max_budget\n        total_cost = gp.quicksum(prices[c] * s_option * x[c, s_option]\n                                 for c in components\n                                 for s_option in spare_counts_options)\n        model.addConstr(total_cost <= max_budget, name=\"BudgetLimit\")\n\n        # 5. Weight Constraint: sum_c sum_s (weight[c] * s * x[c,s]) <= max_weight\n        total_weight = gp.quicksum(weights[c] * s_option * x[c, s_option]\n                                   for c in components\n                                   for s_option in spare_counts_options)\n        model.addConstr(total_weight <= max_weight, name=\"WeightLimit\")\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n        model.setParam('MIPGap', 0.001)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal spare parts installation plan found.\")\n            # Calculate the actual system reliability (product of individual reliabilities)\n            actual_system_reliability = 1.0\n            for c in components:\n                actual_system_reliability *= Rel[c].X\n\n            print(\n                f\"Maximum System Operational Reliability: {actual_system_reliability:.4f} (or {actual_system_reliability*100:.2f}%)\"\n            )\n            print(\n                f\"Objective Function Value (Sum of Log Reliabilities): {model.ObjVal:.4f}\"\n            )\n\n            print(\"\\nOptimal Number of Spare Parts for Each Component:\")\n            num_spares_chosen = {}\n            for c in components:\n                for s_option_val in spare_counts_options:\n                    if x[c, s_option_val].X > 0.5:\n                        num_spares_chosen[c] = s_option_val\n                        print(\n                            f\"  Component {c+1}: Install {s_option_val} spare part(s)\"\n                        )\n                        break\n\n            print(\"\\nAchieved Component Reliabilities:\")\n            for c in components:\n                print(\n                    f\"  Component {c+1}: {Rel[c].X:.4f} (Reliability with {num_spares_chosen[c]} spares, log(Rel): {log_Rel[c].X:.4f})\"\n                )\n\n            print(\"\\nResource Usage:\")\n            final_cost = sum(prices[c] * num_spares_chosen[c]\n                             for c in components)\n            final_weight = sum(weights[c] * num_spares_chosen[c]\n                               for c in components)\n            print(\n                f\"  Total Cost: {final_cost:.2f} Yuan (Budget: <= {max_budget})\"\n            )\n            print(\n                f\"  Total Weight: {final_weight:.2f} kg (Limit: <= {max_weight})\"\n            )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\n                \"Model is infeasible. The requirements cannot be met under the given budget and weight constraints.\"\n            )\n            model.computeIIS()\n            model.write(\"system_reliability_iis.ilp\")\n            print(\"IIS written to system_reliability_iis.ilp for debugging.\")\n        elif model.status == GRB.INF_OR_UNBD:\n            print(\"Model is infeasible or unbounded.\")\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n            if model.SolCount == 0:\n                print(\"No feasible solution found.\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n        print(f\"Error message: {e.message}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_system_reliability()",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "MILP",
        "industry_sector": "Manufacturing",
        "reason": "The problem involves allocating limited resources (budget and weight) to maximize system reliability by selecting the number of spare parts for each component. The solver uses a Mixed-Integer Linear Programming (MILP) approach by transforming the multiplicative objective into a sum of logarithms and using binary variables for selection, which is a common technique in reliability optimization. The application is directly related to the design and maintenance of electronic systems, which falls under manufacturing."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "B027",
    "description": "Someone has a fund of 300,000 yuan and has the following investment projects in the next three years:\n(1) Investment can be made at the beginning of each year within three years, with an annual profit of 20% of the investment amount, and the principal and interest can be used for investment in the following year;\n(2) Investment is only allowed at the beginning of the first year, and it can be recovered at the end of the second year, with the total principal and interest amounting to 150% of the investment amount, but the investment limit is no more than 150,000 yuan;\n(3) Investment is allowed at the beginning of the second year within three years, and it can be recovered at the end of the third year, with the total principal and interest amounting to 160% of the investment amount, and the investment limit is 200,000 yuan;\n(4) Investment is allowed at the beginning of the third year within three years, and it can be recovered in one year with a profit of 40%, and the investment limit is 100,000 yuan.\nChapter One: Linear Programming and Simplex Method\nTry to determine an investment plan for this person that maximizes the principal and interest at the end of the third year.",
    "ground_truth": 580000.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_investment_problem():\n    \"\"\"\n    Solves the multi-period investment problem using Gurobi to maximize\n    the total principal and interest at the end of the third year.\n    \"\"\"\n    try:\n        # Initial capital\n        K0 = 300000.0\n\n        # Create a new model\n        model = gp.Model(\"MultiPeriodInvestment\")\n\n        # --- Decision Variables ---\n        # x_ij: amount invested in project i at the start of year j\n        # Project 1: Annual, 20% profit (return 1.2)\n        x11 = model.addVar(name=\"x11_P1_Y1\", lb=0.0,\n                           vtype=GRB.CONTINUOUS)  # P1, Start of Year 1\n        x12 = model.addVar(name=\"x12_P1_Y2\", lb=0.0,\n                           vtype=GRB.CONTINUOUS)  # P1, Start of Year 2\n        x13 = model.addVar(name=\"x13_P1_Y3\", lb=0.0,\n                           vtype=GRB.CONTINUOUS)  # P1, Start of Year 3\n\n        # Project 2: Start Y1, 2-year, 150% total return (factor 1.5), limit 150k\n        x21 = model.addVar(name=\"x21_P2_Y1\", lb=0.0, vtype=GRB.CONTINUOUS)\n\n        # Project 3: Start Y2, 2-year, 160% total return (factor 1.6), limit 200k\n        x32 = model.addVar(name=\"x32_P3_Y2\", lb=0.0, vtype=GRB.CONTINUOUS)\n\n        # Project 4: Start Y3, 1-year, 40% profit (return 1.4), limit 100k\n        x43 = model.addVar(name=\"x43_P4_Y3\", lb=0.0, vtype=GRB.CONTINUOUS)\n\n        # --- Objective Function ---\n        # Maximize total principal and interest at the end of Year 3.\n        # Z = K0 + 0.2*x11 + 0.5*x21 + 0.2*x12 + 0.6*x32 + 0.2*x13 + 0.4*x43\n        objective = K0 + 0.2 * x11 + 0.5 * x21 + 0.2 * x12 + 0.6 * x32 + 0.2 * x13 + 0.4 * x43\n        model.setObjective(objective, GRB.MAXIMIZE)\n\n        # --- Constraints ---\n        # 1. Cash Availability at Start of Year 1\n        model.addConstr(x11 + x21 <= K0, \"Cash_SOY1\")\n\n        # 2. Cash Availability at Start of Year 2\n        # Investments_SOY2 <= K0 + 0.2*x11 - x21\n        # x12 + x32 - 0.2*x11 + x21 <= K0\n        model.addConstr(x12 + x32 - 0.2 * x11 + x21 <= K0, \"Cash_SOY2\")\n\n        # 3. Cash Availability at Start of Year 3\n        # Investments_SOY3 <= K0 + 0.2*x11 + 0.5*x21 + 0.2*x12 - x32\n        # x13 + x43 - 0.2*x11 - 0.5*x21 - 0.2*x12 + x32 <= K0\n        model.addConstr(\n            x13 + x43 - 0.2 * x11 - 0.5 * x21 - 0.2 * x12 + x32 <= K0,\n            \"Cash_SOY3\")\n\n        # 4. Investment Limit for Project 2\n        model.addConstr(x21 <= 150000, \"Limit_P2\")\n\n        # 5. Investment Limit for Project 3\n        model.addConstr(x32 <= 200000, \"Limit_P3\")\n\n        # 6. Investment Limit for Project 4\n        model.addConstr(x43 <= 100000, \"Limit_P4\")\n\n        # Suppress Gurobi output to console\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal investment plan found.\")\n            print(\n                f\"Maximum Principal and Interest at End of Year 3: {model.objVal:.2f} yuan\"\n            )\n\n            total_profit = model.objVal - K0\n            print(f\"Total Profit over 3 years: {total_profit:.2f} yuan\")\n\n            print(\"\\nInvestment Plan Details (yuan):\")\n            print(\"  Start of Year 1:\")\n            print(f\"    Project 1 (Annual, 20% profit): {x11.X:.2f}\")\n            print(\n                f\"    Project 2 (2-year, 150% return, limit 150k): {x21.X:.2f}\"\n            )\n            cash_soy1_invested = x11.X + x21.X\n            cash_soy1_uninvested = K0 - cash_soy1_invested\n            print(f\"    Total invested at SOY1: {cash_soy1_invested:.2f}\")\n            print(f\"    Uninvested cash from SOY1: {cash_soy1_uninvested:.2f}\")\n\n            cash_available_soy2 = K0 + 0.2 * x11.X - x21.X\n            print(\n                f\"\\n  Cash available at Start of Year 2: {cash_available_soy2:.2f}\"\n            )\n            print(\"  Start of Year 2:\")\n            print(f\"    Project 1 (Annual, 20% profit): {x12.X:.2f}\")\n            print(\n                f\"    Project 3 (2-year, 160% return, limit 200k): {x32.X:.2f}\"\n            )\n            cash_soy2_invested = x12.X + x32.X\n            cash_soy2_uninvested = cash_available_soy2 - cash_soy2_invested\n            print(f\"    Total invested at SOY2: {cash_soy2_invested:.2f}\")\n            print(f\"    Uninvested cash from SOY2: {cash_soy2_uninvested:.2f}\")\n\n            cash_available_soy3 = K0 + 0.2 * x11.X + 0.5 * x21.X + 0.2 * x12.X - x32.X\n            print(\n                f\"\\n  Cash available at Start of Year 3: {cash_available_soy3:.2f}\"\n            )\n            print(\"  Start of Year 3:\")\n            print(f\"    Project 1 (Annual, 20% profit): {x13.X:.2f}\")\n            print(\n                f\"    Project 4 (1-year, 40% profit, limit 100k): {x43.X:.2f}\")\n            cash_soy3_invested = x13.X + x43.X\n            cash_soy3_uninvested = cash_available_soy3 - cash_soy3_invested\n            print(f\"    Total invested at SOY3: {cash_soy3_invested:.2f}\")\n            print(\n                f\"    Uninvested cash from SOY3 (carried to EOY3): {cash_soy3_uninvested:.2f}\"\n            )\n\n        else:\n            print(\"No optimal solution found. Status code:\", model.status)\n\n    except gp.GurobiError as e:\n        print(f\"Error code {e.errno}: {e}\")\n    except AttributeError:\n        print(\n            \"Encountered an attribute error. Gurobi might not be installed or licensed correctly.\"\n        )\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_investment_problem()",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Resource Allocation",
        "modeling_type": "LP",
        "industry_sector": "Finance",
        "reason": "The problem involves allocating a limited fund across various investment projects over multiple time periods to maximize the total return, which is a classic resource allocation problem. The mathematical formulation consists of a linear objective function and linear constraints, with continuous decision variables, making it a Linear Program (LP). The context of managing investment funds and maximizing returns clearly places it within the finance sector."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "B024",
    "description": "An investor plans to invest 100,000 yuan, with two investment options to choose from. The first investment guarantees a return of 0.7 yuan for every 1 yuan invested after one year. The second investment guarantees a return of 2 yuan for every 1 yuan invested after two years, but the investment time must be in multiples of two years. In order to maximize the investor's earnings by the end of the third year, how should the investments be made? Formulate this as a linear programming problem.",
    "ground_truth": 510000.0,
    "formulation": null,
    "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_investment_problem():\n    \"\"\"\n    Solves the multi-period investment problem using Gurobi.\n    \"\"\"\n    try:\n        # Initial capital\n        K = 100000.0\n\n        # Create a new model\n        model = gp.Model(\"InvestmentStrategy\")\n\n        # --- Decision Variables ---\n        # x_ij: amount invested in option i at the start of year j (0-indexed for time)\n        # Option 1: 1-year term, 1 yuan becomes 1.7 yuan (0.7 profit)\n        # Option 2: 2-year term, 1 yuan becomes 3 yuan (2 profit)\n\n        # Investments at Start of Year 1 (Time 0)\n        x10 = model.addVar(name=\"x10\", lb=0.0,\n                           vtype=GRB.CONTINUOUS)  # Opt1, Year 1\n        x20 = model.addVar(name=\"x20\", lb=0.0,\n                           vtype=GRB.CONTINUOUS)  # Opt2, Year 1 (matures EOY2)\n\n        # Investments at Start of Year 2 (Time 1)\n        x11 = model.addVar(name=\"x11\", lb=0.0,\n                           vtype=GRB.CONTINUOUS)  # Opt1, Year 2\n        x21 = model.addVar(name=\"x21\", lb=0.0,\n                           vtype=GRB.CONTINUOUS)  # Opt2, Year 2 (matures EOY3)\n\n        # Investments at Start of Year 3 (Time 2)\n        x12 = model.addVar(name=\"x12\", lb=0.0,\n                           vtype=GRB.CONTINUOUS)  # Opt1, Year 3\n        # No x22 as Opt2 takes 2 years and goal is EOY3\n\n        # --- Objective Function ---\n        # Maximize total earnings by the end of year 3.\n        # Earnings = (Total value at EOY3) - K\n        # Total value = K + 0.7*x10 + 2*x20 + 0.7*x11 + 2*x21 + 0.7*x12\n        # Earnings = 0.7*x10 + 2*x20 + 0.7*x11 + 2*x21 + 0.7*x12\n        objective = 0.7 * x10 + 2.0 * x20 + 0.7 * x11 + 2.0 * x21 + 0.7 * x12\n        model.setObjective(objective, GRB.MAXIMIZE)\n\n        # --- Constraints ---\n        # Constraint 1: Cash availability at Start of Year 1 (Time 0)\n        model.addConstr(x10 + x20 <= K, \"Cash_Year1_Start\")\n\n        # Constraint 2: Cash availability at Start of Year 2 (Time 1)\n        # Money available = (K - x10 - x20) (uninvested T0) + 1.7*x10 (from x10 maturing)\n        # x11 + x21 <= K + 0.7*x10 - x20\n        model.addConstr(x11 + x21 - 0.7 * x10 + x20 <= K, \"Cash_Year2_Start\")\n\n        # Constraint 3: Cash availability at Start of Year 3 (Time 2)\n        # Money available at T2 = (Cash_Available_T1 - x11 - x21) (uninvested T1)\n        #                         + 1.7*x11 (from x11 maturing)\n        #                         + 3.0*x20 (from x20 maturing)\n        # Cash_Available_T1 = K + 0.7*x10 - x20\n        # Money available at T2 = (K + 0.7*x10 - x20 - x11 - x21) + 1.7*x11 + 3.0*x20\n        #                       = K + 0.7*x10 + 2.0*x20 + 0.7*x11 - x21\n        # x12 <= K + 0.7*x10 + 2.0*x20 + 0.7*x11 - x21\n        model.addConstr(x12 - 0.7 * x10 - 2.0 * x20 - 0.7 * x11 + x21 <= K,\n                        \"Cash_Year3_Start\")\n\n        # Suppress Gurobi output to console\n        model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal solution found.\")\n            print(f\"Maximum Earnings: {model.objVal:.2f} yuan\")\n            print(\"\\nInvestment Plan:\")\n            print(f\"  Start of Year 1 (Time 0):\")\n            print(f\"    Invest in Option 1 (x10): {x10.X:.2f} yuan\")\n            print(f\"    Invest in Option 2 (x20): {x20.X:.2f} yuan\")\n\n            available_t1 = K - x10.X - x20.X + 1.7 * x10.X\n            print(\n                f\"\\n  Cash available at Start of Year 2 (Time 1): {available_t1:.2f} yuan\"\n            )\n            print(f\"  Start of Year 2 (Time 1):\")\n            print(f\"    Invest in Option 1 (x11): {x11.X:.2f} yuan\")\n            print(f\"    Invest in Option 2 (x21): {x21.X:.2f} yuan\")\n\n            available_t2 = available_t1 - x11.X - x21.X + 1.7 * x11.X + 3.0 * x20.X\n            print(\n                f\"\\n  Cash available at Start of Year 3 (Time 2): {available_t2:.2f} yuan\"\n            )\n            print(f\"  Start of Year 3 (Time 2):\")\n            print(f\"    Invest in Option 1 (x12): {x12.X:.2f} yuan\")\n\n            total_value_eoy3 = K + model.objVal\n            print(\n                f\"\\nTotal value at End of Year 3: {total_value_eoy3:.2f} yuan\")\n\n        else:\n            print(\"No optimal solution found. Status code:\", model.status)\n\n    except gp.GurobiError as e:\n        print(f\"Error code {e.errno}: {e}\")\n    except AttributeError:\n        print(\n            \"Encountered an attribute error, Gurobi might not be installed or licensed correctly.\"\n        )\n\n\nif __name__ == '__main__':\n    solve_investment_problem()",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Portfolio Optimization",
        "modeling_type": "LP",
        "industry_sector": "Finance",
        "reason": "The problem involves allocating an initial capital across different investment options over multiple time periods to maximize total earnings, which is a classic portfolio optimization problem. The formulation uses linear objective and constraints with continuous variables, making it a Linear Program (LP)."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "B067",
    "description": "There are two coal yards A and B, each receiving no less than 80 tons and 100 tons of coal per month, respectively. They are responsible for supplying coal to three residential areas, which need 55 tons, 75 tons, and 50 tons of coal per month, respectively. Coal yard A is located 10 kilometers, 5 kilometers, and 6 kilometers from these three residential areas. Coal yard B is located 4 kilometers, 8 kilometers, and 15 kilometers from these three residential areas. How should these two coal yards distribute coal to the three residential areas to minimize the ton-kilometers of transportation?",
    "ground_truth": 1030.0,
    "formulation": null,
    "correct_program": "def optimize_coal_distribution(supply_A=80,\n                               supply_B=100,\n                               demand_1=55,\n                               demand_2=75,\n                               demand_3=50):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"Coal_Distribution_Minimize_TonKilometers\")\n\n    # Decision variables: amount of coal shipped from each yard to each area\n    x_A1 = model.addVar(lb=0, name=\"x_A1\")\n    x_A2 = model.addVar(lb=0, name=\"x_A2\")\n    x_A3 = model.addVar(lb=0, name=\"x_A3\")\n    x_B1 = model.addVar(lb=0, name=\"x_B1\")\n    x_B2 = model.addVar(lb=0, name=\"x_B2\")\n    x_B3 = model.addVar(lb=0, name=\"x_B3\")\n\n    # Set objective: minimize total ton-kilometers\n    model.setObjective(\n        10 * x_A1 + 5 * x_A2 + 6 * x_A3 + 4 * x_B1 + 8 * x_B2 + 15 * x_B3,\n        GRB.MINIMIZE)\n\n    # Supply constraints\n    model.addConstr(x_A1 + x_A2 + x_A3 >= supply_A, \"Supply_A\")\n    model.addConstr(x_B1 + x_B2 + x_B3 >= supply_B, \"Supply_B\")\n\n    # Demand constraints\n    model.addConstr(x_A1 + x_B1 == demand_1, \"Demand_1\")\n    model.addConstr(x_A2 + x_B2 == demand_2, \"Demand_2\")\n    model.addConstr(x_A3 + x_B3 == demand_3, \"Demand_3\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        return model.objVal\n    else:\n        return None\nif __name__ == \"__main__\":\n    result = optimize_coal_distribution()\n    if result is not None:\n        print(f\"Optimal total ton-kilometers: {result}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Transportation Problem",
        "modeling_type": "LP",
        "industry_sector": "Energy",
        "reason": "The problem involves minimizing transportation costs (ton-kilometers) for distributing coal from supply points to demand points, which is a classic transportation problem. The model uses linear decision variables and constraints, with a linear objective function, making it a Linear Program (LP). The application is related to coal distribution, which falls under the energy sector."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "B093",
    "description": "A company blends two types of crude oil (A and B) to produce two types of gasoline (Type I and Type II). The minimum proportion of crude oil A in gasoline Types I and II is 50% and 60%, respectively. The selling prices are 4800 yuan/t and 5600 yuan/t, respectively. The company has current inventories of 500 t of crude oil A and 1000 t of crude oil B, and they can purchase up to 1500 t of crude oil A from the market. The market price for crude oil A is: 10,000 yuan/t for purchases up to 500 t; 8,000 yuan/t for the portion exceeding 500 t but not exceeding 1000 t; 6,000 yuan/t for the portion exceeding 1000 t. How should the company plan its purchasing and processing of crude oil?",
    "ground_truth": 5000000.0,
    "formulation": null,
    "correct_program": "from gurobipy import Model, GRB, quicksum\n\n# 创建模型\nmodel = Model(\"Crude_Oil_Blending_Improved\")\n\n# ----------------------------\n# 参数设置\n# ----------------------------\nprice_I = 4800  # Type I 汽油售价\nprice_II = 5600  # Type II 汽油售价\n\ncost_A_segment1 = 10000  # 第一段成本（前500吨）\ncost_A_segment2 = 8000  # 第二段成本（500~1000吨）\ncost_A_segment3 = 6000  # 第三段成本（超过1000吨）\n\nmax_segment1 = 500  # 第一段最大购买量\nmax_segment2 = 500  # 第二段最大购买量\nmax_segment3 = 500  # 第三段最大购买量（总共最多1500）\n\ninv_A = 500  # 现有原油A库存\ninv_B = 1000  # 现有原油B库存\n\nM = 1e6  # 大M值\n\n# ----------------------------\n# 决策变量\n# ----------------------------\n\n# 汽油产量\nx1 = model.addVar(name=\"Gasoline_TypeI\")\nx2 = model.addVar(name=\"Gasoline_TypeII\")\n\n# 原油使用量\na1 = model.addVar(name=\"CrudeA_TypeI\")\nb1 = model.addVar(name=\"CrudeB_TypeI\")\na2 = model.addVar(name=\"CrudeA_TypeII\")\nb2 = model.addVar(name=\"CrudeB_TypeII\")\n\n# 购买的原油 A 分段数量\npa1 = model.addVar(ub=max_segment1, name=\"PurchaseA_Segment1\")  # ≤500\npa2 = model.addVar(ub=max_segment2, name=\"PurchaseA_Segment2\")  # ≤500\npa3 = model.addVar(ub=max_segment3, name=\"PurchaseA_Segment3\")  # ≤500\n\n# 是否进入某分段的二元变量\ny1 = model.addVar(vtype=GRB.BINARY, name=\"Segment1_Active\")\ny2 = model.addVar(vtype=GRB.BINARY, name=\"Segment2_Active\")\ny3 = model.addVar(vtype=GRB.BINARY, name=\"Segment3_Active\")\n\n# 总共使用的原油A和B\ntotal_a_used = a1 + a2\ntotal_b_used = b1 + b2\n\n# ----------------------------\n# 约束条件\n# ----------------------------\n\n# 1. 汽油生产由对应原油组成\nmodel.addConstr(a1 + b1 == x1, \"TypeI_Production\")\nmodel.addConstr(a2 + b2 == x2, \"TypeII_Production\")\n\n# 2. 原油A占比约束\nmodel.addConstr(a1 >= 0.5 * x1, \"TypeI_Min_A_Content\")\nmodel.addConstr(a2 >= 0.6 * x2, \"TypeII_Min_A_Content\")\n\n# 3. 原油使用总量不能超过库存+购买量\nmodel.addConstr(total_a_used <= inv_A + pa1 + pa2 + pa3, \"CrudeA_Limit\")\nmodel.addConstr(total_b_used <= inv_B, \"CrudeB_Limit\")\n\n# 4. 分段购买逻辑约束（必须买满前面段才允许进入下一段）\n# 第一段：只要 y1=1，就可以买，但不超过 max_segment1\nmodel.addConstr(pa1 <= max_segment1 * y1, \"Segment1_Upper\")\nmodel.addConstr(pa1 >= 0)\n\n# 第二段：只能在 y2=1 且 pa1 已买满时才能购买\nmodel.addConstr(pa2 <= max_segment2 * y2, \"Segment2_Upper\")\nmodel.addConstr(y1 >= y2, \"Must_Fill_Segment1_First\")\nmodel.addConstr(pa1 >= max_segment1 * y2, \"Fill_Segment1_Before_Segment2\")\n\n# 第三段：只能在 y3=1 且 pa1、pa2 都已买满时才能购买\nmodel.addConstr(pa3 <= max_segment3 * y3, \"Segment3_Upper\")\nmodel.addConstr(y2 >= y3, \"Must_Fill_Segment2_Before_Segment3\")\n# model.addConstr(pa1 >= max_segment1 * y3, \"Fill_Segment1_Before_Segment3\")\nmodel.addConstr(pa2 >= max_segment2 * y3, \"Fill_Segment2_Before_Segment3\")\n\n# ----------------------------\n# 目标函数：最大化利润 = 销售收入 - 原油成本\n# ----------------------------\n\nrevenue = price_I * x1 + price_II * x2\npurchase_cost = cost_A_segment1 * pa1 + cost_A_segment2 * pa2 + cost_A_segment3 * pa3\n\nprofit = revenue - purchase_cost\n\nmodel.setObjective(profit, GRB.MAXIMIZE)\n\n# ----------------------------\n# 求解模型\n# ----------------------------\n\nmodel.optimize()\n\n# ----------------------------\n# 输出结果\n# ----------------------------\n\nif model.status == GRB.OPTIMAL:\n    print(\"\\nOptimal Solution Found:\")\n    print(f\"Produce {x1.X:.2f} tons of Gasoline Type I\")\n    print(f\"Produce {x2.X:.2f} tons of Gasoline Type II\")\n    print(f\"Use {a1.X:.2f} tons of Crude A for Type I\")\n    print(f\"Use {b1.X:.2f} tons of Crude B for Type I\")\n    print(f\"Use {a2.X:.2f} tons of Crude A for Type II\")\n    print(f\"Use {b2.X:.2f} tons of Crude B for Type II\")\n    print(f\"Purchase Segment 1: {pa1.X:.2f} tons (<=500)\")\n    print(f\"Purchase Segment 2: {pa2.X:.2f} tons (500~1000)\")\n    print(f\"Purchase Segment 3: {pa3.X:.2f} tons (>1000)\")\n    print(f\"Total Profit: {profit.getValue():.2f} yuan\")\nelse:\n    print(\"No optimal solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Blending",
        "modeling_type": "MILP",
        "industry_sector": "Manufacturing",
        "reason": "The problem involves mixing different crude oils to produce gasoline, which is a classic blending problem. The solver uses continuous variables for quantities and binary variables to model the piecewise linear purchasing cost for crude oil A, making it a Mixed-Integer Linear Program. The application is in the production of gasoline, falling under the manufacturing sector."
      }
    ],
    "cluster": null
  },
  {
    "task_id": "B007",
    "description": "Now, we need to determine 4 out of 5 workers to complete one of the four tasks respectively. Due to each worker's different technical specialties, the time required for them to complete each task varies. The hours required by each worker to complete each task are shown in Table 5-2.\n\nTable 5-2\n| Worker | $A$ | $B$ | $C$ | $D$ |\n|--------|-----|-----|-----|-----|\n| I      | 9   | 4   | 3   | 7   |\n| II     | 4   | 6   | 5   | 6   |\n| III    | 5   | 4   | 7   | 5   |\n| IV     | 7   | 5   | 2   | 3   |\n| V      | 10  | 6   | 7   | 4   |\n\nTry to find a job assignment plan that minimizes the total working hours.",
    "ground_truth": 14.0,
    "formulation": null,
    "correct_program": "def optimize_worker_task_assignment():\n    from gurobipy import Model, GRB\n\n    # Data: hours required for each worker-task pair\n    hours = {\n        ('I', 'A'): 9,\n        ('I', 'B'): 4,\n        ('I', 'C'): 3,\n        ('I', 'D'): 7,\n        ('II', 'A'): 4,\n        ('II', 'B'): 6,\n        ('II', 'C'): 5,\n        ('II', 'D'): 6,\n        ('III', 'A'): 5,\n        ('III', 'B'): 4,\n        ('III', 'C'): 7,\n        ('III', 'D'): 5,\n        ('IV', 'A'): 7,\n        ('IV', 'B'): 5,\n        ('IV', 'C'): 2,\n        ('IV', 'D'): 3,\n        ('V', 'A'): 10,\n        ('V', 'B'): 6,\n        ('V', 'C'): 7,\n        ('V', 'D'): 4\n    }\n\n    workers = ['I', 'II', 'III', 'IV', 'V']\n    tasks = ['A', 'B', 'C', 'D']\n\n    # Create model\n    m = Model(\"WorkerTaskAssignment\")\n    m.setParam('OutputFlag', 0)  # Suppress output\n\n    # Decision variables: x_{i,j}\n    x = m.addVars(workers, tasks, vtype=GRB.BINARY, name='x')\n    # Worker selection variables: y_i\n    y = m.addVars(workers, vtype=GRB.BINARY, name='y')\n\n    # Objective: minimize total hours\n    m.setObjective(\n        sum(hours[(i, j)] * x[i, j] for i in workers for j in tasks),\n        GRB.MINIMIZE)\n\n    # Constraints:\n\n    # Each task assigned to exactly one worker\n    for j in tasks:\n        m.addConstr(sum(x[i, j] for i in workers) == 1,\n                    name=f\"Task_{j}_assignment\")\n\n    # Worker assignment constraints\n    for i in workers:\n        m.addConstr(sum(x[i, j] for j in tasks) <= y[i],\n                    name=f\"Worker_{i}_assignment_limit\")\n\n    # Exactly 4 workers are selected\n    m.addConstr(sum(y[i] for i in workers) == 4, name=\"Select_4_workers\")\n\n    # Linking constraints: worker assigned only if selected\n    for i in workers:\n        for j in tasks:\n            m.addConstr(x[i, j] <= y[i], name=f\"Link_{i}_{j}\")\n\n    # Optimize\n    m.optimize()\n\n    # Check feasibility and return optimal value\n    if m.status == GRB.OPTIMAL:\n        return m.objVal\n    else:\n        return None\n\nif __name__ == \"__main__\":\n    result = optimize_worker_task_assignment()\n    if result is not None:\n        print(f\"Optimal total hours: {result}\")\n    else:\n        print(\"No feasible solution found.\")",
    "output_status": [],
    "success_count": 0,
    "success_confidence": 0,
    "fail_to_diagnose": 0,
    "fail_to_verify": 0,
    "retrieved_insights": [],
    "tag": [
      {
        "problem_domain": "Assignment",
        "modeling_type": "MILP",
        "industry_sector": "General Business Operations",
        "reason": "The problem involves assigning workers to tasks to minimize total hours, which is a classic assignment problem. The formulation uses binary variables for assignments and worker selection, and linear constraints and objective, making it a Mixed-Integer Linear Program. This type of problem is common in various business operations where resources (workers) need to be allocated to tasks."
      }
    ],
    "cluster": null
  }
]