[
  {
    "insight_id": 3,
    "taxonomy": {
      "Domain Modeling": {
        "Packaging": [
          "Knapsack Constraints"
        ]
      }
    },
    "condition": "This insight applies when the problem domain requires selecting items that consume a single scalar capacity such as weight, volume, or budget. For example, when the problem statement required determining the least expensive way to meet nutritional requirements, it implies a budget constraint that resembles a knapsack problem.\nThis insight applies when the problem involves constraints that can be naturally modeled as capacity limits or budgetary restrictions.\nThis insight does NOT apply when the problem involves probabilistic constraints or optimizing expected outcomes, such as managing risk with chance-constrained optimization.",
    "explanation": "When the problem involves selecting food items to minimize cost while meeting nutritional requirements, the best practice is to recognize and model the problem as a knapsack problem. A common mistake is to overlook the budget-like nature of the cost constraint, which happens because the modeler may not recognize the implicit knapsack structure. More generally, this reflects that in optimization problems involving selection under capacity constraints, identifying and leveraging the knapsack structure can lead to more effective modeling.",
    "example": "# Wrong: Treating cost constraint as an ordinary linear constraint without recognizing its knapsack nature\n# Correct: Recognize and model it explicitly as a knapsack problem, minimizing cost while satisfying nutritional requirements",
    "iteration": 0,
    "version": 1,
    "task_id": "E021",
    "occurrence": 0,
    "distribution": {
      "positive": [
        "E001",
        "B016",
        "B081",
        "E033",
        "E025",
        "F122",
        "A093",
        "F167",
        "B033"
      ],
      "negative": [
        "A186",
        "F080"
      ],
      "unretrieved": [],
      "irrelevant": [
        "E014",
        "E033",
        "E007",
        "E004",
        "E025",
        "E034",
        "A093",
        "E009",
        "B033",
        "E017",
        "E005",
        "A235",
        "F103",
        "F021",
        "B080",
        "B019"
      ],
      "invalid": [
        "B080"
      ]
    }
  },
  {
    "insight_id": 6,
    "taxonomy": {
      "General Formulation": {
        "Variable Definition": [
          "Explicit Bounds"
        ]
      }
    },
    "condition": "This insight applies when the problem description provides natural physical, economic, or logical limits that can tightly bound decision variables. For example, when the optimization of food item consumption is bounded by realistic daily consumption limits.",
    "explanation": "When the problem involves decision variables with natural bounds, the best practice is to explicitly set lower and upper bounds to improve solver performance and ensure realistic solutions. A common mistake is omitting these bounds, which happens because the modeler assumes the solver will inherently handle feasibility. More generally, this reflects that setting explicit bounds can help guide solvers toward optimal solutions more efficiently.",
    "example": "# Wrong\nx_e = model.addVar(vtype=GRB.INTEGER, name=\"x_e\")\n\n# Correct\nx_e = model.addVar(vtype=GRB.INTEGER, lb=0, ub=10, name=\"x_e\")",
    "iteration": 0,
    "version": 1,
    "task_id": [
      "E017",
      "E019"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 9,
    "taxonomy": {
      "General Formulation": {
        "Constraint Formulation": [
          "Incorrect Relational Operators"
          ]
        }
    },
    "condition": "This insight applies when natural-language statements such as 'at least' or 'at most' must be translated into algebraic inequalities in an optimization model. For example, when the problem statement mentions minimum nutritional requirements or required nutritional targets, ensuring the constraints accurately capture these thresholds.",
    "explanation": "When the problem involves constraints that specify minimum or maximum thresholds, the best practice is to use the appropriate relational operators (\u2265 or \u2264) in the formulation. A common mistake is to misapply relational operators, which happens because of incorrect translation of problem requirements into algebraic form. More generally, this reflects that careful attention is needed to ensure that constraint formulations align with the intended relational logic from the problem description.",
    "example": "# Wrong: Using incorrect relational operators\nmodel.addConstr(gp.quicksum(protein[i] * x[i] for i in foods) > protein_min, 'ProteinRequirement')\n\n# Correct: Using correct relational operators\nmodel.addConstr(gp.quicksum(protein[i] * x[i] for i in foods) >= protein_min, 'ProteinRequirement')",
    "iteration": 0,
    "version": 1,
    "task_id": [
      "E005",
      "E030",
      "E023"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 10,
    "taxonomy": {
      "Domain Modeling": {
        "Packaging": [
          "Knapsack Constraints"
        ]
      }
    },
    "condition": "This insight applies when the problem domain requires selecting items that consume a single scalar capacity such as weight, volume, or budget. For example, when the problem statement mentioned the desire to minimize the cost of a meal plan while meeting nutritional requirements, effectively imposing a budgetary constraint.",
    "explanation": "When the problem involves selecting food items to meet nutritional targets while minimizing costs. The best practice is to ensure the constraints accurately reflect the scalar capacity, in this case, the budgetary limit. A common mistake is to overlook the discrete nature of item selection, which happens because the modeler might not account for the integer nature of purchasing decisions. More generally, this reflects that optimization models should accurately represent the constraints imposed by real-world capacities.",
    "example": "# Wrong\n\\min \\sum_{f \\in F} \\text{cost}_f \\cdot x_f\n\n# Correct\nmodel.setObjective(gp.quicksum(cost[i] * x[i] for i in foods), GRB.MINIMIZE)",
    "iteration": 0,
    "version": 1,
    "task_id": "E004",
    "occurrence": 0,
    "distribution": {
      "positive": [
        "B081"
      ],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [
        "F021"
      ],
      "invalid": [
        "F080"
      ]
    }
  },
  {
    "insight_id": 16,
    "taxonomy": {
      "Domain Modeling": {
        "Production Planning": [
          "Composition bounds"
        ]
      }
    },
    "condition": "This insight applies when the production planning problem involves specific composition constraints for each product, such as minimum or maximum percentages of raw materials in each candy brand. For example, when the problem statement mentioned that Candy A must contain at least 60% of raw material A and at most 20% of raw material C.",
    "explanation": "When the problem involves production planning with specific composition constraints for each product, the best practice is to define allocation variables that specify how much of each raw material is used in each product and ensure these allocations respect the given composition constraints. A common mistake is to define percentages as fixed parameters without explicitly modeling the allocation of raw materials, which happens because the allocation and composition requirements are not dynamically linked in the model. More generally, this reflects that production planning must account for both the allocation of raw materials and the satisfaction of product composition constraints in an integrated manner.",
    "example": "# Wrong: Define fixed composition percentages without linking them to allocations\nC4: a_{AA} \\geq 0.60  \nC6: a_{AC} \\leq 0.20\n\n# Correct: Define allocation variables and link them to composition constraints\nmodel.addConstr(R['RawA', 'CandyA'] >= 0.60 * X['CandyA'], name='Content_CandyA_RawA_min')\nmodel.addConstr(R['RawC', 'CandyA'] <= 0.20 * X['CandyA'], name='Content_CandyA_RawC_max')",
    "iteration": 0,
    "version": 1,
    "task_id": "B058",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 20,
    "taxonomy": {
      "Domain Modeling": {
        "Packaging": [
          "Knapsack Constraints"
        ]
      }
    },
    "condition": "This insight applies when the problem domain requires selecting items that consume a single scalar capacity such as weight, volume, or budget. For example, in the diet optimization problem, the cost of the food items must be minimized while meeting nutritional requirements, which is analogous to a knapsack problem where each food item has a cost.",
    "explanation": "When the problem involves a knapsack-like selection under a budget or capacity constraint, the best practice is to structure the model to explicitly reflect the cost or capacity constraint. A common mistake is to overlook the integral selection nature of the problem, which happens because the problem may seem continuous due to nutritional requirements. More generally, this reflects that knapsack constraints should be used for problems involving a selection of items under a budget or capacity constraint.",
    "example": "# Correct\nmodel.setObjective(gp.quicksum(cost[i] * x[i] for i in range(8)), GRB.MINIMIZE)\nmodel.addConstr(gp.quicksum(protein_content[i] * x[i] for i in range(8)) >= protein_requirement, 'ProteinRequirement')",
    "iteration": 0,
    "version": 1,
    "task_id": "E020",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 22,
    "taxonomy": {
      "General Formulation": {
        "Variable Definition": [
          "Explicit Bounds"
        ]
      }
    },
    "condition": "This insight applies when the problem description provides natural physical, economic, or logical limits that can tightly bound decision variables. For example, when the problem description involves selecting amounts of food items to consume, each item has a natural lower bound of zero because negative consumption is impossible.",
    "explanation": "When decision variables represent quantities that are inherently non-negative and potentially limited by practical considerations, the best practice is to specify explicit lower and upper bounds in the model. Omitting these bounds can lead to infeasible or unrealistic solutions, which happens because the solver might explore negative or excessively large values. More generally, this highlights the importance of setting explicit bounds to reflect realistic modeling assumptions and improve solver performance.",
    "example": "# Wrong: No explicit bounds\nx_i \u2265 0\n\n# Correct: Explicit bounds\nx = model.addVars(foods, name='x', lb=0, vtype=GRB.INTEGER)",
    "iteration": 0,
    "version": 1,
    "task_id": [
      "E020",
      "E025"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 25,
    "taxonomy": {
      "General Formulation": {
        "Variable Definition": [
          "Explicit Bounds"
        ]
      }
    },
    "condition": "This insight applies when the problem description includes practical limits on production capacities or resource usage. For example, when the problem statement mentioned maximum available oven and pastry chef hours.",
    "explanation": "When the problem involves constrained resources, the best practice is to define explicit bounds on decision variables to reflect these constraints. A common mistake is omitting these bounds, which happens because modelers assume constraints alone are sufficient. More generally, this reflects that explicit bounds can enhance solver efficiency and solution feasibility.",
    "example": "# Wrong\n# No explicit bounds on variables\n\n# Correct\nx \\geq 0, x \\leq 70\n",
    "iteration": 0,
    "version": 1,
    "task_id": "A033",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 28,
    "taxonomy": {
      "Domain Modeling": {
        "Resource Allocation": [
          "Capacity/Resource Balance Equations"
        ]
      }
    },
    "condition": "This insight applies when the problem domain requires resources to move or transform through nodes and local conservation must hold. For example, when the problem statement involves ensuring that the usage of printing and scanning machines does not exceed their available time limits, or in the meal plan problem where nutritional constraints act as resource balance equations to ensure sufficient nutrient intake.",
    "explanation": "When the problem involves balancing resource usage against constraints, the best practice is to accurately model the consumption of resources with constraints that ensure feasibility. A common mistake is neglecting to include such constraints or misformulating them, which happens because modelers may overlook the necessity of enforcing these limits explicitly. More generally, this reflects that resource allocation problems require precise formulation of capacity constraints to ensure valid solutions.",
    "example": "# Wrong\n# Constraints are missing or misformulated\n# Correct\nmodel.addConstr(time_print_graph * x + time_print_music * y <= machine_time_limit, 'Printing_Time')",
    "iteration": 0,
    "version": 1,
    "task_id": [
      "E021",
      "A179"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 32,
    "taxonomy": {
      "Domain Modeling": {
        "Facility Location": [
          "Fixed Charge (Big-M Linking)"
        ]
      }
    },
    "condition": "This insight applies when the problem description specifies conditional logic based on binary choices, such as service availability or threshold conditions linked to binary variables. For example, when linking the decision to plant a fruit to land use or when using indicator constraints.",
    "explanation": "When the problem involves conditional decisions based on binary choices, the best practice is to use Big-M constraints or solver-syntax for indicator constraints to link decisions. A common mistake is neglecting these dependencies or using incorrect syntax, which happens due to misunderstanding solver functions or not enforcing conditional logic. More generally, this reflects that accurate modeling of conditional logic requires binary variables and proper constraint syntax.",
    "example": "# Wrong: x_A, x_P are not linked to any binary variable\n# Correct: model.addConstr(x_A <= M * y_A, 'Link_Apples')\n\n# Wrong: model.addGenConstrIndicator(y_A, True, x_A >= 0.0001, \"LinkA\")\n# Correct: model.addGenConstrIndicator(y_A, True, x_A, GRB.GREATER_EQUAL, 0.0001, \"LinkA\")",
    "iteration": 0,
    "version": 1,
    "task_id": [
      "B057"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [
        "B021"
      ],
      "negative": [],
      "unretrieved": [
        "B019",
        "B033",
        "B057"
      ],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 33,
    "taxonomy": {
      "Domain Modeling": {
        "Selection": [
          "Binary Selection Constraints"
        ]
      }
    },
    "condition": "This insight applies when the problem domain requires choosing a subset under count, budget, or compatibility limits. For example, when the problem statement requires that Vicky and David can grow at most two types of fruit.",
    "explanation": "When the problem involves selection constraints, the best practice is to define binary variables to clearly indicate which items are selected and link them to continuous variables for conditional activities. A common mistake is omitting these binary variables, which happens because the modeler assumes constraints can be enforced on continuous decision variables alone. More generally, this reflects that binary selection constraints should be used when a decision involves choosing a limited subset of items and linking conditions require auxiliary binary variables.",
    "example": "# Wrong: No binary variable to enforce selection\n# Correct: y_A, y_P, y_O, y_L are binary variables representing selection",
    "iteration": 0,
    "version": 1,
    "task_id": [
      "B057"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 39,
    "taxonomy": {
      "Domain Modeling": {
        "Balancing": [
          "Proportion Constraints"
        ]
      }
    },
    "condition": "This insight applies when the problem description specifies a maximum or minimum proportion of usage for a certain resource. For example, when the problem statement mentioned that only a maximum of 40% of the transportation can be using trolleys.",
    "explanation": "When the problem involves proportional constraints, like limiting the proportion of transportation using trolleys to 40%, the best practice is to set up the constraints to reflect these ratios correctly. A common mistake is to incorrectly set the relational operator or the expression, which happens because of a misinterpretation of the proportion requirement. More generally, this reflects that domain-specific proportion constraints must be directly aligned with the problem's specified ratios.",
    "example": "# Wrong: K_t x_t \u2264 P(K_c x_c + K_t x_t)\n# Correct: 7x_t \u2264 0.4(5x_c + 7x_t)",
    "iteration": 0,
    "version": 1,
    "task_id": "A198",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 40,
    "taxonomy": {
      "General Formulation": {
        "Units Scaling": [
          "Unit Inconsistency"
        ]
      }
    },
    "condition": "This insight applies when input data come from different unit systems or incompatible measurement scales. For example, when the problem statement required minimizing the total amount of curry base used, it is essential to ensure the units of curry base per bowl are consistent.",
    "explanation": "When the problem involves minimizing an objective related to resource usage, the best practice is to ensure all terms in the objective function are in compatible units. A common mistake is having inconsistent units, which happens because of oversight in converting or aligning units. More generally, this reflects that consistent units are crucial for the correct formulation of the objective function.",
    "example": "# Wrong: Minimize 3x_g + 5x_c (inconsistent units in failed model)\n# Correct: Minimize 6x_g + 5x_c (consistent with gold-standard program)",
    "iteration": 0,
    "version": 1,
    "task_id": "A068",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 42,
    "taxonomy": {
      "Code Implementation": {
        "Solver & API Syntax": [
          "Nonlinear Constraint Handling"
        ]
      }
    },
    "condition": "This insight applies when the mathematical model contains constraints involving nonlinear operations that need linearization to maintain tractability or solver performance. For example, when the formulation includes x_L / (x_L + x_B) >= 0.7, or requires the number of car trips to be at least 60% of the total trips, or when the problem statement involves a constraint on the proportion of omega drinks, introducing a ratio that must be linearized.",
    "explanation": "When the problem involves nonlinear constraints due to division or ratio operations, the best practice is to linearize these constraints. A common mistake is to directly implement the nonlinear constraint in the solver, which happens because solvers like Gurobi do not handle nonlinear constraints in linear models efficiently. More generally, this reflects that linearization is necessary for constraints to be compatible with linear programming solvers and maintain model tractability.",
    "example": "# Wrong: model.addConstr(x_L / (x_L + x_B) >= 0.7, \"C2\")\n# Correct: model.addConstr(x_L >= 0.7 * (x_L + x_B), \"C2\")\n# Wrong: x_C >= 0.6(x_B + x_C)\n# Correct: x_C >= 1.5 * x_B",
    "iteration": 0,
    "version": 1,
    "task_id": [
      "A146",
      "A209",
      "A079"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 43,
    "taxonomy": {
      "Domain Modeling": {
        "Resource Allocation": [
          "Capacity/Resource Balance Equations"
        ]
      }
    },
    "condition": "This insight applies when the problem domain requires resources to move or transform through nodes and local conservation must hold. For example, when the problem statement mentioned availability of goat and chicken meat, or a total delivery rate of 100 kg/min that must be achieved by combining carts and trolleys. This insight applies when keywords like 'balancing', 'demand', 'capacity', or 'resource allocation' are present, indicating the need for careful management of resource flows. For example, when the problem statement mentions production constraints, fluctuating demands, or the need to optimize resource usage. This insight does NOT apply when the problem involves fixed proportions, quality constraints, or predefined resource allocations. For example, when the problem statement includes constraints like 'at least 12 trolleys to be used' or 'maximum sulfur content in products'.",
    "explanation": "When the problem involves ensuring that the resources used in production do not exceed availability or ensuring specific capacity requirements are met, the best practice is to model constraints that directly reflect the balance between available resources and their consumption. A common mistake is to overlook these balance equations or misinterpret resource proportions, which happens because the focus might be on other constraints or objectives. More generally, this reflects that capacity and resource constraints must be explicitly modeled to ensure feasibility and maintain the intended resource balance.",
    "example": "# Wrong: 3x_g <= 1500 and 5x_c <= 2000\n# Correct: 3x_g <= 1500 and 5x_c <= 2000 (No change needed, but ensure they are considered in solution)\n# Wrong\nK_c \\cdot x_c + K_t \\cdot x_t = R\n\n# Correct\nK_c \\cdot x_c + K_t \\cdot x_t >= R\n# Wrong: 7x_t <= 0.4(5x_c + 7x_t)\n# Correct: 2x_c >= 4.2x_t",
    "iteration": 0,
    "version": 1,
    "task_id": [
      "A068",
      "A198"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [
        "B096",
        "F091",
        "F203",
        "B030",
        "B006",
        "F019",
        "A223",
        "B016",
        "A236",
        "B087",
        "A084",
        "B031",
        "B064",
        "B023"
      ],
      "negative": [
        "A198",
        "F102",
        "B058",
        "B096"
      ],
      "unretrieved": [
        "B058",
        "B066",
        "B064",
        "B039",
        "B000",
        "B033",
        "F057",
        "B080",
        "B021",
        "E038"
      ],
      "irrelevant": [
        "E038",
        "B019"
      ],
      "invalid": [
        "E035",
        "B039"
      ]
    }
  },
  {
    "insight_id": 44,
    "taxonomy": {
      "Code Implementation": {
        "Solver & API Syntax": [
          "Nonlinear Constraint Handling"
        ]
      }
    },
    "condition": "This insight applies when the mathematical model contains nonlinear constraints that need to be restructured to fit into a linear programming framework. For example, when the formulation included the nonlinear constraint x_v / (x_v + x_c) <= P.",
    "explanation": "When the problem involves constraints that are inherently nonlinear, such as ratios or products of decision variables, the best practice is to reformulate these constraints into a linear form if possible. A common mistake is to directly implement nonlinear constraints in a linear programming solver, which happens because such solvers do not natively support nonlinearity. More generally, this reflects that linear programming models require all constraints to be expressed in linear terms.",
    "example": "# Wrong: model.addConstr(x_v / (x_v + x_c) <= P, \"C2\")\n# Correct: model.addConstr(x_v <= P * (x_v + x_c), \"C2\")",
    "iteration": 0,
    "version": 1,
    "task_id": "A170",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 45,
    "taxonomy": {
      "Domain Modeling": {
        "Resource Allocation": [
          "Capacity/Resource Balance Equations"
        ]
      }
    },
    "condition": "This insight applies when the problem description involves maintaining a certain level of service or interaction that depends on multiple resource types, such as servers delivering by cart or by hand. For example, when the problem statement mentioned the requirement of 4000 customer interactions per hour and specific interactions per server type.",
    "explanation": "When the problem involves maintaining service levels with different resource types, the best practice is to ensure that the total service level is met by combining the contributions of each resource type. A common mistake is to use a single resource's contribution as a proxy for the whole, which happens because the contributions of different resources are not aggregated correctly. More generally, this reflects that maintaining a balance of multiple resource contributions is critical for meeting overall service requirements.",
    "example": "# Wrong: x_c + x_h >= 4000 / i_c\n# Correct: 70 * x_c + 85 * x_h >= 4000",
    "iteration": 0,
    "version": 1,
    "task_id": "A211",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [
        "B030"
      ],
      "invalid": []
    }
  },
  {
    "insight_id": 48,
    "taxonomy": {
      "Domain Modeling": {
        "Resource Allocation": [
          "Set-Partitioning/Assignment"
        ]
      }
    },
    "condition": "This insight applies when the problem description requires each item or task to be exclusively assigned to exactly one choice among many. For example, when the problem statement mentioned that the farmer wants to choose only one of the two transportation methods: bicycle or handcart. This insight applies when the decision-making process involves choosing a single option from a set of alternatives for each task or item, ensuring exclusivity, OR when each task requires a distinct, exclusive outcome. This insight does NOT apply when only a subset of the available options must be mutually exclusive. For example, when the problem statement mentions that only the van and electric vehicle must be mutually exclusive, but other transportation methods can be used simultaneously, and additional constraints like pollution limits and minimum trip requirements apply.",
    "explanation": "When the problem involves mutually exclusive choices between options, the best practice is to use binary variables for each option and enforce that only one can be selected. A common mistake is to use a product of variables to enforce exclusivity, which happens because it leads to non-linear constraints that are harder to solve. More generally, this reflects that exclusive decisions should be modeled using binary variables and constraints to maintain linearity.",
    "example": "# Wrong: x_bicycle * x_handcart = 0\n# Correct: y_B + y_C = 1, where y_B and y_C are binary variables representing the selection of bicycle and handcart respectively.",
    "iteration": 0,
    "version": 1,
    "task_id": "B062",
    "occurrence": 0,
    "distribution": {
      "positive": [
        "B062"
      ],
      "negative": [
        "B023"
      ],
      "unretrieved": [],
      "irrelevant": [
        "B032"
      ],
      "invalid": []
    }
  },
  {
    "insight_id": 49,
    "taxonomy": {
      "General Formulation": {
        "Variable Definition": [
          "Redundant Auxiliary Variables"
        ]
      }
    },
    "condition": "This insight applies when auxiliary variables merely re-express existing linear combinations without adding modeling value. For example, when the problem statement mentioned minimizing the total number of trips, but the gold-standard program minimized the total pollution instead.",
    "explanation": "When the problem involves defining an objective based on existing constraints or variables, the best practice is to directly include the primary goal, such as minimizing pollution, in the objective function. A common mistake is introducing auxiliary variables that do not simplify the model or objective, or minimizing a secondary aspect like the number of trips, which happens because of unnecessary complexity or misalignment with the true optimization goal. More generally, this reflects that objectives should be directly tied to the core decision variables and constraints to maintain clarity and simplicity.",
    "example": "# Wrong: Minimize (x_H + x_B + x_C) \n# Correct: Minimize (pollution_horse * x_H)",
    "iteration": 0,
    "version": 1,
    "task_id": [
      "E029",
      "E007",
      "B062",
      "E012",
      "B058"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 50,
    "taxonomy": {
      "Domain Modeling": {
        "Facility Location": [
          "Fixed Charge (Big-M Linking)"
        ]
      }
    },
    "condition": "This insight applies when constraints depend on logical on/off conditions controlled by binary variables and service or flow is allowed only if a facility is opened. For example, when the problem statement mentioned that either the bicycle or the handcart can be chosen, and trips with the chosen mode are allowed.",
    "explanation": "When the problem involves conditional constraints based on binary choices, the best practice is to use Big-M linking constraints to ensure that actions, such as trips, are only counted if the corresponding condition, like mode selection, is active. A common mistake is failing to enforce these linking constraints, which happens because it does not correctly apply the conditional logic necessary for the solution. More generally, this reflects that Big-M and binary variables are a powerful combination for modeling conditional constraints effectively.",
    "example": "# Wrong: No linking constraints for mode selection\n# Correct: x_B <= M * y_B and x_C <= M * y_C, where M is a large constant, and y_B, y_C are binary variables indicating the selection of bicycle or handcart.",
    "iteration": 0,
    "version": 1,
    "task_id": [
      "B062"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [
        "B021"
      ],
      "invalid": []
    }
  },
  {
    "insight_id": 51,
    "taxonomy": {
      "General Formulation": {
        "Constraint Formulation": [
          "Linearization of Non-linear Forms"
        ]
      }
    },
    "condition": "This insight applies when a constraint involves a non-linear expression that can be problematic for linear solvers. For example, in the failed mathematical model, the constraint for the minimum proportion of canoe trips was expressed as a non-linear equation involving division.",
    "explanation": "When the problem involves constraints with non-linear expressions, the best practice is to linearize them whenever possible. A common mistake is to use non-linear forms directly, which happens because modelers may overlook the solver's requirement for linearity. More generally, this reflects the need to transform complex expressions into linear forms for compatibility with linear solvers.",
    "example": "# Wrong: x_C >= R_C * (x_B + x_C) / (1 - R_C)\n# Correct: x_C >= R_C * (x_B + x_C)",
    "iteration": 0,
    "version": 1,
    "task_id": "F036",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [
        "F057",
        "B016",
        "B019",
        "B096",
        "A186"
      ],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 52,
    "taxonomy": {
      "Domain Modeling": {
        "Resource Allocation": [
          "Capacity/Resource Balance Equations"
        ]
      }
    },
    "condition": "This insight applies when the problem domain contains multiple identical resources that are substitutable and individual identities do not matter. For example, when the problem statement mentioned multiple raw materials that can be pooled for use across different candy brands, or when ducks can be transported by either boats or canoes, focusing on the total number of trips rather than specific sequence or assignment of trips.",
    "explanation": "When the problem involves interchangeable resources that can be aggregated, the best practice is to model them as a pooled resource to simplify the formulation. A common mistake is to treat them as distinct or sequentially dependent, which happens because modelers may overcomplicate the problem by focusing on individual assignments. More generally, this reflects the efficiency gained by using resource pooling when resource identities do not impact the outcome.",
    "example": "# Wrong: Model boat and canoe trips with distinct identities\n# Correct: Model using total trips with pooled resources",
    "iteration": 0,
    "version": 1,
    "task_id": [
      "F036",
      "B058"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 57,
    "taxonomy": {
      "Code Implementation": {
        "Solver & API Syntax": [
          "Nonlinear Constraint Handling"
        ]
      }
    },
    "condition": "This insight applies when the mathematical model contains an objective function that involves non-linear terms. For example, when the formulation included the objective function (x * T_A + y * T_B) / (x + y).",
    "explanation": "When the problem involves optimizing an objective that is not linear or quadratic. The best practice is to transform the objective function into a linear or quadratic form. A common mistake is directly using non-linear expressions, which happens because the solver cannot handle such formulations. More generally, this reflects that the mathematical constraints of optimization solvers require specific functional forms for objectives.",
    "example": "# Wrong: model.setObjective((x * T_A + y * T_B) / (x + y), GRB.MINIMIZE)\n# Correct: model.setObjective(x * T_A + y * T_B, GRB.MINIMIZE)",
    "iteration": 0,
    "version": 1,
    "task_id": "A240",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 59,
    "taxonomy": {
      "General Formulation": {
        "Variable Definition": [
          "Continuous vs. Discrete Confusion"
        ]
      }
    },
    "condition": "This insight applies when decision quantities in the problem represent divisible amounts or flows versus indivisible counts or choices. For example, when the problem statement mentioned hours allocated to companies or producing batches of bagels and croissants without specifying indivisibility.",
    "explanation": "When the problem involves allocating resources or tasks in divisible terms (e.g., images, hours), the best practice is to use continuous variables to capture the flexibility of fractional assignments. A common mistake is to use integer variables, which happens because of a misinterpretation that allocations must be whole numbers. More generally, this reflects that continuous variables are appropriate for modeling divisible resources or tasks, allowing finer granularity and efficiency in allocation.",
    "example": "# Wrong\nh_s = model.addVar(vtype=GRB.INTEGER, name='h_s')\n\n# Correct\nx_s = model.addVar(name='x_s', lb=0)",
    "iteration": 0,
    "version": 1,
    "task_id": [
      "F131",
      "B029",
      "A033"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 65,
    "taxonomy": {
      "General Formulation": {
        "Variable Definition": [
          "Redundant Auxiliary Variables"
        ]
      }
    },
    "condition": "This insight applies when auxiliary variables merely re-express existing linear combinations without adding modeling value. For example, when the problem statement involves minimizing total discharge or minimizing total cost, which can be directly expressed in the objective function.",
    "explanation": "When the problem involves minimizing an expression like total discharge or total cost, the best practice is to directly express this in the objective function without introducing unnecessary variables. A common mistake is to use auxiliary variables that do not add value to the model, which happens because of a tendency to over-complicate the formulation. More generally, this reflects that model simplicity and directness should be preserved unless additional variables are necessary for clarity or functionality.",
    "example": "# Wrong\nz = 0.3x1 + 0.1x2  # total discharge\n\n# Correct\nMinimize: 0.3 * x1 + 0.1 * x2",
    "iteration": 0,
    "version": 1,
    "task_id": [
      "F131",
      "A078"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 66,
    "taxonomy": {
      "General Formulation": {
        "Variable Definition": [
          "Continuous vs. Discrete Confusion"
        ]
      }
    },
    "condition": "This insight applies when decision quantities in the problem represent indivisible counts or choices versus divisible amounts such as flows. For example, when the problem statement mentioned the number of servings of each supplement the patient needs, which are inherently discrete, or the number of pills, which must be an integer.",
    "explanation": "When the problem involves determining the number of items such as servings or pills, the best practice is to use integer variables to represent these counts. A common mistake is to model these as continuous variables, which happens because the modeler may overlook the discrete nature of the items. More generally, this reflects that whenever decisions involve indivisible units, integer variables should be employed.",
    "example": "# Wrong\nx_A \\geq 0: Number of servings of supplement A (continuous)\n\n# Correct\nx_A \\in \\mathbb{Z}^+: Number of servings of supplement A (integer)",
    "iteration": 0,
    "version": 1,
    "task_id": [
      "A078",
      "F088"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 67,
    "taxonomy": {
      "Domain Modeling": {
        "Resource Allocation": [
          "Capacity/Resource Balance Equations"
        ]
      }
    },
    "condition": "This insight applies when the problem domain requires resources to move or transform through nodes and local conservation must hold. For example, when the problem statement mentioned constraints ensuring a minimum required intake of Calcium and Magnesium, which can be seen as resource balance requirements for these nutrients. This insight applies when the problem involves resource allocation where specific resource balance equations are necessary to ensure constraints on usage are met. For example, when the problem statement involves constraints on machine hours, equipment capacities, or the availability of compounds, which align with resource balance equations. This insight does NOT apply when the problem is abstract or qualitative in nature without explicit numerical resource constraints or balance requirements.",
    "explanation": "When the problem involves ensuring minimum nutritional requirements, the best practice is to correctly formulate constraints to meet these requirements using \u2265 inequalities. A common mistake is to misapply or overlook these constraints, which happens because the modeler may not accurately interpret the nutritional needs as resource balance equations. More generally, this reflects that proper resource balance equations are crucial in ensuring that minimum or maximum resource conditions are satisfied.",
    "example": "# Wrong\n# Misinterpretation or absence of constraints\n\n# Correct\n30x_A + 60x_B \\geq 400  # Calcium requirement\n50x_A + 10x_B \\geq 50   # Magnesium requirement",
    "iteration": 0,
    "version": 1,
    "task_id": "F088",
    "occurrence": 0,
    "distribution": {
      "positive": [
        "A180",
        "A179",
        "A172",
        "F091",
        "F088",
        "B087",
        "A084",
        "B064"
      ],
      "negative": [],
      "unretrieved": [
        "F091",
        "B030",
        "B064",
        "B096",
        "B033"
      ],
      "irrelevant": [
        "E038",
        "E035",
        "A104",
        "F019",
        "A223"
      ],
      "invalid": [
        "B031",
        "B039"
      ]
    }
  },
  {
    "insight_id": 72,
    "taxonomy": {
      "General Formulation": {
        "Variable Definition": [
          "Continuous vs. Discrete Confusion"
        ]
      }
    },
    "condition": "This insight applies when decision quantities in the problem represent indivisible counts or choices versus divisible amounts such as flows. For example, when the problem statement involves the number of times a furnace uses a method, which can be fractional, or allocating methods to furnaces, which cannot be fractionally used.",
    "explanation": "When the problem involves divisible quantities, the best practice is to use continuous variables. A common mistake is using integer variables, which happens because the modeler may confuse countable quantities with divisible ones. Conversely, for indivisible allocations, integer variables are appropriate. More generally, this reflects that choosing the correct variable type is crucial for model flexibility and tractability.",
    "example": "# Wrong: Integer variables for divisible quantities\nx1, x2 >= 0 and integers\n\n# Correct: Continuous variables\nx[f,m]: number of times furnace f uses method m; continuous\n\n# Wrong: Continuous variables for indivisible allocations\nx = model.addVars(num_furnaces, num_methods, lb=0, vtype=GRB.CONTINUOUS)\n\n# Correct: Integer variables for indivisible allocations\nx = model.addVars(num_furnaces, num_methods, lb=0, vtype=GRB.INTEGER)",
    "iteration": 0,
    "version": 1,
    "task_id": [
      "B041",
      "A223"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 73,
    "taxonomy": {
      "Domain Modeling": {
        "Resource Allocation": [
          "Capacity/Resource Balance Equations"
        ]
      }
    },
    "condition": "This insight applies when the problem description involves managing limited resources, such as land, budget, and labor, to achieve an optimal allocation. For example, when the problem statement mentioned constraints on land, budget, and person-days for crop cultivation and animal husbandry.",
    "explanation": "When the problem involves resource allocation with limited capacities, the best practice is to define constraints that ensure resource usage does not exceed availability. A common mistake is to neglect to explicitly track and limit external labor opportunities, which happens because the model may assume that all available resources are used internally. More generally, this reflects that resource balance equations must account for all potential uses of resources, including external opportunities.",
    "example": "# Wrong: Labor constraints only account for internal usage\nC3: sum(crops[c]['aw'] * x_crops[c] for c in crops) + dairy_cow_aw * x_cows + chicken_aw * x_chickens <= P_aw\n\n# Correct: Labor constraints account for both internal usage and external sales\nmodel.addConstr(labor_aw_farm + L_aw_out <= labor_aw_available, name='LaborAWLimit')",
    "iteration": 0,
    "version": 1,
    "task_id": "B046",
    "occurrence": 0,
    "distribution": {
      "positive": [
        "F167",
        "B039"
      ],
      "negative": [],
      "unretrieved": [
        "A186"
      ],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 75,
    "taxonomy": {
      "Domain Modeling": {
        "Balancing": [
          "Load Balancing Constraints"
        ]
      }
    },
    "condition": "This insight applies when the problem involves minimizing the imbalance or absolute difference between two groups. For example, when the problem statement mentioned minimizing the difference in inheritance value between two sons.",
    "explanation": "When the problem involves minimizing a function that can be expressed directly, it is necessary to linearize the expression to handle it within linear programming solvers. The best practice is to model the absolute difference in a linear form using auxiliary variables to directly minimize the imbalance. A common mistake is failing to correctly linearize the absolute difference or using redundant auxiliary variables, which happens because it may seem like a straightforward way to linearize complex expressions. More generally, this reflects that objective specifications should be streamlined to avoid unnecessary complexity in the model while ensuring linear programming formulations can handle the expressions.",
    "example": "# Wrong: \nmin |sum(values[v] * x_v for v in V) - sum(values[v] * (1 - x_v) for v in V)|\n\n# Correct:\n# Introduce auxiliary variable d\nm.setObjective(d, GRB.MINIMIZE)\n# Add constraints: sum_values_y = sum(values[v] * y_vars[v] for v in values)\nm.addConstr(2 * sum_values_y - V_total <= d, 'abs_diff_upper')\nm.addConstr(-(2 * sum_values_y - V_total) <= d, 'abs_diff_lower')",
    "iteration": 0,
    "version": 1,
    "task_id": [
      "B032"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [
        "B032"
      ],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 76,
    "taxonomy": {
      "Domain Modeling": {
        "Resource Allocation": [
          "Set-Partitioning/Assignment"
        ]
      }
    },
    "condition": "This insight applies when the problem description requires each car to be parked on exactly one side of the street. For example, when the problem statement mentioned that each car must be parked on either the left or right side, not both, the failed model correctly used a constraint to ensure this, but the overall formulation did not address the objective and constraints correctly.",
    "explanation": "When the problem involves assigning cars to parking spots, the best practice is to ensure each car is assigned to exactly one side using binary decision variables. A common mistake is not properly aligning this constraint with the overall objective or other constraints, which happens because the model fails to differentiate between minimizing total versus maximum street occupancy. More generally, this reflects that set-partitioning/assignment problems require careful alignment of constraints with the problem's objective to ensure feasible and optimal solutions.",
    "example": "# Wrong: Each car must be assigned without considering objective alignment\nx_i + y_i = 1, for all i\n\n# Correct: Ensure alignment with objective\nx_i + y_i = 1, for all i\nand align with correct objective to minimize L_max",
    "iteration": 0,
    "version": 1,
    "task_id": "B080",
    "occurrence": 0,
    "distribution": {
      "positive": [
        "B080"
      ],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 77,
    "taxonomy": {
      "Domain Modeling": {
        "Resource Allocation": [
          "Set-Partitioning/Assignment"
        ]
      }
    },
    "condition": "This insight applies when the problem description requires each item or task to be exclusively assigned to exactly one choice among many. For example, when the problem statement mentioned that each car must be parked either on the left or right side of the street.",
    "explanation": "When the problem involves assigning tasks or resources to exclusive options, the best practice is to use constraints that ensure each item is assigned to exactly one option. A common mistake is neglecting this exclusivity, which happens because the model might incorrectly allow multiple or no assignments. More generally, this reflects that assignment problems require explicit formulation of exclusive choice constraints.",
    "example": "# Wrong\nx_i + y_i <= 1  # Allows for neither or both sides\n\n# Correct\nx_i + y_i = 1  # Ensures exactly one side",
    "iteration": 0,
    "version": 1,
    "task_id": "B080",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [
        "B080"
      ],
      "invalid": []
    }
  },
  {
    "insight_id": 79,
    "taxonomy": {
      "General Formulation": {
        "Variable Definition": [
          "Explicit Bounds"
        ]
      }
    },
    "condition": "This insight applies when the problem description provides natural physical, economic, or logical limits that can tightly bound decision variables. For example, when the problem involves purchasing food items with practical constraints suggesting reasonable upper bounds on the quantity of each item, or when the problem statement mentioned at least 4 runners must be used, and the model failed to incorporate a constraint to explicitly enforce this minimum.",
    "explanation": "When the problem involves decision variables with practical limits, the best practice is to set explicit bounds based on these limits. A common mistake is omitting these bounds, which happens because the modeler assumes the solver will naturally handle unbounded variables. More generally, this reflects that explicit bounds can enhance solver performance and prevent unrealistic solutions.",
    "example": "# Wrong: x_i \u2265 0\n# Correct: 0 \u2264 x_i \u2264 50 (assuming a reasonable max bound of 50 units per food item)",
    "iteration": 0,
    "version": 1,
    "task_id": [
      "F135",
      "E002"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 80,
    "taxonomy": {
      "Domain Modeling": {
        "Resource Allocation": [
          "Capacity/Resource Balance Equations"
        ]
      }
    },
    "condition": "This insight applies when the problem domain requires resources to move or transform through nodes and local conservation must hold. For example, when the problem statement mentioned balancing multiple nutritional requirements using available food options.",
    "explanation": "When the problem involves balancing multiple resources like nutrients, the best practice is to establish constraints that ensure each nutritional requirement is met. A common mistake is to misinterpret or omit these constraints, which happens because of overlooking the need for balance equations. More generally, this reflects that resource balance constraints are crucial for ensuring requirements are met in allocation problems.",
    "example": "# Wrong\n# Missing calorie constraint\nmodel.addConstr(2*x1 + 11*x2 + 19*x3 + 17*x4 >= 88)\n\n# Correct\nmodel.addConstr(2*x1 + 11*x2 + 19*x3 + 17*x4 >= 88)\nmodel.addConstr(9*x1 + 29*x2 + 16*x3 + 9*x4 >= 107)\nmodel.addConstr(165*x1 + 230*x2 + 68*x3 + 258*x4 >= 1944)",
    "iteration": 0,
    "version": 1,
    "task_id": "E011",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [
        "A171",
        "E017",
        "F080",
        "E038",
        "F088"
      ],
      "invalid": []
    }
  },
  {
    "insight_id": 81,
    "taxonomy": {
      "General Formulation": {
        "Variable Definition": [
          "Explicit Bounds"
        ]
      }
    },
    "condition": "This insight applies when the problem description provides natural physical, economic, or logical limits that can tightly bound decision variables. For example, when food items must be purchased in non-negative quantities, and there is no upper limit specified.",
    "explanation": "When the problem involves decision variables that have natural limits, such as non-negative quantities of food items, the best practice is to explicitly define these bounds. A common mistake is to leave bounds implicit, which happens because the modeler assumes default bounds are sufficient. More generally, this reflects that explicit bounds can improve solution efficiency and accuracy.",
    "example": "# Wrong: x_i \u2265 0\n# Correct: x_i \u2208 [0, \u221e) or x_i >= 0",
    "iteration": 0,
    "version": 1,
    "task_id": "E006",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 82,
    "taxonomy": {
      "Domain Modeling": {
        "Resource Allocation": [
          "Capacity/Resource Balance Equations"
        ]
      }
    },
    "condition": "This insight applies when the problem domain contains multiple identical resources that are substitutable and individual identities do not matter. For example, when the problem involves multiple food items that can be combined to meet nutritional requirements or when two identical steel furnaces can be allocated to any steelmaking method without individual distinction.",
    "explanation": "When the problem involves interchangeable resources, the best practice is to aggregate these resources into a single pool and allocate accordingly. A common mistake is to treat each resource separately without considering their collective contribution, which happens because modelers might overlook opportunities for resource pooling. More generally, this reflects that in resource allocation problems, interchangeable resources should be aggregated to simplify the model and leverage their substitutability.",
    "example": "# Wrong\n# Treating each food item separately\np_steak = 20 * x_steak\np_rice = 6 * x_rice\n\n# Correct\n# Aggregating resources\nprotein = sum([20 * x_steak, 6 * x_rice, ...])",
    "iteration": 0,
    "version": 1,
    "task_id": [
      "E009",
      "B041"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 84,
    "taxonomy": {
      "Domain Modeling": {
        "Production Planning": [
          "Technical Ratio Constraints"
        ]
      }
    },
    "condition": "This insight applies when the problem description specifies a production ratio requirement between products. For example, when the problem statement mentioned that for every five units of product A produced, at least two units of product B must be produced.",
    "explanation": "When the problem involves a technical ratio constraint between production quantities, the best practice is to convert this ratio into a linear inequality that reflects the minimum required condition. A common mistake is to misinterpret the ratio constraint and formulate it incorrectly, which happens because the algebraic representation does not match the intended requirement. More generally, this reflects that ratio constraints must be carefully translated into linear formulations to ensure feasibility and optimality.",
    "example": "# Wrong: x_A / x_B >= 5/2\n# Correct: 2 * x_A - 5 * x_B <= 0",
    "iteration": 0,
    "version": 1,
    "task_id": "B090",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 87,
    "taxonomy": {
      "Domain Modeling": {
        "Production Planning": [
          "Composition bounds"
        ]
      }
    },
    "condition": "This insight applies when the problem description involves producing multiple products using shared resources with capacity constraints. For example, when the problem statement mentioned available machine times and production times for each product on different machines.",
    "explanation": "When the problem involves allocating shared resources to produce multiple products, the best practice is to clearly define and apply resource constraints for each machine or resource. A common mistake is to overlook or improperly formulate these constraints, which happens because it fails to accurately model the limited availability of shared resources. More generally, this reflects that resource allocation problems require precise modeling of resource capacity constraints to ensure feasible and optimal solutions.",
    "example": "# Wrong: Objective does not consider explicit resource constraints\n\\[ \\text{Maximize } (I_{L0} + x_L - D_L) + (I_{S0} + x_S - D_S) \\]\n\n# Correct: Include explicit machine time constraints\nfor m in machines:\n    model.addConstr(gp.quicksum(time_req[p][m] * Produce[p] for p in products) <= avail_machine_time[m], name=f\"Machine{m}_TimeLimit\")",
    "iteration": 0,
    "version": 1,
    "task_id": "B087",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 88,
    "taxonomy": {
      "Domain Modeling": {
        "Balancing": [
          "Load Balancing Constraints"
        ]
      }
    },
    "condition": "This insight applies when the problem description involves determining operational hours for multiple resources that should not exceed certain limits. For example, when the problem statement mentioned minimizing the time each factory is run while meeting production and resource constraints.",
    "explanation": "When the problem involves optimizing operational hours for resources that can run concurrently, the best practice is to apply constraints that ensure no resource runs excessively longer than others. A common mistake is not imposing any balancing constraints, which happens because the focus is on minimizing total time without considering the distribution across resources. More generally, this reflects that balancing workloads can prevent excessive utilization of individual resources.",
    "example": "# Wrong: Only minimize h_N + h_W\n# Correct: Add constraints like max_hour >= h_N, max_hour >= h_W",
    "iteration": 0,
    "version": 1,
    "task_id": "A236",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 89,
    "taxonomy": {
      "Domain Modeling": {
        "Resource Allocation": [
          "Capacity/Resource Balance Equations"
        ]
      }
    },
    "condition": "This insight applies when the problem domain requires resources to move or transform through nodes and local conservation must hold. For example, when the problem statement mentioned a plastic usage constraint, the failed mathematical model included this constraint but did not correctly account for the makespan objective that requires balancing resource usage across different factories in conjunction with operational hours.",
    "explanation": "When the problem involves managing resource allocation across different production units, the best practice is to ensure that resource usage aligns with production hours and capacity constraints. A common mistake is to apply capacity constraints without integrating them with the operational time objective, which happens because the interdependence between time and resource use is overlooked. More generally, this reflects that when resources and time are jointly constrained, a holistic approach that integrates both aspects is required.",
    "example": "# Wrong: 40x + 35y \u2264 60,000 without accounting for the makespan\n# Correct: Ensure resource usage constraint is aligned with the makespan objective using auxiliary variable max_hour.",
    "iteration": 0,
    "version": 1,
    "task_id": "A236",
    "occurrence": 0,
    "distribution": {
      "positive": [
        "A236"
      ],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 91,
    "taxonomy": {
      "General Formulation": {
        "Units Scaling": [
          "Unit Inconsistency"
        ]
      }
    },
    "condition": "This insight applies when input data come from different unit systems or incompatible measurement scales. For example, when the problem statement mentioned processing time constraints for products in hours per kg, or rates and costs of annotation companies compared hours with images, leading to unit inconsistency.",
    "explanation": "When the problem involves constraints with different units, the best practice is to ensure all terms are in compatible units. A common mistake is having inconsistent units within constraints, which happens because of oversight in unit conversion. More generally, this reflects that consistent unit usage is crucial for accurate constraint formulation.",
    "example": "# Wrong\n12x_{A1} + 8x_{A2} \\leq 480\n# Correct\n4 * x_A + 2 * x_B <= max_hours",
    "iteration": 0,
    "version": 1,
    "task_id": [
      "F131",
      "B092"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 95,
    "taxonomy": {
      "Domain Modeling": {
        "Production Planning": [
          "Inventory Balance Equations"
        ]
      }
    },
    "condition": "This insight applies when the problem description involves materials or products that carry over between periods and must satisfy stock-flow balance. For example, when the problem statement mentioned that the store has an initial stock of 200 units and can purchase or sell products each month, maintaining the inventory balance over time is crucial. This insight applies when the problem involves managing resources, such as inventory or workforce, over multiple periods with initial levels specified, and constraints on capacity or skill development, impacting demand and cost minimization. For example, when the problem statement mentions production scheduling or workforce training affecting production capacity and demand fulfillment. This insight does NOT apply when the problem involves static resource allocation without time-dependent constraints or inventory levels.",
    "explanation": "When the problem involves inventory levels that change over time due to purchases and sales, the best practice is to ensure that inventory balance equations correctly reflect the stock-flow relationship. A common mistake is to omit constraints that enforce sales to not exceed the available inventory, which happens because the model focuses only on purchase and sales quantities without ensuring feasibility of stock levels. More generally, this reflects that production planning problems require explicit tracking of inventory changes to maintain accurate stock levels.",
    "example": "# Wrong: Missing sales constraint\nI_1 = I_0 + x_1 - y_1\n\n# Correct: Include sales limitation\nI_1 = I_0 + x_1 - y_1\nmodel.addConstr(y_1 <= I_0 + x_1)",
    "iteration": 0,
    "version": 1,
    "task_id": "B015",
    "occurrence": 0,
    "distribution": {
      "positive": [
        "B087",
        "B015",
        "B049"
      ],
      "negative": [],
      "unretrieved": [
        "B066",
        "B000",
        "B049"
      ],
      "irrelevant": [],
      "invalid": [
        "B087"
      ]
    }
  },
  {
    "insight_id": 96,
    "taxonomy": {
      "Domain Modeling": {
        "Resource Allocation": [
          "Capacity/Resource Balance Equations"
        ]
      }
    },
    "condition": "This insight applies when the problem domain requires resources to move or transform through nodes and local conservation must hold. For example, in the given problem, the inventory must be balanced by considering both inflow (purchases) and outflow (sales) each month. This insight applies when resource allocation problems involve managing inventory levels with constraints on both the inflow and the capacity of the storage facility. For example, when the problem statement mentions a warehouse capacity limit and the need to balance initial stock, purchases, and sales to avoid exceeding this limit. This insight does NOT apply when optimizing production scheduling where resources are machines with fixed processing capacities and the objective is maximizing profit rather than maintaining resource levels or capacities. For example, when the problem statement mentions equipment processing times and capacities without inventory or balancing constraints.",
    "explanation": "When the problem involves resource allocation with capacity limits, the best practice is to ensure that inventory levels do not exceed warehouse capacity at any time. A common mistake is to ignore the constraint that limits the sum of initial stock and purchases to be within the warehouse capacity, which happens because the model may only focus on monthly end-of-period stock levels. More generally, this reflects that resource allocation models must account for both inflow and capacity constraints to maintain feasible operations.",
    "example": "# Wrong: Inventory capacity constraint only on end-period\nI_m <= C\n\n# Correct: Inventory capacity constraint on inflow as well\nmodel.addConstr(prev_inventory + x[t] <= 500)",
    "iteration": 0,
    "version": 1,
    "task_id": "B015",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [
        "B030"
      ],
      "unretrieved": [
        "B015",
        "B049",
        "B039"
      ],
      "irrelevant": [
        "E035"
      ],
      "invalid": []
    }
  },
  {
    "insight_id": 98,
    "taxonomy": {
      "Code Implementation": {
        "Data I/O & Validation": [
          "KeyError & Index Mismatch"
        ]
      }
    },
    "condition": "This insight applies when the mathematical model contains constraints with index ranges that should match the problem's formulation scope. For example, when the formulation included inventory balance constraints for periods 1 to 3, the range should be from 1 to 3.",
    "explanation": "When the problem involves iterating over a set of indices in constraints. The best practice is to ensure the index range matches the intended scope. A common mistake is iterating over an incorrect range, which happens because of a misunderstanding of the problem's scope or off-by-one errors. More generally, this reflects that precise index range alignment is crucial for correctly implementing mathematical constraints.",
    "example": "# Wrong\nmodel.addConstrs((I[m] == I[m-1] + x[m] - y[m] for m in range(1, 4)), \"Inventory_Balance\")\n\n# Correct\nmodel.addConstrs((I[m] == I[m-1] + x[m-1] - y[m-1] for m in range(1, 4)), \"Inventory_Balance\")",
    "iteration": 0,
    "version": 1,
    "task_id": "B015",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 99,
    "taxonomy": {
      "Domain Modeling": {
        "Production Planning": [
          "Inventory Balance Equations"
        ]
      }
    },
    "condition": "This insight applies when the problem description involves materials or products that carry over between periods and must satisfy stock-flow balance. For example, when the problem statement mentioned tracking inventory of products purchased and sold each month to ensure the warehouse capacity is not exceeded.",
    "explanation": "When the problem involves tracking inventory over time, the best practice is to accurately represent the inventory balance equation, ensuring that inventory at the end of each period is accounted for based on the previous inventory, purchases, and sales. A common mistake is to misrepresent this balance, which happens because the formulation might not correctly reflect the flow of goods over time. More generally, this reflects that inventory management problems require precise formulation of stock-flow equations to maintain feasibility and optimize objectives.",
    "example": "# Wrong: I_m = I_{m-1} + x_m - y_m for each month m\n# Correct: Ensure this equation is accurately coded and constraints correctly applied in the optimizer.",
    "iteration": 0,
    "version": 1,
    "task_id": "B049",
    "occurrence": 0,
    "distribution": {
      "positive": [
        "B015",
        "B049"
      ],
      "negative": [
        "B066",
        "B049"
      ],
      "unretrieved": [],
      "irrelevant": [
        "B087"
      ],
      "invalid": [
        "B000",
        "B087"
      ]
    }
  },
  {
    "insight_id": 100,
    "taxonomy": {
      "General Formulation": {
        "Variable Definition": [
          "Explicit Bounds"
        ]
      }
    },
    "condition": "This insight applies when the problem description provides natural physical, economic, or logical limits that can tightly bound decision variables. This insight applies when resources or capacities have explicit limits that can be used to bound decision variables. For example, when the problem statement mentions carrying capacities, percentage constraints, or time constraints that align with this insight. This insight does NOT apply when decision-making focuses on choices rather than explicit bounds, or when objectives, not explicit constraints, naturally limit decision variables.",
    "explanation": "When the problem involves bounded resources or capacities, the best practice is to set explicit bounds on variables to improve solver performance and prevent infeasibility. A common mistake is to omit these bounds, which happens because the model may rely on constraints alone to enforce limits, potentially leading to suboptimal solutions. More generally, this reflects that explicit bounds enhance the solver's ability to prune the search space effectively.",
    "example": "# Wrong: x_m, y_m, I_m defined without explicit upper bounds\n# Correct: x_m <= C, y_m <= I_{m-1} + x_m, I_m <= C",
    "iteration": 0,
    "version": 1,
    "task_id": "B049",
    "occurrence": 0,
    "distribution": {
      "positive": [
        "B058",
        "B081",
        "B031",
        "B049",
        "F103",
        "B016",
        "B039"
      ],
      "negative": [
        "B062",
        "A240",
        "B064"
      ],
      "unretrieved": [
        "B062",
        "F102",
        "A092",
        "B087"
      ],
      "irrelevant": [
        "B096",
        "F163",
        "A136",
        "F057",
        "F047",
        "F140",
        "F103",
        "A093",
        "F167",
        "A223",
        "B016",
        "B019",
        "B030",
        "B066",
        "B039",
        "B006",
        "E017",
        "E005",
        "A235",
        "B058",
        "A033",
        "A179",
        "A172",
        "F091",
        "A146",
        "F203",
        "F122",
        "F102",
        "A083",
        "A176",
        "A104",
        "F019",
        "F021",
        "A084",
        "B031",
        "B023"
      ],
      "invalid": [
        "A172",
        "F152",
        "B087",
        "B015",
        "E033",
        "E025",
        "A223",
        "B080",
        "B021",
        "B000",
        "B049",
        "B033"
      ]
    }
  },
  {
    "insight_id": 101,
    "taxonomy": {
      "Domain Modeling": {
        "Resource Allocation": [
          "Set-Partitioning/Assignment"
        ]
      }
    },
    "condition": "This insight applies when the problem description requires choosing between mutually exclusive options. For example, the company wants to choose only one of the van or electric vehicle for transport.",
    "explanation": "When the problem involves mutually exclusive choices, the best practice is to use binary variables to enforce exclusivity. A common mistake is to use constraints that do not explicitly enforce this exclusivity, which happens because the modeler may rely on indirect logical constraints. More generally, this reflects that mutually exclusive choices should be directly modeled using binary decision variables to ensure clarity and correctness.",
    "example": "# Wrong: Logical constraints without explicit exclusivity.\nx_V \\leq 1000 \\cdot (1 - y_{VE})\nx_E \\leq 1000 \\cdot y_{VE}\n\n# Correct: Use binary variables for exclusivity.\nm.addConstr(y_V + y_E <= 1, name=\"ModeChoice\")",
    "iteration": 0,
    "version": 1,
    "task_id": "B023",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [
        "B062"
      ],
      "invalid": [
        "B023"
      ]
    }
  },
  {
    "insight_id": 103,
    "taxonomy": {
      "Domain Modeling": {
        "Resource Allocation": [
          "Fixed Charge (Big-M Linking)"
        ]
      }
    },
    "condition": "This insight applies when the problem description specifies that a particular mode of transportation must be chosen exclusively between two options, such as choosing only one between van and electric vehicle. For example, when the problem statement mentioned that the company wants to choose only one of the van or electric vehicle options.",
    "explanation": "When the problem involves a choice between two exclusive options, the best practice is to use a binary variable to enforce this choice and link it with constraints using a Big-M approach. A common mistake is failing to enforce mutual exclusivity properly, which happens because the constraints do not correctly prevent both options from being selected simultaneously. More generally, this reflects that the Fixed Charge (Big-M Linking) technique is essential in problems where the activation of certain options depends on binary decisions.",
    "example": "# Wrong\nx_van <= M * y_van_or_electric\nx_electric <= M * (1 - y_van_or_electric)\n\n# Correct\nx_van <= M * y_V\nx_electric <= M * y_E\ny_V + y_E = 1",
    "iteration": 0,
    "version": 1,
    "task_id": "B023",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 105,
    "taxonomy": {
      "Domain Modeling": {
        "Resource Allocation": [
          "Capacity/Resource Balance Equations"
        ]
      }
    },
    "condition": "This insight applies when the problem domain requires resources to move or transform through nodes and local conservation must hold. For example, when the problem statement mentioned the need to ensure the minimum number of waiters is met in each time period.\nThis insight applies when scheduling resources to meet specific time-based demands and ensuring minimum resource levels for each interval. For example, when the problem statement mentions needing to schedule waiters for specific time periods to meet a minimum number required in each shift, considering constraints such as continuous working hours.\nThis insight does NOT apply when the problem involves multiple resource types with differing efficiencies and training dynamics that violate local conservation principles. For example, when there are distinct production rates and training constraints for workers.",
    "explanation": "When the problem involves ensuring minimum resources are available in each time period, the best practice is to construct constraints that explicitly cover the demand using available resources. A common mistake is to include unnecessary terms or overlook the correct coverage of demands, which happens because of misalignment between variable indices and the periods they should cover. More generally, this reflects that resource balance equations must be carefully constructed to ensure local conservation across nodes or time periods.",
    "example": "# Wrong\nx_2 + x_3 + x_4 + x_5 + x_6 + x_{22} + x_{23} + x_{24} >= 4\n\n# Correct\nx[5] + x[0] >= demands[0]",
    "iteration": 0,
    "version": 1,
    "task_id": "B082",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [
        "B000"
      ],
      "unretrieved": [
        "B082"
      ],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 107,
    "taxonomy": {
      "Domain Modeling": {
        "Resource Allocation": [
          "Set-Partitioning/Assignment"
        ]
      }
    },
    "condition": "This insight applies when the problem description requires each raw steel bar to be cut into one of several predefined patterns to meet the demand for finished products. For example, when the problem statement mentioned cutting raw steel bars of 10 meters into combinations of 3-meter and 4-meter bars.",
    "explanation": "When the problem involves cutting stock with predefined patterns, the best practice is to use a set-partitioning or assignment approach to allocate each raw material to exactly one cutting pattern. A common mistake is to not define the decision variables according to these patterns, which happens because the model does not fully capture the exclusive assignment of raw steel bars to specific cutting patterns. More generally, this reflects that set-partitioning is essential when tasks must be exclusively assigned to one choice among many.",
    "example": "# Wrong: \n\\[ \\text{Minimize} \\quad \\sum_{i=0}^{3} \\sum_{j=0}^{2} x_{ij} \\] \n\n# Correct: \nmodel.setObjective(gp.quicksum(x[p_id] for p_id in pattern_ids), GRB.MINIMIZE)",
    "iteration": 0,
    "version": 1,
    "task_id": "B068",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 111,
    "taxonomy": {
      "General Formulation": {
        "Variable Definition": [
          "Redundant Auxiliary Variables"
        ]
      }
    },
    "condition": "This insight applies when auxiliary variables or unnecessary terms are introduced in the objective function formulation, which do not add modeling value or contribute to the optimization task. For example, when the problem statement involves maximizing flow and the objective uses a summation that can be directly derived from conservation principles, or when minimizing the total number of trips includes unnecessary terms.",
    "explanation": "When the problem involves setting an objective function, the best practice is to avoid introducing redundant variables or terms that do not simplify or clarify the model. A common mistake is to define auxiliary variables or incorporate terms that are not necessary, which happens because they complicate the model without providing additional insight or constraint. More generally, this reflects that model clarity and simplicity should be prioritized when formulating objectives.",
    "example": "# Wrong: Objective: Maximize \\( \\sum_{i \\in N} f_{i7} \\)\n# Correct: Directly use flow balance: Maximize \\( F \\)",
    "iteration": 0,
    "version": 1,
    "task_id": [
      "E064",
      "B023"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 112,
    "taxonomy": {
      "Domain Modeling": {
        "Network Flow": [
          "Max-Flow Objective"
        ]
      }
    },
    "condition": "This insight applies when the problem description requires maximizing throughput between designated source and sink nodes. For example, when the problem statement mentioned maximizing the flow from Data Center 0 to Data Center 7.",
    "explanation": "When the problem involves maximizing flow in a network, the objective should directly reflect the total flow from the source to the sink node. The best practice is to set the objective function to maximize the total flow reaching the sink. A common mistake is to incorrectly specify the objective, such as including unnecessary terms that do not contribute to the flow into the sink, which happens because the focus is not maintained on the flow reaching the destination. More generally, this reflects that the objective function in max-flow problems should precisely capture the flow into the sink.",
    "example": "# Wrong\n\\text{Maximize } \\sum_{j=0}^{N-1} f_{Sj} - \\sum_{i=0}^{N-1} f_{iS}\n\n# Correct\nmodel.setObjective(gp.quicksum(flow[i, 7] for i in N if (i, 7) in capacities), GRB.MAXIMIZE)",
    "iteration": 0,
    "version": 1,
    "task_id": [
      "E064"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 113,
    "taxonomy": {
      "General Formulation": {
        "Variable Definition": [
          "Indexing & Data Structure Alignment"
        ]
      }
    },
    "condition": "This insight applies when variables are indexed over sets or dictionaries that must align with the keys of the provided data. For example, when the problem statement defined flow variables indexed over data center connections that need to match the capacity matrix indices.",
    "explanation": "When the problem involves defining variables over a network, indices must align with the data structure used to represent parameters like capacities. The best practice is to ensure variable indices match the keys or indices of the parameter matrix. A common mistake is misalignment of indices, leading to KeyErrors or incorrect interpretation of constraints, which happens because the indices are not consistently applied across variables and parameters. More generally, this reflects that careful alignment of indices is essential for coherent formulation and data handling in optimization problems.",
    "example": "# Wrong\nflow = model.addVars(N, N, lb=0, ub=capacities, name=\"flow\")\n\n# Correct\nflow = model.addVars(capacities.keys(), lb=0, ub=capacities, name=\"flow\")",
    "iteration": 0,
    "version": 1,
    "task_id": "E064",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [
        "B058",
        "E035",
        "B099"
      ],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 115,
    "taxonomy": {
      "Domain Modeling": {
        "Network Flow": [
          "Max-Flow Objective"
        ]
      }
    },
    "condition": "This insight applies when the problem description requires maximizing throughput between designated source and sink nodes. For example, when the problem statement mentions computing the maximum amount of electricity that can be distributed from the Power Plant (Node 0) to the Final Distribution Center (Node 7). This insight applies when the problem description requires maximizing a bottleneck flow along a path between designated source and sink nodes, particularly where the flow along the path is defined by the smallest capacity on that path. For example, when the problem statement mentions finding a path from node A to node E that passes through node C, with the link's capacity defined by the minimum bandwidth along the path. This insight does NOT apply when the problem involves network flow with multiple paths and nodes, requiring distribution and network analysis rather than a single-source single-sink direct flow maximization. For example, when the problem statement mentions determining the maximum cargo flow through a transportation network with multiple hubs, each with its own capacity constraints and interconnections.",
    "explanation": "When the problem involves maximizing the flow from a source to a sink, the best practice is to directly maximize the outflow from the source or inflow to the sink. A common mistake is to subtract the sink inflow from the source outflow in the objective, which happens because this formulation incorrectly assumes a net flow balance rather than a straightforward maximization. More generally, this reflects that the objective should focus on maximizing the desired throughput directly rather than involving unnecessary terms.",
    "example": "# Wrong\n\\text{Maximize } \\sum_{j \\in N} f_{0j} - \\sum_{i \\in N} f_{i7}\n\n# Correct\nmodel.setObjective(sum(flow[i, 7] for i in N if (i, 7) in C), GRB.MAXIMIZE)",
    "iteration": 0,
    "version": 1,
    "task_id": "E068",
    "occurrence": 0,
    "distribution": {
      "positive": [
        "E061"
      ],
      "negative": [
        "E068",
        "E071",
        "E056",
        "E057",
        "E066",
        "E052",
        "E059",
        "E053"
      ],
      "unretrieved": [
        "B099"
      ],
      "irrelevant": [
        "B099"
      ],
      "invalid": [
        "E103"
      ]
    }
  },
  {
    "insight_id": 117,
    "taxonomy": {
      "Code Implementation": {
        "Data I/O & Validation": [
          "Matrix Dimension Mismatch"
        ]
      }
    },
    "condition": "This insight applies when the mathematical model contains matrices or arrays that define bounds or parameters for variables, and these must be dimensionally compatible with the variable definitions. For example, when the formulation included an upper bound matrix for flow variables that must match the dimensionality of the node pairs.",
    "explanation": "When the problem involves defining variable bounds with matrices. The best practice is to ensure that the matrix dimensions align with the variable indices. A common mistake is to use a scalar or an incorrectly dimensioned matrix as bounds, which happens because the programmer assumes uniformity across dimensions without checking compatibility. More generally, this reflects that correct data structure dimensions are crucial for model validity.",
    "example": "# Wrong\nf = model.addVars(N, N, lb=0, ub=gp.quicksum(C[i][j] for i in N for j in N), vtype=GRB.CONTINUOUS, name='f')\n\n# Correct\nf = model.addVars(N, N, lb=0, ub=C, vtype=GRB.CONTINUOUS, name='f')",
    "iteration": 0,
    "version": 1,
    "task_id": "E068",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 118,
    "taxonomy": {
      "Domain Modeling": {
        "Network Flow": [
          "Flow Conservation"
        ]
      }
    },
    "condition": "This insight applies when the problem description involves quantities traversing a directed network and nodal balance must be maintained. For example, when the problem statement mentioned optimizing the digital traffic flow in a network of relay stations with specified capacities or a network of tunnels with electricity flowing between nodes and required flow conservation at each node.",
    "explanation": "When the problem involves optimizing flow through a network, the best practice is to ensure that flow conservation constraints are correctly formulated for all nodes except the source and destination. A common mistake is failing to properly differentiate between source, sink, and intermediary nodes, which happens because the nodal balance conditions are not correctly maintained. More generally, this reflects that accurate identification and application of flow conservation principles are crucial in network flow problems.",
    "example": "# Wrong: \n\\( \\sum_{j \\in V} f_{ij} = \\sum_{k \\in V} f_{ki} \\) for every node including source and destination.\n\n# Correct: \n\\( \\sum_{j \\in V} f_{ij} = \\sum_{k \\in V} f_{ki} \\) for every node \\( i \\neq 0 \\) and \\( i \\neq 7 \\).",
    "iteration": 0,
    "version": 1,
    "task_id": [
      "E055",
      "E068"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 119,
    "taxonomy": {
      "Domain Modeling": {
        "Network Flow": [
          "Max-Flow Objective"
        ]
      }
    },
    "condition": "This insight applies when the problem description requires maximizing throughput between designated source and sink nodes. For example, when the problem statement mentioned finding the maximum data flow from Station 0 to Station 7. This insight applies when the problem description involves calculating the maximum flow from a source node to a sink node in a network, and the objective function needs to directly capture the net flow from the source or into the sink. For example, when the problem statement mentions finding the maximum amount of resources that can be transported from the Central Supply Hub (Sector 0) to the Farthest Outpost (Sector 8) per Martian day, ensuring each transport tube's flow does not exceed its capacity.",
    "explanation": "When the problem involves maximizing flow through a network, the best practice is to set the objective to maximize the flow from the source to the sink. A common mistake is failing to properly set up the objective function to reflect the maximum flow, which happens because the objective does not directly capture the net flow out of the source or into the sink. More generally, this reflects that correctly formulating the objective function is crucial for achieving the desired optimization goal in network flow problems.",
    "example": "# Wrong:\n\\( \\max \\sum_{j \\in V} f_{0j} - \\sum_{i \\in V} f_{i0} \\)\n\n# Correct:\nmodel.setObjective(gp.quicksum(flow[0, j] for j in V if (0, j) in E), GRB.MAXIMIZE)",
    "iteration": 0,
    "version": 1,
    "task_id": "E055",
    "occurrence": 0,
    "distribution": {
      "positive": [
        "E103"
      ],
      "negative": [
        "E057",
        "E067"
      ],
      "unretrieved": [
        "E061"
      ],
      "irrelevant": [
        "B099"
      ],
      "invalid": [
        "E052",
        "E053"
      ]
    }
  },
  {
    "insight_id": 121,
    "taxonomy": {
      "Code Implementation": {
        "Solver & API Syntax": [
          "Variable Bounds Specification"
        ]
      }
    },
    "condition": "This insight applies when the mathematical model contains variables requiring specified upper bounds. For example, when the formulation included flow variables with upper bounds determined by the problem constraints.",
    "explanation": "When the problem involves defining upper bounds for decision variables. The best practice is to specify variable bounds as constants or pre-computed values. A common mistake is using expressions that evaluate to non-real numbers, which happens because solvers expect numerical bounds, not expressions that require further evaluation. More generally, this reflects that solvers require explicit numerical parameters for variable bounds to ensure model feasibility and correctness.",
    "example": "# Wrong: flow = model.addVars(N, N, lb=0, ub=gp.quicksum(gp.quicksum(C[i][j] for j in range(N)) for i in range(N)), vtype=GRB.CONTINUOUS, name='f')\n# Correct: flow = model.addVars(N, N, lb=0, ub=GRB.INFINITY, vtype=GRB.CONTINUOUS, name='f')",
    "iteration": 0,
    "version": 1,
    "task_id": "E055",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 122,
    "taxonomy": {
      "Domain Modeling": {
        "Network Flow": [
          "Max-Flow Objective"
        ]
      }
    },
    "condition": "This insight applies when the problem description requires maximizing throughput between designated source and sink nodes. For example, when the problem statement mentioned the objective to compute the maximum energy that can be transmitted from Substation 0 (the source) to Substation 7 (the destination) per time unit.",
    "explanation": "When the problem involves maximizing the flow from a source node to a destination node in a network, the best practice is to set the objective function to directly maximize the flow on the arcs leading into the sink node (or out of the source node if symmetric). A common mistake is to incorrectly formulate the objective in terms of net flow at the sink node without proper balancing, which happens because it might neglect the fact that flow into the sink should equal flow out of the source. More generally, this reflects that the objective should clearly and directly represent the quantity to be maximized in network flow problems.",
    "example": "# Wrong: Maximize the net flow into the destination as `sum(f_ij for i in N) - sum(f_ji for j in N)`\n# Correct: Maximize the flow into the destination as `sum(flow[i, 7] for i in N if (i, 7) in capacity)`",
    "iteration": 0,
    "version": 1,
    "task_id": "E059",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [
        "E057",
        "E059"
      ],
      "unretrieved": [],
      "irrelevant": [
        "E061",
        "B099"
      ],
      "invalid": []
    }
  },
  {
    "insight_id": 125,
    "taxonomy": {
      "Code Implementation": {
        "Solver & API Syntax": [
          "Quicksum vs. sum Syntax"
        ]
      }
    },
    "condition": "This insight applies when the mathematical model contains linear expressions aggregated over large index sets that should be constructed using solver-native summation operators. For example, when the formulation included flow variables across a network with capacity constraints, the use of `gp.quicksum()` ensures efficient construction of these expressions.",
    "explanation": "When the problem involves aggregating variables over multiple indices, such as in flow networks, the best practice is to use `gp.quicksum()` for expression construction. A common mistake is using Python's native `sum()`, which happens because users may not be aware of solver-specific optimizations for large-scale models. More generally, this reflects that efficient model construction requires leveraging solver-native operations to handle large index sets.",
    "example": "# Wrong\nflow = model.addVars(N, N, lb=0, ub=gp.quicksum(capacities[i, j] for i, j in capacities if i != j), name=\"flow\")\n\n# Correct\nflow = model.addVars(N, N, lb=0, ub=capacities, name=\"flow\")",
    "iteration": 0,
    "version": 1,
    "task_id": "E071",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 126,
    "taxonomy": {
      "General Formulation": {
        "Variable Definition": [
          "Indexing & Data Structure Alignment"
        ]
      }
    },
    "condition": "This insight applies when the mathematical model contains indexed variables or parameters that are accessed with indices not present in the corresponding data structures. For example, when defining capacities as a dictionary and attempting to use it as an upper bound, ensuring that the indices match the intended pairs is crucial.",
    "explanation": "When the problem involves using indexed parameters, such as capacities in a network, the best practice is to ensure all indices are valid and present in the data structure. A common mistake is accessing a non-existent entry, which happens because indices may be incorrectly specified or assumed. More generally, this reflects that careful validation of indices and data access is essential to prevent runtime errors and incorrect model formulations.",
    "example": "# Wrong\nflow = model.addVars(N, N, lb=0, ub=gp.quicksum(capacities[i, j] for i, j in capacities if i != j), name=\"flow\")\n\n# Correct\nflow = model.addVars(N, N, lb=0, ub=capacities, name=\"flow\")",
    "iteration": 0,
    "version": 1,
    "task_id": [
      "E059",
      "E071"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 128,
    "taxonomy": {
      "Domain Modeling": {
        "Network Flow": [
          "Max-Flow Objective"
        ]
      }
    },
    "condition": "This insight applies when the problem description requires maximizing throughput between designated source and sink nodes. For example, when the problem statement mentioned maximizing the amount of data transferred from Station 0 to Station 6.",
    "explanation": "When the problem involves maximizing flow from a source node to a sink node, the best practice is to set the objective to maximize the flow leaving the source minus the flow entering the source. A common mistake is to maximize only the flow into the sink, which happens because it can overlook flow conservation constraints. More generally, this reflects that correctly setting the objective is crucial for network flow problems.",
    "example": "# Wrong\n\\text{Maximize } \\sum_{i \\in N} f_{i6} \n\n# Correct\nmodel.setObjective(gp.quicksum(f[0, j] for j in V) - gp.quicksum(f[i, 0] for i in V), GRB.MAXIMIZE)",
    "iteration": 0,
    "version": 1,
    "task_id": "E056",
    "occurrence": 0,
    "distribution": {
      "positive": [
        "E056"
      ],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [
        "E061",
        "B099"
      ],
      "invalid": []
    }
  },
  {
    "insight_id": 129,
    "taxonomy": {
      "Domain Modeling": {
        "Network Flow": [
          "Flow Conservation"
        ]
      }
    },
    "condition": "This insight applies when the problem description involves quantities traversing a directed network and nodal balance must be maintained. For example, when the problem statement specified flow conservation constraints for intermediate hubs or stations in the network, except for the source and sink nodes.",
    "explanation": "When the problem involves maintaining flow balance at nodes in a network, the best practice is to apply flow conservation constraints correctly for each node except the source and sink. A common mistake is to apply incorrect flow conservation at source or sink nodes, which happens because it can lead to incorrect flow distribution and suboptimal solutions. More generally, this reflects that in network flow problems, flow conservation must be correctly applied to ensure valid solutions.",
    "example": "# Wrong: \n\\sum_{j \\in N} f_{0j} - \\sum_{j \\in N} f_{j0} \\geq 0\n\n# Correct: \n\\sum_{j \\in N} f_{ij} = \\sum_{j \\in N} f_{ji}, \\quad \\forall i \\in N \\setminus \\{0, 5\\}",
    "iteration": 0,
    "version": 1,
    "task_id": [
      "E056",
      "E059",
      "E053"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 130,
    "taxonomy": {
      "General Formulation": {
        "Variable Definition": [
          "Indexing & Data Structure Alignment"
        ]
      }
    },
    "condition": "This insight applies when variables are indexed over sets or dictionaries that must align with the keys of the provided data. For example, when the problem statement defines capacities for specific pairs of hubs and the model must ensure that flow variables match these indices.",
    "explanation": "When the problem involves indexing variables over sets, the best practice is to ensure variable indices align with parameter keys to avoid errors. A common mistake is misalignment of indices, which happens because it can cause KeyErrors or incorrect variable referencing in mathematical models or code implementations. More generally, this reflects that careful alignment of indices is crucial for the accurate formulation of optimization models.",
    "example": "# Wrong: \nf = model.addVars(N, N, name='f', lb=0)\n\n# Correct: \nf = model.addVars(c.keys(), name='f', lb=0)",
    "iteration": 0,
    "version": 1,
    "task_id": "E053",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 131,
    "taxonomy": {
      "Domain Modeling": {
        "Network Flow": [
          "Flow Conservation"
        ]
      }
    },
    "condition": "This insight applies when the problem description involves quantities traversing a directed network and nodal balance must be maintained. For example, when the problem statement requires determining the maximum cargo flow across a network of hubs where inflow and outflow at intermediate hubs should balance.\nThis insight applies when redistributing resources across a network with multiple nodes, each requiring a balance between supply and demand. For example, when the problem statement mentions optimal allocation of supplies among hospitals or warehouses with varying needs, ensuring all locations maintain a balance akin to flow conservation.\nThis insight does NOT apply when the problem involves single-source to single-sink maximum flow determination without intermediate nodal balance requirements. For example, when the problem statement specifies maximizing the flow from a source to a destination based solely on link capacities without requiring flow conservation at intermediate nodes.",
    "explanation": "When the problem involves a network flow, the best practice is to enforce flow conservation at each intermediate node, ensuring that the total inflow equals the total outflow. A common mistake is to relax the conservation constraint at intermediate nodes, which happens because of an oversight in ensuring flow continuity across the network. More generally, this reflects the necessity of maintaining flow balance in network flow formulations.",
    "example": "# Wrong: Relaxed flow conservation constraints\n\\sum_{j \\in H} f_{ij} - \\sum_{j \\in H} f_{ji} = 0, \\forall i \\in H \\setminus \\{0, 5\\}\n\n# Correct: Enforce flow conservation constraints\nmodel.addConstrs((gp.quicksum(f[i, j] for j in N) == gp.quicksum(f[j, i] for j in N) for i in N if i != 0 and i != 5), name=\"flow_conservation\")",
    "iteration": 0,
    "version": 1,
    "task_id": "E053",
    "occurrence": 0,
    "distribution": {
      "positive": [
        "E068",
        "E061",
        "E056",
        "E057",
        "E103",
        "E059",
        "E038"
      ],
      "negative": [
        "E071",
        "E066",
        "E052"
      ],
      "unretrieved": [
        "E038",
        "E035"
      ],
      "irrelevant": [
        "B006"
      ],
      "invalid": []
    }
  },
  {
    "insight_id": 132,
    "taxonomy": {
      "Domain Modeling": {
        "Network Flow": [
          "Flow Conservation"
        ]
      }
    },
    "condition": "This insight applies when the problem description involves quantities traversing a directed network where flow conservation must be maintained at each node. This insight applies when the problem involves calculating the maximum flow through a network or maximizing flow with intermediate nodes. This insight does NOT apply when the problem involves direct supply and demand balancing across multiple locations without intermediate nodes or a network structure requiring flow conservation.",
    "explanation": "When the problem involves a flow network, the best practice is to enforce flow conservation at all intermediate nodes, ensuring that the inflow equals outflow for these nodes. A common mistake is incorrectly defining or omitting flow conservation, which happens because the balance equations are not correctly applied, leading to infeasibility or suboptimal solutions. More generally, this reflects that nodal balance is essential for maintaining the integrity of flow in the network.",
    "example": "# Wrong: Flow conservation applied inconsistently\n\\sum_{j \\in N} f_{ij} - \\sum_{j \\in N} f_{ji} = 0, \\quad \\forall i \\in N, i \\neq 0, i \\neq 5\n\n# Correct: Consistent flow conservation at each intermediate node\nmodel.addConstrs((gp.quicksum(f[i, j] for j in N) == gp.quicksum(f[j, i] for j in N) for i in N if i != 0 and i != 5), name='flow_conservation')",
    "iteration": 0,
    "version": 1,
    "task_id": "E053",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [
        "E038"
      ],
      "unretrieved": [
        "E066",
        "E052",
        "E035"
      ],
      "irrelevant": [
        "E035"
      ],
      "invalid": []
    }
  },
  {
    "insight_id": 133,
    "taxonomy": {
      "Domain Modeling": {
        "Network Flow": [
          "Max-Flow Objective"
        ]
      }
    },
    "condition": "This insight applies when the problem description requires maximizing throughput between designated source and sink nodes. For example, when the problem statement mentioned maximizing the volume of goods transported from Node 0 to Node 8.\nThis insight applies when the problem requires maximizing flow from a source node to a sink node OR when it involves maximizing throughput from a source node to a sink node, ensuring capacity constraints and flow conservation are respected. For example, when the problem statement mentions calculating the maximum amount of resources that can be transported from a central node to a specific destination node.\nThis insight does NOT apply when the problem involves distributing resources from a source to multiple nodes and culminates at a final node that is not a single sink but rather an endpoint in a multi-destination network. For example, when the problem statement mentions determining the maximum volume of water that can be distributed from a central source to all other centers, culminating at a final node which represents an endpoint rather than a single sink.",
    "explanation": "When the problem involves maximizing the flow from a source to a sink in a network, the best practice is to directly maximize the net flow from the source to the sink. A common mistake is to maximize only the inflow to the sink without accounting for the outflow from the source, which happens because the formulation fails to ensure the flow conservation principle is respected at the source. More generally, this reflects that the objective should account for both source and sink in network flow problems.",
    "example": "# Wrong: Maximize inflow to the sink\n\\text{Maximize} \\quad \\sum_{i \\in N} f_{i8}\n\n# Correct: Maximize net flow from source to sink\nmodel.setObjective(gp.quicksum(flow[0, j] for j in nodes) - gp.quicksum(flow[i, 0] for i in nodes), GRB.MAXIMIZE)",
    "iteration": 0,
    "version": 1,
    "task_id": "E066",
    "occurrence": 0,
    "distribution": {
      "positive": [
        "E056",
        "E067"
      ],
      "negative": [
        "E071"
      ],
      "unretrieved": [
        "E061",
        "E066",
        "E052"
      ],
      "irrelevant": [
        "E057",
        "B099",
        "E103"
      ],
      "invalid": [
        "E068",
        "E103",
        "E053"
      ]
    }
  },
  {
    "insight_id": 134,
    "taxonomy": {
      "Domain Modeling": {
        "Network Flow": [
          "Flow Conservation"
        ]
      }
    },
    "condition": "This insight applies when the problem description involves quantities traversing a directed network and nodal balance must be maintained. For example, when the problem statement requires ensuring goods flow seamlessly through each node without exceeding capacities.",
    "explanation": "When the problem involves maintaining flow conservation in a network, the best practice is to apply flow conservation constraints at all nodes except the source and sink. A common mistake is to impose an unnecessary constraint at the source, which happens because it may incorrectly limit the total amount of flow that can be dispatched. More generally, this reflects that source and sink nodes should have special treatment in flow conservation formulations.",
    "example": "# Wrong: Source has an additional constraint\n\\sum_{j \\in N} f_{0j} \\leq \\sum_{j \\in N} C_{0j}\n\n# Correct: No additional constraint at source\nmodel.addConstrs((gp.quicksum(flow[i, j] for j in nodes) - gp.quicksum(flow[k, i] for k in nodes) == 0 for i in nodes if i not in [0, 8]), \"FlowConservation\")",
    "iteration": 0,
    "version": 1,
    "task_id": "E066",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [
        "E038"
      ],
      "invalid": []
    }
  },
  {
    "insight_id": 135,
    "taxonomy": {
      "Code Implementation": {
        "Solver & API Syntax": [
          "Variable Bounds Specification"
        ]
      }
    },
    "condition": "This insight applies when the mathematical model contains variable bounds defined by expressions that must be evaluated before the model is constructed. For example, when the formulation included variable bounds as the sum of capacities, which should be evaluated first.",
    "explanation": "When the problem involves setting variable bounds with pre-evaluated expressions. The best practice is to evaluate expressions before using them in variable definitions. A common mistake is to embed unevaluated expressions directly, which happens because the model expects numerical constants for bounds. More generally, this reflects that variable bounds should be numerically defined at the time of model construction.",
    "example": "# Wrong: flow = model.addVars(N, N, lb=0, ub=gp.quicksum(capacities[i][j] for i in N for j in N if i != j), name='flow')\n# Correct: flow = model.addVars(N, N, lb=0, ub=gp.quicksum(capacities[i][j] for i in N for j in N if i != j).getValue(), name='flow')",
    "iteration": 0,
    "version": 1,
    "task_id": "E066",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 136,
    "taxonomy": {
      "Domain Modeling": {
        "Network Flow": [
          "Flow Conservation"
        ]
      }
    },
    "condition": "This insight applies when the problem description involves quantities traversing a directed network and nodal balance must be maintained. For example, when the problem statement mentioned calculating the maximum amount of electricity that can be transmitted through a network of power stations and transmission lines.",
    "explanation": "When the problem involves quantities flowing through a network, the best practice is to apply flow conservation constraints at each node except for the source and sink. A common mistake is to incorrectly specify or omit these constraints, which happens because of misunderstanding the need to balance inflow and outflow at intermediate nodes. More generally, this reflects that proper network flow modeling requires accurate representation of flow conservation to ensure feasibility and optimality.",
    "example": "# Wrong: \n\\sum_{j \\in N} f_{ij} - \\sum_{j \\in N} f_{ji} = 0 \\quad \\forall i \\in N \\setminus \\{0, 7\\}\n\n# Correct: \nmodel.addConstrs((gp.quicksum(flow[i, j] for j in stations if (i, j) in capacities) - gp.quicksum(flow[k, i] for k in stations if (k, i) in capacities) == 0 for i in stations if i != 0 and i != 7), name=\"flow_conservation\")",
    "iteration": 0,
    "version": 1,
    "task_id": "E057",
    "occurrence": 0,
    "distribution": {
      "positive": [
        "E068",
        "E057"
      ],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 137,
    "taxonomy": {
      "Domain Modeling": {
        "Network Flow": [
          "Max-Flow Objective"
        ]
      }
    },
    "condition": "This insight applies when the problem description requires maximizing throughput between designated source and sink nodes. For example, when the problem statement specified the challenge as calculating the maximum amount of electricity that can be transmitted from Station 0 to Station 7.",
    "explanation": "When the problem involves maximizing flow from a source to a sink, the best practice is to correctly define the objective to maximize this throughput. A common mistake is to misformulate the objective by either maximizing inflow to the sink or outflow from the source without considering both, which happens because of overlooking the network's full flow dynamics. More generally, this reflects that the objective in a max-flow problem should accurately capture the total flow from the source to the sink.",
    "example": "# Wrong: \n\\text{Maximize } \\sum_{i \\in N} f_{i7}\n\n# Correct: \nmodel.setObjective(gp.quicksum(flow[0, j] for j in stations if (0, j) in capacities) - gp.quicksum(flow[i, 0] for i in stations if (i, 0) in capacities), GRB.MAXIMIZE)",
    "iteration": 0,
    "version": 1,
    "task_id": "E057",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [
        "E057"
      ],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": [
        "E068"
      ]
    }
  },
  {
    "insight_id": 138,
    "taxonomy": {
      "Domain Modeling": {
        "Network Flow": [
          "Source-Sink Flow Conservation"
        ]
      }
    },
    "condition": "This insight applies when the optimization task requires maximizing flow from a designated source node to a sink node, and the flow must be conserved at these nodes. For example, when the problem statement mentioned maximizing data transmission from Station 0 to Station 8.",
    "explanation": "When the problem involves maximizing flow from a source to a sink, the best practice is to explicitly model the flow balance at the source and sink to ensure that the net flow into the sink equals the net flow out of the source. A common mistake is to omit these explicit constraints, which happens because the model may incorrectly assume flow conservation is naturally maintained by other constraints. More generally, this reflects that source and sink nodes often require special treatment to ensure correct flow conservation in network flow models.",
    "example": "# Wrong\n\\sum_{j \\in N} f_{0j} - \\sum_{j \\in N} f_{j0} = \\sum_{j \\in N} f_{0j}\n\n# Correct\n\\sum_{j \\in N} f_{0j} - \\sum_{j \\in N} f_{j0} = \\text{Net Flow from Source}\n\\sum_{j \\in N} f_{j8} - \\sum_{j \\in N} f_{8j} = \\text{Net Flow into Sink}",
    "iteration": 0,
    "version": 1,
    "task_id": "E052",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 140,
    "taxonomy": {
      "Domain Modeling": {
        "Network Flow": [
          "Flow Conservation"
        ]
      }
    },
    "condition": "This insight applies when the problem description involves quantities traversing a directed network and nodal balance must be maintained. For example, when the problem statement mentioned the need to relocate freight cars among regions, ensuring that all inflows and outflows are balanced at each region.",
    "explanation": "When the problem involves moving resources through a network with specific supply and demand at nodes, the best practice is to ensure flow conservation at each node, which means the sum of inflows minus outflows must equal the net supply or demand at that node. A common mistake is omitting these flow balance constraints, which happens because one might incorrectly assume that supply and demand constraints alone are sufficient. More generally, this reflects that proper flow conservation is vital for network flow problems to ensure feasible solutions that respect the movement of resources.",
    "example": "# Wrong: No explicit flow balance constraint\nx_ij \u2265 0, \u2200 i, j \u2208 R, i \u2260 j\n\n# Correct: Include flow conservation\n\u2211_{j \u2208 R, j \u2260 i} x_{ij} - \u2211_{j \u2208 R, j \u2260 i} x_{ji} = supply[i] - demand[i], \u2200 i \u2208 R",
    "iteration": 0,
    "version": 1,
    "task_id": "E107",
    "occurrence": 0,
    "distribution": {
      "positive": [
        "E035"
      ],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 141,
    "taxonomy": {
      "General Formulation": {
        "Units Scaling": [
          "Unit Inconsistency"
        ]
      }
    },
    "condition": "This insight applies when input data come from different unit systems or incompatible measurement scales. For example, when the problem statement includes supply and demand values for car relocations, but the constraints are not consistently formulated in terms of net transfer of cars across regions. This insight applies when input data involve different unit systems or when constraints require consistent measurement across various resources and outputs. For example, when the problem statement includes resource consumption and production values for different commodities, such as steel and engines, but the units in constraints (like labor or currency) need alignment to ensure coherent application across these metrics.",
    "explanation": "When the problem involves integrating data from multiple sources or unit systems, the best practice is to ensure consistent units across all variables, parameters, and constraints. A common mistake is failing to align these scales, which happens because of oversight or misalignment in data preparation. More generally, this reflects that maintaining unit consistency is crucial to avoid misinterpretations and errors in optimization models.",
    "example": "# Wrong: Inconsistent unit application\n\u2211_{i \u2208 R, i \u2260 j} x_{ij} >= d_j, \u2200 j \u2208 R\n\n# Correct: Consistent unit application\n\u2211_{i \u2208 R, i \u2260 j} x_{ij} >= d_j - s_j, \u2200 j \u2208 R",
    "iteration": 0,
    "version": 1,
    "task_id": "E107",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [
        "B039"
      ],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 142,
    "taxonomy": {
      "Domain Modeling": {
        "Resource Allocation": [
          "Capacity/Resource Balance Equations"
        ]
      }
    },
    "condition": "This insight applies when the problem domain requires resources to move or transform through nodes and local conservation must hold. For example, when the problem statement mentioned ensuring the total number of cars moved out of a region equals the number of cars moved into it plus or minus the deficit or surplus.",
    "explanation": "When the problem involves balancing resource allocation across nodes, it is crucial to ensure that the balance equations are correctly specified. The best practice is to set the constraints such that the net flow into or out of each region matches the supply-demand balance. A common mistake is to incorrectly formulate these balance equations, which happens because of misunderstanding the net flow requirements. More generally, this reflects that resource balance equations must accurately capture the conservation of flow within a network context.",
    "example": "# Wrong: Balance constraints as written in the failed model\n\\[ \\sum_{j \\in N, j \\neq i} x_{ij} - \\sum_{j \\in N, j \\neq i} x_{ji} = S_i - D_i, \\quad \\forall i \\in N \\] \n\n# Correct: Balance constraints in the gold-standard program\nmodel.addConstrs((gp.quicksum(x[i, j] for j in R if i != j) == gp.quicksum(x[j, i] for j in R if j != i) + supply[i] - demand[i] for i in R), \"Balance\")",
    "iteration": 0,
    "version": 1,
    "task_id": "E107",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": [
        "B039"
      ]
    }
  },
  {
    "insight_id": 143,
    "taxonomy": {
      "Domain Modeling": {
        "Network Flow": [
          "Flow Conservation"
        ]
      }
    },
    "condition": "This insight applies when the problem description involves quantities traversing a directed network and nodal balance must be maintained. For example, when the problem statement mentioned establishing a link from node A to E through C with flow conservation constraints at each node. This insight applies when the problem involves finding a path through a directed network with considerations for flow conservation or capacity constraints. For example, when the problem statement mentions establishing a link between nodes like A and E through a specific node such as C, with the goal to maximize the minimum bandwidth across this path, ensuring flow continuity and capacity constraints are critical. This insight does NOT apply when the problem statement does not involve network flow or nodal balance, such as when dealing with static graphs or non-flow related constraints.",
    "explanation": "When the problem involves network flow, the best practice is to ensure that flow conservation is correctly modeled at all relevant nodes, particularly at nodes where flow enters and exits. A common mistake is incomplete or incorrect flow conservation constraints, which happens because the flow balance equations are not properly established or are missing for critical nodes. More generally, this reflects that flow conservation must account for all flow inputs and outputs at each node to ensure a feasible and correct solution.",
    "example": "# Wrong\nFrom A: \u2211_{j \u2208 N} x_{Aj} - \u2211_{i \u2208 N} x_{iA} = 1\nThrough C: \u2211_{j \u2208 N} x_{Cj} - \u2211_{i \u2208 N} x_{iC} = 0\nTo E: \u2211_{j \u2208 N} x_{Ej} - \u2211_{i \u2208 N} x_{iE} = -1\n\n# Correct\nFor all nodes except A and E: inflow - outflow = 0\nFor node A: outflow - inflow = 1\nFor node E: inflow - outflow = 1",
    "iteration": 0,
    "version": 1,
    "task_id": "B099",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [
        "B099"
      ],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 144,
    "taxonomy": {
      "Domain Modeling": {
        "Network Flow": [
          "Arc-capacity constraints"
        ]
      }
    },
    "condition": "This insight applies when the problem domain contains edges with maximum throughput or capacity limits. For example, when the problem requires maximizing the bandwidth between nodes, using the minimum bandwidth on the path as the objective, or when the problem statement specified the maximum units per day that each transport tube can carry.",
    "explanation": "When the problem involves network flow with arc capacities, the best practice is to correctly enforce arc-capacity constraints that limit the flow on each link by its bandwidth. A common mistake is failing to properly apply these constraints to ensure that the flow does not exceed the capacity of any arc, which happens because the constraints might be incorrectly formulated or applied. More generally, this reflects that arc-capacity constraints ensure that the solution respects the physical limits of the network.",
    "example": "# Wrong\nz \u2264 c_{ij} * x_{ij} for all i, j\n\n# Correct\nB_overall \u2264 bw_data[i][j] + max_possible_bandwidth * (1 - x[i, j])",
    "iteration": 0,
    "version": 1,
    "task_id": [
      "B099",
      "E061"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 146,
    "taxonomy": {
      "Domain Modeling": {
        "Network Flow": [
          "Flow Conservation"
        ]
      }
    },
    "condition": "This insight applies when the problem description involves quantities traversing a directed network and nodal balance must be maintained. For example, when the problem statement mentioned creating a path from node A to node E through node C, flow conservation must be maintained at all nodes except A, C, and E.\n\nThis insight applies when the problem involves finding a path through a network with specified start, intermediate, and end nodes, where the path must avoid loops and maintain flow conservation. For example, when the problem statement requires establishing a high-bandwidth link from node A to node E through node C, ensuring the path's feasibility involves maintaining flow conservation at all nodes except A, C, and E.\n\nThis insight does NOT apply when there are no intermediate nodes specified or when the network allows for loops without constraints on nodal balance. For example, when the problem statement suggests free traversal in a network without explicit direction or nodal constraints, this insight does not apply.",
    "explanation": "When the problem involves ensuring that flow is conserved at each node across a network, the best practice is to enforce flow conservation constraints at each node. A common mistake is neglecting to apply flow conservation constraints to intermediate nodes, which happens because the focus may overly emphasize start and end nodes. More generally, this reflects that in network flow problems, flow conservation is crucial for ensuring feasible paths that do not disconnect or loop excessively.",
    "example": "# Wrong\n\\sum_{i \\in N} x_{iB} = \\sum_{j \\in N} x_{Bj} \\quad \\forall B \\in N \\setminus \\{A, C, E\\} \n\n# Correct\nfor k in all_nodes:\n    if k != start_node and k != intermediate_node and k != end_node:\n        model.addConstr(gp.quicksum(x[i, k] for i in all_nodes if i != k) == gp.quicksum(x[k, j] for j in all_nodes if j != k), name=f\"FlowCons_x_{k}\")",
    "iteration": 0,
    "version": 1,
    "task_id": "B099",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [
        "B099"
      ],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 147,
    "taxonomy": {
      "General Formulation": {
        "Constraint Formulation": [
          "Big-M & Indicator Variables"
        ]
      }
    },
    "condition": "This insight applies when constraints depend on logical on/off conditions controlled by binary variables. For example, when the problem statement requires a path that considers bandwidth limits only if the path is chosen, or when van and electric vehicle usage are controlled by logical constraints.",
    "explanation": "When the problem involves constraints that should apply conditionally based on binary variables, the best practice is to use Big-M formulations to activate or deactivate constraints. A common mistake is failing to apply these formulations properly, which happens because the constraints may be applied unconditionally without being tied to the decision variables. More generally, this reflects that Big-M formulations are necessary to correctly model conditional constraints that depend on the selection of particular paths, arcs, or usage scenarios.",
    "example": "# Wrong\nz \\leq b_{ij} x_{ij} \\quad \\forall i, j \\in N\n\n# Correct\nfor i in all_nodes:\n    for j in all_nodes:\n        if i != j and bw_data[i][j] > 0:\n            model.addConstr(B_overall <= bw_data[i][j] + max_possible_bandwidth * (1 - x[i, j]), name=f\"B_limit_x_{i}_{j}\")",
    "iteration": 0,
    "version": 1,
    "task_id": [
      "B023",
      "B099"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 149,
    "taxonomy": {
      "Code Implementation": {
        "Solver & API Syntax": [
          "Quicksum vs. sum Syntax"
        ]
      }
    },
    "condition": "This insight applies when the mathematical model contains expressions that aggregate flows or similar quantities over subsets of indices using a summation operator. For example, when the formulation attempted to incorrectly define a flow conservation constraint using equal terms on both sides.",
    "explanation": "When the problem involves creating flow conservation constraints. The best practice is to ensure that each side of the equation represents distinct parts of the flow. A common mistake is using identical expressions on both sides, which happens because of misunderstanding the flow balance requirement. More generally, this reflects that modelers must accurately represent the distinct inflow and outflow components in balance equations.",
    "example": "# Wrong: model.addConstr(f[1, 2] + f[1, 3] == sum(f[i, j] for i, j in C_ij if i == 1), 'FlowConservation1')\n# Correct: model.addConstr(f[1, 2] + f[1, 3] == f[1, 2] + f[1, 3], 'FlowConservation1')",
    "iteration": 0,
    "version": 1,
    "task_id": "E102",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 150,
    "taxonomy": {
      "General Formulation": {
        "Variable Definition": [
          "Explicit Bounds"
        ]
      }
    },
    "condition": "This insight applies when the mathematical model contains decision variables that need to respect specific upper bounds based on parameters. For example, when the problem statement mentioned flow variables with upper bounds defined by edge capacities.",
    "explanation": "When the problem involves decision variables with specific upper bounds defined by parameters, the best practice is to specify bounds using a dictionary that maps each variable to its respective limit. A common mistake is using an aggregate expression, which happens because it applies the same upper bound to all variables. More generally, this reflects that variable bounds should be explicitly and individually defined to ensure model accuracy.",
    "example": "# Wrong: flow = model.addVars(E, name=\"f\", lb=0, ub=gp.quicksum(capacities.values()))\n# Correct: flow = model.addVars(E, name=\"f\", lb=0, ub={edge: capacities[edge] for edge in E})",
    "iteration": 0,
    "version": 1,
    "task_id": [
      "E103",
      "E064"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 151,
    "taxonomy": {
      "Domain Modeling": {
        "Network Flow": [
          "Max-Flow Objective"
        ]
      }
    },
    "condition": "This insight applies when the problem description requires maximizing throughput between designated source and sink nodes, where direct flow without intermediate routing complexities is the focus. For example, when the problem statement mentioned maximizing the flow from Node 1 to Node 4 without involving intermediate nodes. This insight does NOT apply when the problem involves multiple intermediate nodes with varying capacities between the source and sink, requiring consideration of flow distribution across these paths to achieve maximum flow. For example, when the problem statement describes a network with intermediate nodes (like nodes 2 and 3) and edges with different capacities, influencing how flow must be balanced to maximize throughput to the sink.",
    "explanation": "When the problem involves maximizing flow in a network, the best practice is to maximize the total flow explicitly from source to sink. A common mistake is to maximize the inflow to the sink without ensuring the flow from the source is also maximized, which happens because the objective may not correctly represent the problem's throughput maximization requirement. More generally, this reflects that the objective function must align with the problem's core requirement of maximizing flow from source to sink.",
    "example": "# Wrong: Maximize \u2211 f_{i4}\n# Correct: Maximize f_{24} + f_{34}",
    "iteration": 0,
    "version": 1,
    "task_id": "E101",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [
        "E103"
      ],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 152,
    "taxonomy": {
      "Domain Modeling": {
        "Network Flow": [
          "Flow Conservation"
        ]
      }
    },
    "condition": "This insight applies when the problem description involves quantities traversing a directed network and nodal balance must be maintained. For example, when intermediate nodes like Node 2 and Node 3 have incoming and outgoing flows that need to be balanced.\nThis insight applies when keywords like 'network flow', 'node balance', or 'directed graph' appear in the problem description.\nThis insight does NOT apply when the problem lacks any mention of network-related terminology, focusing instead on sequence or batch processing.",
    "explanation": "When the problem involves flow conservation at nodes, the best practice is to ensure that the sum of inflows equals the sum of outflows for each node, except for source and sink nodes. A common mistake is omitting necessary constraints, which happens because of incorrect or incomplete nodal flow balance equations. More generally, this reflects that each node in a network flow problem must adhere to flow conservation principles.",
    "example": "# Wrong: At Node 3, f_{13} + f_{23} = f_{34}\n# Correct: Also include Node 1 flow balance; Node 1: f_{12} + f_{13} = \u2211 f_{1j}",
    "iteration": 0,
    "version": 1,
    "task_id": "E101",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [
        "E103"
      ],
      "unretrieved": [],
      "irrelevant": [
        "E071",
        "E052"
      ],
      "invalid": [
        "E103"
      ]
    }
  },
  {
    "insight_id": 153,
    "taxonomy": {
      "Code Implementation": {
        "Solver & API Syntax": [
          "Expression Syntax for Constraints"
        ]
      }
    },
    "condition": "This insight applies when the mathematical model contains constraints, specifically when the model involves binary decision variables or flow conservation constraints requiring equalities. For example, when the formulation included binary variables or flow conservation equations for nodes.",
    "explanation": "When the problem involves constraint formulation, the best practice is to rely on the solver's variable type declarations and syntax to enforce constraints correctly. A common mistake is explicitly adding constraints to define behaviors already ensured by the solver's features, or passing terms as separate arguments. This happens because users may not fully trust or understand the solver's capabilities or syntax requirements. More generally, this reflects that modelers should leverage solver-native features to reduce redundancy and potential errors.",
    "example": "# Wrong: model.addConstrs((y[i] in [0, 1] for i in centers), name=\"BinaryDecision\")\n# Correct: # No need to add constraints, as y[i] is defined as binary.\n# Wrong: model.addConstr(flow[1, 2], GRB.EQUAL, flow[2, 3] + flow[2, 4], \"FlowConservationNode\")\n# Correct: model.addConstr(flow[1, 2] == flow[2, 3] + flow[2, 4], \"FlowConservationNode\")",
    "iteration": 0,
    "version": 1,
    "task_id": [
      "E082",
      "E101"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 157,
    "taxonomy": {
      "General Formulation": {  
        "Variable Definition": [
          "Indexing & Data Structure Alignment"
        ]
      }
    },
    "condition": "This insight applies when the mathematical model contains constraints that need to be expressed using generator expressions directly within constraint construction functions. For example, when the formulation included subtour elimination constraints ensuring variable bounds like `1 <= u[i] <= len(N) - 1` for all cities except the starting city.",
    "explanation": "When the problem involves adding constraints with generator expressions. The best practice is to clearly separate constraints for different bounds or conditions explicitly. A common mistake is attempting to combine multiple logical conditions into a single generator expression, which can lead to logical errors or solver misinterpretations. More generally, this reflects that constraints should be defined clearly and separately to ensure model clarity and correctness.",
    "example": "# Wrong:\nmodel.addConstrs((1 <= u[i] <= len(N) - 1 for i in N if i != 1), name=\"SubtourElimValid\")\n\n# Correct:\nmodel.addConstrs((u[i] >= 1 for i in N if i != 1), \"SubtourElimValidLower\")\nmodel.addConstrs((u[i] <= len(N) - 1 for i in N if i != 1), \"SubtourElimValidUpper\")",
    "iteration": 0,
    "version": 1,
    "task_id": [
      "E041"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 158,
    "taxonomy": {
      "Domain Modeling": {
        "Routing": [
          "Subtour Elimination Constraints"
        ]
      }
    },
    "condition": "This insight applies when the problem description allows decision variables to form disconnected cycles that must be eliminated. For example, in the Traveling Salesman Problem, where the salesperson must visit each city exactly once and return to the starting city, forming a complete tour without subtours. This insight applies when the problem involves any scenario requiring a complete tour visiting each node or location exactly once and returning to the starting point, necessitating subtour elimination. This insight does NOT apply when constraints inherently prevent subtours or when node visit constraints are specified to avoid disconnected cycles.",
    "explanation": "When the problem involves ensuring a single tour that visits each node exactly once, such as in the Traveling Salesman Problem, the best practice is to implement subtour elimination constraints to prevent disconnected cycles. A common mistake is failing to apply these constraints correctly, which happens because the model may allow for disconnected cycles or subtours that do not encompass all nodes. More generally, this reflects that effective routing models must incorporate constraints to prevent illegal cycles and ensure complete tours.",
    "example": "# Wrong: u_i - u_j + |N| x_{ij} <= |N| - 1 for all i, j in N, i \u2260 j\n# Correct: u[i] - u[j] + len(C) * x[i, j] <= len(C) - 1 for i, j in C, i \u2260 j and i \u2260 1 and j != 1",
    "iteration": 0,
    "version": 1,
    "task_id": [
      "E043",
      "E041",
      "B069"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [
        "E044",
        "E050"
      ],
      "unretrieved": [
        "E045",
        "E046",
        "E044",
        "E050"
      ],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 159,
    "taxonomy": {
      "General Formulation": {
        "Variable Definition": [
          "Indexing & Data Structure Alignment"
        ]
      }
    },
    "condition": "This insight applies when variables are indexed over sets or dictionaries that must align with the keys of the provided data. For example, when the problem statement involved defining variables for each pair of cities, which are represented in a dictionary of costs.",
    "explanation": "When the problem involves defining decision variables that correspond to indexed data, the best practice is to ensure that variable indices match the keys of the input data structures. A common mistake is misalignment between variable indices and data keys, which happens because of oversight in matching the structure of variables to the available data. More generally, this reflects that careful alignment is necessary to prevent errors and ensure the model accurately represents the problem data.",
    "example": "# Wrong: Defining variables without matching indices.\n# Correct: Defining variables with indices that align with cost dictionary keys.",
    "iteration": 0,
    "version": 1,
    "task_id": [
      "E043",
      "B069"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 160,
    "taxonomy": {
      "Code Implementation": {
        "Solver & API Syntax": [
          "Quicksum vs. sum Syntax"
        ]
      }
    },
    "condition": "This insight applies when the mathematical model contains linear expressions aggregated over large index sets that should be constructed using solver-native summation operators. For example, when the formulation included an objective to minimize travel costs across a network represented by a cost matrix and binary decision variables.",
    "explanation": "When the problem involves summing over large index sets or complex expressions. The best practice is to use `gp.quicksum()` to efficiently build linear expressions in Gurobi. A common mistake is using Python's `sum()`, which happens because users might not be aware of the efficiency benefits of solver-native methods. More generally, this reflects that leveraging solver-specific functions can lead to more efficient and error-free implementations.",
    "example": "# Wrong\nmodel.setObjective(sum(cost[i, j] * x[i, j] for i in N for j in N), GRB.MINIMIZE)\n\n# Correct\nmodel.setObjective(gp.quicksum(cost[i, j] * x[i, j] for i in N for j in N), GRB.MINIMIZE)",
    "iteration": 0,
    "version": 1,
    "task_id": "E042",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 161,
    "taxonomy": {
      "Code Implementation": {
        "Solver & API Syntax": [
          "Expression Syntax for Constraints"
        ]
      }
    },
    "condition": "This insight applies when the mathematical model contains indexed variables or parameters that are accessed with indices not present in the corresponding data structures. For example, when the formulation includes cost or parameter data in dictionary form, such as a cost matrix for a traveling salesman problem, where certain combinations of indices like self-loops (i.e., i == j) are not defined.",
    "explanation": "When the problem involves indexing cost or parameter data that may not include all possible combinations of indices. The best practice is to ensure that the indices used in expressions do not access undefined entries. A common mistake is to attempt to use a complete product of indices without excluding undefined combinations, which happens because the modeler assumes all index combinations are valid. More generally, this reflects that careful validation of index sets against data definitions is crucial.",
    "example": "# Wrong\nmodel.setObjective(gp.quicksum(cost[i, j] * x[i, j] for i in N for j in N), GRB.MINIMIZE)\n\n# Correct\nmodel.setObjective(gp.quicksum(cost[i, j] * x[i, j] for i in N for j in N if i != j), GRB.MINIMIZE)",
    "iteration": 0,
    "version": 1,
    "task_id": [
      "E042",
      "E102"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 162,
    "taxonomy": {
      "General Formulation": {
        "Constraint Formulation": [
          "Linearization of Non-linear Forms"
        ]
      }
    },
    "condition": "This insight applies when nonlinear relations among variables reduce tractability or solver performance. For example, when the problem statement involves truck capacity, each truck can carry up to 2 containers, requiring a linear relationship between containers and trucks.",
    "explanation": "When the problem involves a non-linear relationship, such as the number of containers per truck, the best practice is to linearize the constraints to maintain tractability. A common mistake is to directly model non-linear relationships, which happens because the need for linearization is overlooked. More generally, this reflects the necessity of transforming non-linear constraints into a linear form to ensure solvability by linear optimization tools.",
    "example": "# Wrong: x_{ij} = 2 * y_{ij} \n# Correct: x_{ij} \u2264 2 * y_{ij}",
    "iteration": 0,
    "version": 1,
    "task_id": "B006",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 163,
    "taxonomy": {
      "Code Implementation": {
        "Solver & API Syntax": [
          "Nonlinear Constraint Handling"
        ]
      }
    },
    "condition": "This insight applies when the mathematical model contains linear expressions within constraints that can be affected by unintended integer division. For example, when the formulation included a constraint intended to limit the number of trucks to an integer value but mistakenly used integer division on the linear expression `x[i, j] + 1`.",
    "explanation": "When the problem involves setting constraints on integer variables that should not be divided. The best practice is to ensure that all linear expressions within constraints are preserved without unintended division. A common mistake is using integer division on expressions, which happens because the developer misunderstands how integer division alters the expression. More generally, this reflects that constraints should maintain the intended mathematical relationship without unintended modifications.",
    "example": "# Wrong: model.addConstr(x[i, j] <= 2 * ((x[i, j] + 1) // 2), name=f\"TruckCapacity_{warehouses[i]}_{ports[j]}\")\n# Correct: model.addConstr(x[i, j] <= 2, name=f\"TruckCapacity_{warehouses[i]}_{ports[j]}\")",
    "iteration": 0,
    "version": 1,
    "task_id": "B006",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 164,
    "taxonomy": {
      "Code Implementation": {
        "Solver & API Syntax": [
          "Binary Constraint Handling"
        ]
      }
    },
    "condition": "This insight applies when the mathematical model contains binary decision variables that naturally take on values of 0 or 1. For example, when the formulation included binary variables y[i] for opening distribution centers.",
    "explanation": "When the problem involves binary decision variables, the best practice is to rely on the solver's inherent handling of binary constraints. A common mistake is adding redundant constraints like y[i] in [0, 1], which happens because users might mistakenly believe they need to explicitly enforce binary behavior. More generally, this reflects that solvers already account for variable types, and additional constraints can lead to unnecessary complexity.",
    "example": "# Wrong: model.addConstrs((y[i] in [0, 1] for i in I), name=\"BinaryConstraints\")\n# Correct: # No need to add explicit binary constraints, just define y as binary",
    "iteration": 0,
    "version": 1,
    "task_id": [
      "E084",
      "E075"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 167,
    "taxonomy": {
      "Domain Modeling": {
        "Resource Allocation": [
          "Capacity/Resource Balance Equations"
        ]
      }
    },
    "condition": "This insight applies when the problem domain requires resources to move or transform through nodes and local conservation must hold. For example, when the problem required a balance of raw materials used in candy production, but the failed model incorrectly integrated these balance equations.",
    "explanation": "When the problem involves the allocation of limited resources for production, the best practice is to use capacity/resource balance equations to ensure resources are conserved as they move through production stages. A common mistake is failing to maintain these balances, which happens because the model does not correctly account for all inputs and outputs at each stage. More generally, this reflects that ensuring resource balance is crucial when modeling resource allocation problems.",
    "example": "# Wrong: 0.6 * x_A + 0.15 * x_B <= L_A\n# Correct: R['RawA', 'CandyA'] + R['RawA', 'CandyB'] + R['RawA', 'CandyC'] <= L_A",
    "iteration": 1,
    "version": 1,
    "task_id": "B058",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 169,
    "taxonomy": {
      "General Formulation": {
        "Variable Definition": [
          "Explicit Bounds"
        ]
      }
    },
    "condition": "This insight applies when the problem description provides natural physical, economic, or logical limits that can tightly bound decision variables. For example, when the problem statement specified that Ben has 50 acres available, and must grow a minimum of 5 acres of apples and 10 acres of pears. This insight applies when the problem description involves constraints that can be represented as explicit bounds on decision variables, especially when there are physical, economic, or logical limits that restrict choices. For example, when the problem statement specifies the number of trips that must be taken with a horse or the pollution constraints limiting the number of trips for transportation methods. This insight does NOT apply when there are no explicit constraints or limits described in the problem statement.",
    "explanation": "When the problem involves physical or logical limits, the best practice is to explicitly define bounds for decision variables to enhance solver efficiency and accuracy. A common mistake is to omit these bounds, which happens because the implicit constraints are not translated into explicit variable bounds. More generally, this reflects that setting realistic bounds can prevent infeasible solutions and improve solver performance.",
    "example": "# Wrong: x_a \u2265 0, x_p \u2265 0\n# Correct: 5 \u2264 x_a \u2264 50, 10 \u2264 x_p \u2264 50",
    "iteration": 1,
    "version": 1,
    "task_id": "F152",
    "occurrence": 0,
    "distribution": {
      "positive": [
        "B081",
        "B039"
      ],
      "negative": [
        "B064"
      ],
      "unretrieved": [
        "B062"
      ],
      "irrelevant": [
        "B064",
        "B049",
        "F163"
      ],
      "invalid": [
        "F152",
        "A092"
      ]
    }
  },
  {
    "insight_id": 170,
    "taxonomy": {
      "Code Implementation": {
        "Solver & API Syntax": [
          "Strict Inequalities"
        ]
      }
    },
    "condition": "This insight applies when the mathematical model contains strict inequality relations between variables that cannot be directly handled by LP/MIP solvers. For example, when the formulation included a constraint that required the number of vans to be strictly greater than the number of minibuses, or required more cucumbers than potatoes, or a constraint like the number of electric jacks being less than a given value.",
    "explanation": "When the problem involves expressing strict inequalities in a mathematical model. The best practice is to reformulate the constraint to use non-strict inequalities, such as adding 1 to the right-hand side for integer variables. A common mistake is to directly implement strict inequalities, which happens because solvers like Gurobi do not support strict inequalities. More generally, this reflects that solvers require constraints to be expressed in a format they can process, typically using \u2264, =, or \u2265.",
    "example": "# Wrong\nmodel.addConstr(x_v > x_m, \"VansExceedMinibuses\")\n# Correct\nmodel.addConstr(x_v >= x_m + 1, \"VansExceedMinibuses\")\n\n# Wrong\nmodel.addConstr(x_c > x_p, \"MoreCucumbersThanPotatoes\")\n# Correct\nmodel.addConstr(x_c >= x_p + 1, \"MoreCucumbersThanPotatoes\")\n\n# Wrong\nmodel.addConstr(x_e < M_e, \"ElectricJacksLimit\")\n# Correct\nmodel.addConstr(x_e <= M_e - 1, \"ElectricJacksLimit\")",
    "iteration": 1,
    "version": 1,
    "task_id": [
      "F163",
      "A147",
      "A221"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 171,
    "taxonomy": {
      "Code Implementation": {
        "Solver & API Syntax": [
          "Nonlinear Constraint Handling"
        ]
      }
    },
    "condition": "This insight applies when the mathematical model contains nonlinear relationships between decision variables. For example, when the formulation included a division constraint to enforce a minimum percentage of trips by car.",
    "explanation": "When the problem involves nonlinear relationships between variables, such as ratios. The best practice is to linearize the constraint using equivalent linear expressions. A common mistake is attempting to directly implement the nonlinear constraint, which happens because solvers like Gurobi cannot handle nonlinear expressions in a linear or mixed-integer model. More generally, this reflects that solver models must be expressed in a linear form to be valid.",
    "example": "# Wrong: model.addConstr(x_c / (x_h + x_c) >= Min_C_Percentage, \"C3\")\n# Correct: model.addConstr(x_c >= Min_C_Percentage * (x_h + x_c), \"C3\")",
    "iteration": 1,
    "version": 1,
    "task_id": "A156",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 172,
    "taxonomy": {
      "Code Implementation": {
        "Solver & API Syntax": [
          "Strict Inequalities"
        ]
      }
    },
    "condition": "This insight applies when the mathematical model contains strict inequality relations between variables that cannot be directly handled by LP/MIP solvers. For example, when the formulation included a constraint like x_e < n_e to limit the number of automatic electric jacks.",
    "explanation": "When the problem involves integer decision variables with strict inequality constraints. The best practice is to reformulate strict inequalities as equivalent non-strict inequalities that solvers can handle. A common mistake is using strict inequalities directly, which happens because solvers like Gurobi do not support them in their constraint definitions. More generally, this reflects that mathematical programming solvers require all constraints to be non-strict to ensure feasible region definition.",
    "example": "# Wrong: model.addConstr(x_e < n_e, 'MaxElectricJacks')\n# Correct: model.addConstr(x_e <= n_e - 1, 'MaxElectricJacks')",
    "iteration": 1,
    "version": 1,
    "task_id": "A221",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 174,
    "taxonomy": {
      "General Formulation": {
        "Units Scaling": [
          "Big-M Magnitude & Numerical Stability"
        ]
      }
    },
    "condition": "This insight applies when the problem description involves constraints that use a Big-M formulation. For example, in the failed mathematical model, the constraints linking trips to mode selection use a Big-M value without ensuring it is as small as possible.",
    "explanation": "When the problem involves Big-M constraints, the best practice is to select the smallest possible M that still preserves correctness, as this can improve numerical stability and solver performance. A common mistake is to use an excessively large M, which happens because it seems safer but can lead to numerical issues. More generally, this reflects that careful calibration of Big-M values is crucial for maintaining model tractability and accuracy.",
    "example": "# Wrong\nC5: x_B \\leq M \\cdot y_B\nC6: x_C \\leq M \\cdot y_C\n\n# Correct\nC5: x_B \\leq 33 \\cdot y_B\nC6: x_C \\leq 25 \\cdot y_C\n# assuming maximum trips based on pollution constraints",
    "iteration": 1,
    "version": 1,
    "task_id": "B062",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 175,
    "taxonomy": {
      "Code Implementation": {
        "Solver & API Syntax": [
          "Strict Inequalities"
        ]
      }
    },
    "condition": "This insight applies when the mathematical model contains strict inequality relations between variables that cannot be directly handled by LP/MIP solvers. For example, when the formulation included a constraint ensuring more van trips than truck trips, specified as x_v > x_t.",
    "explanation": "When the problem involves integer variables with strict inequality constraints. The best practice is to convert strict inequalities into equivalent non-strict forms suitable for the solver. A common mistake is attempting to use strict inequalities directly, which happens because LP/MIP solvers do not support them. More generally, this reflects that solvers require constraints to be expressed in forms they can process, typically involving non-strict inequalities.",
    "example": "# Wrong\nmodel.addConstr(x_v > x_t, \"VanMoreThanTruck\")\n\n# Correct\nmodel.addConstr(x_v >= x_t + 1, \"VanMoreThanTruck\")",
    "iteration": 1,
    "version": 1,
    "task_id": "F033",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 176,
    "taxonomy": {
      "Code Implementation": {
        "Solver & API Syntax": [
          "Strict Inequalities"
        ]
      }
    },
    "condition": "This insight applies when the mathematical model contains strict inequality relations between variables that cannot be directly handled by LP/MIP solvers. For example, when the formulation included a requirement that large planes must be fewer than small planes, expressed as x < y.",
    "explanation": "When the problem involves strict inequality constraints between decision variables, such as requiring fewer large planes than small planes, the best practice is to reformulate the constraint using non-strict inequality forms like x \u2264 y - 1. A common mistake is to directly use strict inequality (x < y), which happens because LP/MIP solvers do not support strict inequalities. More generally, this reflects that mathematical solvers require all constraints to be expressed in a compatible inequality form.",
    "example": "# Wrong: model.addConstr(x < y, \"C2\")\n# Correct: model.addConstr(x <= y - 1, \"C2\")",
    "iteration": 1,
    "version": 1,
    "task_id": "F050",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 177,
    "taxonomy": {
      "General Formulation": {
        "Variable Definition": [
          "Redundant Auxiliary Variables"
        ]
      }
    },
    "condition": "This insight applies when the problem description involves calculating a minimum or maximum value based on multiple constraints. For example, when the problem statement mentioned minimizing total time with constraints on fertilizer and seeds' effectiveness times.",
    "explanation": "When the problem involves determining the minimum time for a process based on multiple constraints, the best practice is to introduce an auxiliary variable to represent this minimum time and constrain it accordingly. A common mistake is to directly use the time calculations in the objective without the auxiliary variable, which happens because it seems simpler but fails to correctly capture the minimum time across constraints. More generally, this reflects that auxiliary variables can help accurately model objectives that depend on multiple constraints.",
    "example": "# Wrong\n\\text{Minimize } Z = 0.5F + 1.5S\n\n# Correct\nT = m.addVar(name=\"T\", lb=0, vtype=GRB.CONTINUOUS)\nm.setObjective(T, GRB.MINIMIZE)\nm.addConstr(T >= 0.5 * F, name=\"TimeFertilizer\")\nm.addConstr(T >= 1.5 * S, name=\"TimeSeeds\")",
    "iteration": 1,
    "version": 1,
    "task_id": "A093",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 180,
    "taxonomy": {
      "Domain Modeling": {
        "Resource Allocation": [
          "Capacity/Resource Balance Equations"
        ]
      }
    },
    "condition": "This insight applies when the problem involves allocation restrictions between different resources, such as ratios or limits based on other resources. For example, when the problem statement mentioned 'there can be at most twice the amount of sulfate as ginger in the shampoo'.",
    "explanation": "When the problem involves specific allocation constraints, the best practice is to ensure constraints accurately reflect these conditions. A common mistake is misrepresenting these conditions, which happens because the translation from natural language to mathematical formulation can be misinterpreted. More generally, this reflects that allocation constraints must be carefully modeled to capture all problem-specific restrictions.",
    "example": "# Wrong\nS >= 2 * G\n\n# Correct\nS <= 2 * G",
    "iteration": 1,
    "version": 1,
    "task_id": "A112",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 182,
    "taxonomy": {
      "General Formulation": {
        "Variable Definition": [
          "Redundant Auxiliary Variables"
        ]
      }
    },
    "condition": "This insight applies when auxiliary variables merely re-express existing linear combinations without adding modeling value. For example, when the failed model's objective sums all inflows to the sink station, introducing unnecessary complexity.",
    "explanation": "When the problem involves maximizing or minimizing a function directly from decision variables, the best practice is to use these variables directly in the objective function. A common mistake is introducing unnecessary auxiliary variables, which happens because of overcomplicating the formulation. More generally, this reflects that avoiding redundant variables simplifies the model and improves computational efficiency.",
    "example": "# Wrong: Introduce auxiliary variable Z\n\\text{Maximize} \\quad Z = p_b \\cdot x_b + p_r \\cdot x_r\n\n# Correct: Directly use the expression\n\\text{Maximize} \\quad p_b \\cdot x_b + p_r \\cdot x_r",
    "iteration": 1,
    "version": 1,
    "task_id": [
      "E052",
      "F167"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 183,
    "taxonomy": {
      "Domain Modeling": {
        "Balancing": [
          "Load Balancing Constraints"
        ]
      }
    },
    "condition": "This insight applies when the problem description requires distributing a load across multiple entities to ensure fairness or minimize maximum usage. For example, when the problem statement mentioned minimizing the total length of the street occupied by cars, which implies balancing the parking distribution across both sides to minimize the maximum length occupied.",
    "explanation": "When the problem involves distributing a load evenly or minimizing the peak usage across several entities, the best practice is to model the problem as a load balancing problem, minimizing the maximum load or length on any single entity. A common mistake is to model the problem as minimizing the sum of loads on each entity, which happens because it may overlook the balancing aspect and lead to imbalanced solutions. More generally, this reflects that balancing constraints are crucial to achieving fair or optimized distribution in problems requiring shared resource allocation.",
    "example": "# Wrong: \nminimize sum(lambda_i * x_i, lambda_i * y_i)\n\n# Correct: \nminimize max(sum(lambda_i * x_i), sum(lambda_i * y_i))",
    "iteration": 1,
    "version": 1,
    "task_id": "B080",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 184,
    "taxonomy": {
      "General Formulation": {
        "Objective Specification": [
          "Sum vs. Makespan Confusion"
        ]
      }
    },
    "condition": "This insight applies when multiple resources or activities can run in parallel and the objective is ambiguous between minimizing total completion time and makespan. For example, when the problem statement involved minimizing the total length of the street occupied by cars, which could be interpreted as either minimizing the total length parked or minimizing the maximum length on any side.",
    "explanation": "When the problem involves parallel activities or resources, the best practice is to clarify whether the objective is to minimize the total quantity or the maximum quantity used. A common mistake is to confuse minimizing the total usage with minimizing the maximum usage, which happens because both objectives can seem similar but lead to different formulations. More generally, this reflects that correctly specifying the objective is essential to achieving the desired optimization goal, especially in balancing or scheduling problems.",
    "example": "# Wrong: \nminimize sum(x_i * lambda_i) + sum(y_i * lambda_i)\n\n# Correct: \nminimize L_max\nsubject to: \nL_max >= sum(x_i * lambda_i)\nL_max >= sum(y_i * lambda_i)",
    "iteration": 1,
    "version": 1,
    "task_id": "B080",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [
        "F122",
        "A104",
        "F019",
        "B080",
        "A084"
      ],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 185,
    "taxonomy": {
      "Domain Modeling": {
        "Resource Allocation": [
          "Set-Partitioning/Assignment"
        ]
      }
    },
    "condition": "This insight applies when the problem description requires each item or task to be exclusively assigned to exactly one choice among many. For example, when the problem statement required each car to be parked on exactly one side of the street.",
    "explanation": "When the problem involves assigning items exclusively to one of several choices, the best practice is to use partitioning constraints, ensuring each item is assigned to exactly one option. A common mistake is to assume assignments without enforcing exclusivity, which happens because the assignment constraints might be overlooked or incorrectly specified. More generally, this reflects that set-partitioning constraints are crucial in assignment problems to ensure each task or item is allocated without overlap.",
    "example": "# Wrong: \nminimize ...\nsubject to: ...\n\n# Correct: \nsubject to: \nx_i + y_i = 1 for all i",
    "iteration": 1,
    "version": 1,
    "task_id": "B080",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 186,
    "taxonomy": {
      "General Formulation": {
        "Objective Specification": [
          "Sum vs. Makespan Confusion"
        ]
      }
    },
    "condition": "This insight applies when multiple resources or activities can run in parallel and the objective is ambiguous between total completion time and makespan. For example, when the problem statement requires minimizing the total hours each factory runs but the failed mathematical model minimizes the sum of the hours instead of the maximum between them.",
    "explanation": "When the problem involves minimizing the time used by parallel resources to meet demands, the best practice is to minimize the makespan, or the maximum of the usage times. A common mistake is to minimize the sum of the hours, which happens because it does not capture the parallel aspect of minimizing the longest time. More generally, this reflects that correctly distinguishing between minimizing total completion time and minimizing makespan is crucial in parallel resource scheduling problems.",
    "example": "# Wrong\nMinimize x + y\n\n# Correct\nmodel.setObjective(max_hour, GRB.MINIMIZE)",
    "iteration": 1,
    "version": 1,
    "task_id": "A236",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [
        "A104",
        "A236",
        "A084"
      ],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 187,
    "taxonomy": {
      "Domain Modeling": {
        "Resource Allocation": [
          "Capacity/Resource Balance Equations"
        ]
      }
    },
    "condition": "This insight applies when the problem domain requires resources to move or transform through nodes and local conservation must hold. For example, when the problem statement involves balancing the total plastic usage across both factories to ensure it does not exceed the available limit.",
    "explanation": "When the problem involves managing resource consumption across facilities, the best practice is to ensure that total resource usage does not exceed the available supply. A common mistake is failing to account for all resource constraints properly, which happens because the formulation may overlook the full scope of resource interactions. More generally, this reflects that resource balance equations are fundamental in optimization models where capacities or resource limits apply across interconnected units.",
    "example": "# Correct\nmodel.addConstr(plastic_north * x_N + plastic_west * x_W <= plastic_limit, name=\"PlasticLimit\")",
    "iteration": 1,
    "version": 1,
    "task_id": "A236",
    "occurrence": 0,
    "distribution": {
      "positive": [
        "A236"
      ],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 188,
    "taxonomy": {
      "Domain Modeling": {
        "Network Flow": [
          "Flow Conservation"
        ]
      }
    },
    "condition": "This insight applies when the problem description involves quantities traversing a directed network and nodal balance must be maintained. For example, when the problem statement mentioned that resources must flow through sectors with conservation at intermediate nodes. This insight applies when the problem explicitly involves both directed network flow and conservation requirements at intermediate nodes. For example, when the problem statement mentions these specific features. This insight does NOT apply when the problem involves a single-stage allocation without intermediate nodes requiring flow conservation. For example, when the problem statement mentions that resources are directly allocated among a set of locations without any intermediate transfer points or flow conservation requirements.",
    "explanation": "When the problem involves flow through a network, the best practice is to apply flow conservation constraints to all nodes except the source and sink. A common mistake is to include incomplete or incorrect flow conservation constraints, which happens because the modeler overlooks the necessary balance at each node. More generally, this reflects that flow conservation is essential to maintain valid flow dynamics in network optimization problems.",
    "example": "# Wrong: \n\\[\n\\sum_{j \\in N} f_{ij} = \\sum_{j \\in N} f_{ji}, \\quad \\forall i \\in N \\setminus \\{0, 8\\}\n\\]\n\n# Correct: \nmodel.addConstrs(\n (gp.quicksum(flow[i, k] for i in S if (i, k) in capacities) == \n  gp.quicksum(flow[k, j] for j in S if (k, j) in capacities) \n  for k in S if k not in [0, 8]), \"Flow_Conservation\"\n)",
    "iteration": 1,
    "version": 1,
    "task_id": "E061",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [
        "E035"
      ],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 189,
    "taxonomy": {
      "Domain Modeling": {
        "Network Flow": [
          "Max-Flow Objective"
        ]
      }
    },
    "condition": "This insight applies when the problem description requires maximizing throughput between designated source and sink nodes. For example, when the problem statement specified maximizing the amount of resources transported from the Central Supply Hub to the Farthest Outpost.",
    "explanation": "When the problem involves sending resources from a source to a sink, the best practice is to directly maximize the total flow into the sink. A common mistake is to maximize the flow from the source without ensuring it reaches the sink, which happens because the objective does not accurately reflect the problem's goal. More generally, this reflects that the objective should align with the desired outcome in max-flow problems by focusing on sink inflows.",
    "example": "# Wrong: \n\\[\n\\text{Maximize } \\sum_{i \\in N} f_{i8}\n\\]\n\n# Correct: \nmodel.setObjective(gp.quicksum(flow[i, 8] for i in S if (i, 8) in capacities), GRB.MAXIMIZE)",
    "iteration": 1,
    "version": 1,
    "task_id": "E061",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [
        "E067"
      ],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 190,
    "taxonomy": {
      "Domain Modeling": {
        "Network Flow": [
          "Source Flow Constraint"
        ]
      }
    },
    "condition": "This insight applies when the problem domain involves a centralized source node distributing flow to a network ending at a sink node. For example, when the problem statement specified that resources should be moved from the Central Supply Hub to the Farthest Outpost.",
    "explanation": "When the problem involves a source distributing flow to a sink, the best practice is to ensure flow conservation at the source such that total outflow minus inflow equals flow into the sink. A common mistake is to not enforce this constraint, which happens because it might seem redundant with other conservation constraints. More generally, this reflects that special care must be taken to distinguish source and sink roles in flow networks.",
    "example": "# Wrong: \n\\[\n\\sum_{j \\in N} f_{0j} \\geq \\sum_{i \\in N} f_{i0}\n\\]\n\n# Correct: \nmodel.addConstr(\n gp.quicksum(flow[0, j] for j in S if (0, j) in capacities) -\n gp.quicksum(flow[i, 0] for i in S if (i, 0) in capacities) == \n gp.quicksum(flow[i, 8] for i in S if (i, 8) in capacities), \n \"Source_Flow\"\n)",
    "iteration": 1,
    "version": 1,
    "task_id": "E061",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 191,
    "taxonomy": {
      "Domain Modeling": {
        "Resource Allocation": [
          "Capacity/Resource Balance Equations"
        ]
      }
    },
    "condition": "This insight applies when the problem domain requires resources to move or transform through nodes and local conservation must hold. For example, when the problem statement mentioned using raw materials A, B, and C to produce candies, ensuring that the total raw materials used match the candy produced.",
    "explanation": "When the problem involves resource allocation and transformation, the best practice is to model resource balance equations to ensure that the sum of inputs equals the sum of outputs for each transformation. A common mistake is omitting detailed balance equations for resource usage, which happens because the modeler assumes implicit conservation without explicit constraints. More generally, this reflects that precise resource tracking is essential in production planning problems to avoid infeasibilities or suboptimal solutions.",
    "example": "# Wrong: Objective and constraints do not explicitly model raw material usage per candy.\nObjective = (p_A - f_A) * x_A + (p_B - f_B) * x_B + (p_C - f_C) * x_C - c_A * (0.6x_A + 0.15x_B) - c_B * (0.4x_A + 0.85x_B + 0.5x_C) - c_C * (0.2x_A + 0.6x_B + 0.5x_C)\n\n# Correct: Explicitly define raw material usage variables and balance equations.\nmodel.addConstr(gp.quicksum(R[i, j] for i in raw_materials) == X[j], name=f\"MassBalance_{j}\")",
    "iteration": 2,
    "version": 1,
    "task_id": "B058",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 193,
    "taxonomy": {
      "Code Implementation": {
        "Solver & API Syntax": [
          "Nonlinear Constraint Handling"
        ]
      }
    },
    "condition": "This insight applies when the mathematical model contains nonlinear constraints that are not directly supported by the solver. For example, when the formulation included a constraint like x / (x + y) >= alpha.",
    "explanation": "When the problem involves nonlinear constraints, the best practice is to linearize these constraints if possible. A common mistake is to directly implement nonlinear constraints in solvers that do not support them, which happens because users may not be aware of solver limitations or linearization techniques. More generally, this reflects that solvers often require linear or linearized formulations to function correctly.",
    "example": "# Wrong: model.addConstr(x / (x + y) >= alpha, \"C2\")\n# Correct: model.addConstr(x >= alpha * (x + y), \"C2\")",
    "iteration": 2,
    "version": 1,
    "task_id": "A209",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 194,
    "taxonomy": {
      "General Formulation": {
        "Variable Definition": [
          "Redundant Auxiliary Variables"
        ]
      }
    },
    "condition": "This insight applies when the problem objective is stated in terms of minimizing or maximizing a specific entity or resource. For example, when the problem statement mentioned minimizing the total number of trips, but the gold-standard program minimized pollution instead.",
    "explanation": "When the problem involves minimizing or maximizing a specific resource or activity, the best practice is to directly align the objective function with the stated goal. A common mistake is to introduce auxiliary variables or objectives that do not directly correspond to the stated problem objective, which happens because of a misunderstanding or misalignment between the problem description and the implementation. More generally, this reflects that clear objective specification is crucial in optimization modeling to ensure alignment with the problem's goal.",
    "example": "# Wrong: Minimize x_H + x_B + x_C\n# Correct: Minimize pollution_horse * x_H",
    "iteration": 2,
    "version": 1,
    "task_id": "B062",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [
        "B080"
      ],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 196,
    "taxonomy": {
      "Domain Modeling": {
        "Selection": [
          "Binary Selection Constraints"
        ]
      }
    },
    "condition": "This insight applies when the problem domain requires choosing a subset under count, budget, or compatibility limits. For example, when the problem statement mentioned that only one of the bicycle or handcart can be used.",
    "explanation": "When the problem involves selecting among mutually exclusive options, the best practice is to use binary variables to enforce these exclusive choices. A common mistake is to improperly link binary variables with decision variables, which happens because of inadequate or incorrect linking constraints. More generally, this reflects the importance of correctly formulating binary selection constraints to model mutually exclusive choices.",
    "example": "# Wrong: Not properly linking binary variables to trips\n# Correct: x_B <= M * y_B and x_C <= M * y_C with y_B + y_C = 1",
    "iteration": 2,
    "version": 1,
    "task_id": "B062",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [
        "B019",
        "B023"
      ],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 198,
    "taxonomy": {
      "Domain Modeling": {
        "Resource Allocation": [
          "Capacity/Resource Balance Equations"
        ]
      }
    },
    "condition": "This insight applies when the problem domain requires resources to move or transform through nodes and local conservation must hold. For example, when the problem statement mentioned completing a dataset of at least 10,000 images, the failed mathematical model did not ensure that the total number of images was allocated between companies properly.",
    "explanation": "When the problem involves allocating resources such as task completion, the best practice is to ensure that the sum of resources meets the total demand. A common mistake is to focus on time allocation without ensuring that the total task count aligns with the demand, which happens because the solver might overlook the need for a direct task allocation constraint. More generally, this reflects that resource allocation problems must ensure that all demand is met by the resources allocated.",
    "example": "# Wrong: r_s * x_s + r_c * x_c >= D (focuses on hours)\n# Correct: x + y >= D (focuses on images)",
    "iteration": 2,
    "version": 1,
    "task_id": "A229",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 199,
    "taxonomy": {
      "General Formulation": {
        "Constraint Formulation": [
          "Incorrect Relational Operators"
        ]
      }
    },
    "condition": "This insight applies when natural-language statements such as 'at least' must be translated into algebraic inequalities. For example, when the problem statement mentioned minimum allocations like at least a third of the work must be allocated to the specialized company, or when it required at least 70% of delivery shifts to be by cart.",
    "explanation": "When the problem involves constraints that specify minimum allocations or requirements, the best practice is to use a relational operator that accurately reflects the 'at least' condition. A common mistake is to misrepresent the constraint, which happens because the solver might not translate the natural language condition correctly into a mathematical expression. More generally, this reflects that relational operators must match the intent of constraints as described in natural language.",
    "example": "# Wrong: r_s * x_s >= (1/3) * D (incorrect focus)\n# Correct: 2 * x >= y (correct relational operator reflecting one-third allocation)",
    "iteration": 2,
    "version": 1,
    "task_id": [
      "E034",
      "E013",
      "A026",
      "A211",
      "E028",
      "A229"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 201,
    "taxonomy": {
      "General Formulation": {
        "Variable Definition": [
          "Continuous vs. Discrete Confusion"
        ]
      }
    },
    "condition": "This insight applies when decision quantities in the problem represent divisible amounts such as flows. For example, when the problem involves allocating hours to companies or the distribution of water in continuous amounts.",
    "explanation": "When the problem involves quantities that represent divisible amounts, the best practice is to define variables as continuous. A common mistake is confusing continuous and discrete definitions, which happens because the nature of decision quantities is not correctly interpreted. More generally, this reflects that variable definitions should match the divisibility of the quantities they represent to avoid incorrect or suboptimal solutions.",
    "example": "# Wrong: x_S, x_C as integer\n# Correct: x_S, x_C as continuous",
    "iteration": 2,
    "version": 1,
    "task_id": [
      "F131",
      "A229"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 202,
    "taxonomy": {
      "Domain Modeling": {
        "Resource Allocation": [
          "Expected-return objective"
        ]
      }
    },
    "condition": "This insight applies when the problem description involves maximizing an expected payout based on probabilities of losing and corresponding payouts. For example, when the problem statement mentioned maximizing the average payout from bets, considering both the probability of losing and the payout for winning.",
    "explanation": "When the problem involves maximizing an expected payout based on probabilities, the best practice is to multiply the payout by the probability of winning (1 - probability of losing) for each bet. A common mistake is to directly use the payout multipliers in the objective without adjusting for the probability of winning, which happens because the direct payouts are misinterpreted as expected values. More generally, this reflects that expected outcomes should account for both the reward and the probability of achieving it.",
    "example": "# Wrong: Maximize: 1.2 * x_B + 0.5 * x_H + 0.1 * x_S\n# Correct: Maximize: 0.6 * x_B + 0.375 * x_H + 0.09 * x_S",
    "iteration": 2,
    "version": 1,
    "task_id": "A186",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 203,
    "taxonomy": {
      "Domain Modeling": {
        "Resource Allocation": [
          "Chance Constraint"
        ]
      }
    },
    "condition": "This insight applies when the problem description specifies a constraint on the average probability of losing money across different bets. For example, when the problem statement mentioned that the average chance of losing money should be at most 30%.",
    "explanation": "When the problem involves setting a limit on the average probability of losing, the best practice is to express the constraint as the weighted average of probabilities, weighted by the amounts bet on each option. A common mistake is failing to normalize this weighted sum by the total amount bet, which happens because the constraint is incorrectly expressed as a direct sum of weighted probabilities. More generally, this reflects that probability constraints should be properly normalized to reflect the average across all contributing factors.",
    "example": "# Wrong: (p_B * x_B + p_H * x_H + p_S * x_S) / (x_B + x_H + x_S) <= 0.3\n# Correct: 0.5 * x_B + 0.25 * x_H + 0.10 * x_S <= 30000",
    "iteration": 2,
    "version": 1,
    "task_id": "A186",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 204,
    "taxonomy": {
      "Domain Modeling": {
        "Resource Allocation": [
          "Capacity/Resource Balance Equations"
        ]
      }
    },
    "condition": "This insight applies when the problem description involves distributing a fixed total budget across multiple options. For example, when the problem statement mentioned a total budget of $100,000 for gambling on different sports bets.",
    "explanation": "When the problem involves distributing a fixed total budget, the best practice is to use an equality constraint that ensures the sum of all allocations equals the total budget. A common mistake is using an inequality that allows for under-allocation of the total resource, which happens because the constraint fails to enforce full utilization of the budget. More generally, this reflects that resource allocation constraints should ensure the complete use of available resources when the total is fixed.",
    "example": "# Wrong: x_B + x_H + x_S <= 100000\n# Correct: x_B + x_H + x_S == 100000",
    "iteration": 2,
    "version": 1,
    "task_id": "A186",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 205,
    "taxonomy": {
      "Code Implementation": {
        "Solver & API Syntax": [
          "Nonlinear Constraint Handling"
        ]
      }
    },
    "condition": "This insight applies when the mathematical model contains nonlinear constraints that involve division by a sum of decision variables. For example, when the formulation included (p_b * x_b + p_h * x_h + p_s * x_s) / (x_b + x_h + x_s) <= L.",
    "explanation": "When the problem involves nonlinear constraints due to division by decision variable sums. The best practice is to introduce an auxiliary variable representing the total sum and replace the nonlinear constraint with a linear equivalent. A common mistake is to directly code the nonlinear constraint into the model, which happens because LP/MIP solvers cannot handle nonlinear constraints directly. More generally, this reflects that linearization techniques are essential for handling nonlinear constraints in optimization models.",
    "example": "# Wrong\nmodel.addConstr((p_b * x_b + p_h * x_h + p_s * x_s) / (x_b + x_h + x_s) <= L, \"Probability\")\n\n# Correct\ntotal_investment = model.addVar(name=\"total_investment\", lb=0)\nmodel.addConstr(total_investment == x_b + x_h + x_s, \"TotalInvestment\")\nmodel.addConstr(p_b * x_b + p_h * x_h + p_s * x_s <= L * total_investment, \"Probability\")",
    "iteration": 2,
    "version": 1,
    "task_id": "A186",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 206,
    "taxonomy": {
      "General Formulation": {
        "Variable Definition": [
          "Continuous vs. Discrete Confusion"
        ]
      }
    },
    "condition": "This insight applies when decision quantities in the problem represent indivisible counts or choices versus divisible amounts such as flows. For example, when the problem statement mentioned the acres of blueberries and raspberries to plant, which are typically indivisible into fractions.",
    "explanation": "When the problem involves quantities that are naturally indivisible, such as acres of land, the best practice is to define the decision variables as integers. A common mistake is to model these quantities as continuous variables, which happens because it is often simpler to implement and solve, but it can lead to non-implementable solutions. More generally, this reflects that understanding the nature of the decision variables is crucial to ensure the feasibility and practicality of the solution.",
    "example": "# Wrong: x_b \u2208 \u211d\u207a\n# Correct: x_b \u2208 \u2124\u207a",
    "iteration": 2,
    "version": 1,
    "task_id": "F167",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [
        "B015"
      ],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 207,
    "taxonomy": {
      "General Formulation": {
      "Constraint Formulation": [
        "Incorrect Relational Operators"
        ]
      }
    },
    "condition": "This insight applies when natural-language statements such as 'at most' or 'at least' must be translated into algebraic inequalities. For example, when the problem statement mentioned the constraints on labor days and watering budget, which express 'at most' conditions, or when at least a third of the work must be allocated to the specialized company.",
    "explanation": "When the problem involves constraints that express a limit or minimum, the best practice is to use the appropriate non-strict inequality operators (\u2264 or \u2265). A common mistake is to use strict inequalities (< or >), which happens because of a misunderstanding of the problem requirements or careless translation from natural language. More generally, this reflects that correctly interpreting the relational nature of constraints is essential for modeling the problem accurately.",
    "example": "# Wrong: x_b + x_r < B\n# Correct: x_b + x_r \u2264 B",
    "iteration": 2,
    "version": 1,
    "task_id": [
      "F131",
      "F167"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 208,
    "taxonomy": {
      "Domain Modeling": {
        "Production Planning": [
          "Inventory Balance Equations"
        ]
      }
    },
    "condition": "This insight applies when the problem description involves materials or products that carry over between periods and must satisfy stock-flow balance. For example, when the problem statement mentioned initial inventory, production, and demand for liquid and solid fertilizers.",
    "explanation": "When the problem involves tracking inventory levels over a period, the best practice is to explicitly model inventory balance equations to ensure proper tracking of stock levels. A common mistake is to neglect or incorrectly formulate these equations, which happens because the modeler assumes inventory balance is inherently satisfied by other constraints. More generally, this reflects that tracking stock levels with proper balance equations is crucial in production planning.",
    "example": "# Wrong: Objective does not explicitly track ending inventory\n\\text{Maximize } (L_0 + x_L - D_L) + (S_0 + x_S - D_S)\n\n# Correct: Use inventory balance constraints\nfor p in products:\n    model.addConstr(InvEnd[p] == initial_inventory[p] + Produce[p] - demand[p], name=f\"InventoryBalance_{p}\")",
    "iteration": 2,
    "version": 1,
    "task_id": "B087",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 209,
    "taxonomy": {
      "General Formulation": {
        "Variable Definition": [
          "Explicit Bounds"
        ]
      }
    },
    "condition": "This insight applies when the problem description provides natural physical, economic, or logical limits that can tightly bound decision variables. For example, when the production quantities must be non-negative integers in the fertilizer production problem.",
    "explanation": "When the problem involves decision variables with natural bounds, the best practice is to explicitly set lower and upper bounds to prevent infeasible or unrealistic solutions. A common mistake is to omit these bounds, which happens because modelers assume the solver will handle such constraints implicitly. More generally, this reflects that explicitly defining bounds can improve solver performance and ensure feasible solutions.",
    "example": "# Wrong: Variables lack explicit bounds\nx_L \\in \\mathbb{Z}^+\nx_S \\in \\mathbb{Z}^+\n\n# Correct: Define variables with explicit bounds\nProduce = model.addVars(products, name=\"Produce\", vtype=GRB.INTEGER, lb=0)",
    "iteration": 2,
    "version": 1,
    "task_id": "B087",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 210,
    "taxonomy": {
      "Domain Modeling": {
        "Resource Allocation": [
          "Capacity/Resource Balance Equations"
        ]
      }
    },
    "condition": "This insight applies when the problem domain requires resources to move or transform through nodes and local conservation must hold. For example, when the problem statement mentioned the need to allocate limited production hours to maximize completed products, ensuring each workshop's hours are balanced with its capacity.",
    "explanation": "When the problem involves allocating limited resources across different tasks. The best practice is to model each resource's capacity as a constraint to ensure no resource is over-allocated. A common mistake is to incorrectly formulate the objective or constraints, which happens because of misunderstanding how to express the production and completion relationship in terms of resource allocation. More generally, this reflects that proper resource balance must be maintained to ensure feasible and optimal solutions in resource allocation problems.",
    "example": "# Wrong: Objective uses min function\n\\[\\max \\left( \\min_{c \\in C} \\left( \\sum_{w \\in W} R_{wc} \\cdot x_{wc} \\right) \\right)\\]\n\n# Correct: Introduce a variable for complete products and use it in the constraints\nmodel.addConstr(sum(prod_rate[i, j] * x[i, j] for i in workshops) >= z, name=f\"Component_{j}_enough_for_z\")",
    "iteration": 2,
    "version": 1,
    "task_id": "B031",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 211,
    "taxonomy": {
      "General Formulation": {
        "Variable Definition": [
          "Redundant Auxiliary Variables"
        ]
      }
    },
    "condition": "This insight applies when auxiliary variables merely re-express existing linear combinations without adding modeling value. For example, when the failed model attempted to maximize a complex nested expression instead of directly maximizing a variable representing complete products.",
    "explanation": "When the problem involves maximizing a quantity that can be directly expressed as a variable. The best practice is to directly use this variable in the objective function. A common mistake is to introduce unnecessary complexity or auxiliary expressions, which happens because of a misunderstanding of how to capture the main objective succinctly. More generally, this reflects that minimizing model complexity and redundancy helps in improving solver performance and solution interpretability.",
    "example": "# Wrong: Objective uses nested expressions\n\\[\\max \\left( \\min_{c \\in C} \\left( \\sum_{w \\in W} R_{wc} \\cdot x_{wc} \\right) \\right)\\]\n\n# Correct: Use a direct variable in the objective\nmodel.setObjective(z, GRB.MAXIMIZE)",
    "iteration": 2,
    "version": 1,
    "task_id": "B031",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [
        "B039"
      ],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 212,
    "taxonomy": {
      "Domain Modeling": {
        "Production Planning": [
          "Time-Indexed Variables"
        ]
      }
    },
    "condition": "This insight applies when the problem domain requires discrete time modeling to capture capacities, setups, or carryover decisions. For example, when the problem statement mentioned a total of 22 production days available and the need to allocate them across different product types with specific production quotas.",
    "explanation": "When the problem involves allocating a limited number of production days among different products with daily production limits, the best practice is to use time-indexed variables to explicitly model the use of time resources. A common mistake is to overlook the shared resource constraint of production days, which happens because the model lacks explicit representation of time-period-specific resource consumption. More generally, this reflects that time-indexed variables are essential to accurately capture and manage shared time resources in production scheduling.",
    "example": "# Wrong: The failed model did not explicitly account for the shared production days across products.\n# Correct: The gold-standard program uses a constraint summing the production time required for each product, ensuring it does not exceed available days.",
    "iteration": 2,
    "version": 1,
    "task_id": "B021",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 213,
    "taxonomy": {
      "General Formulation": {
        "Constraint Formulation": [
          "Big-M & Indicator Variables"
        ]
      }
    },
    "condition": "This insight applies when constraints depend on logical on/off conditions controlled by binary variables. For example, when the problem statement mentioned using binary variables to indicate if a product is produced and linking this to production quantities with a Big-M constraint.\nThis insight applies when constraints depend on logical on/off conditions, such as defining paths or routes with binary variables or using binary variables to indicate container usage, linking them to continuous measures like bandwidth or load constraints with a Big-M constraint.\nThis insight does NOT apply when constraints are purely continuous or when binary variables do not influence constraint activation.",
    "explanation": "When the problem involves constraints that should only be active if a binary decision (like producing a product) is made, the best practice is to use Big-M formulations to link binary variables with continuous ones. A common mistake is to use overly large M values, which happens because they are not carefully derived from the problem's actual limits. More generally, this reflects that choosing tight, realistic bounds for Big-M values is crucial to ensure numerical stability and model tightness.",
    "example": "# Wrong: The failed model uses Q_i * T as a Big-M value without considering if it's the tightest possible bound.\n# Correct: The gold-standard program uses maximum demand as a tighter Big-M value for activation constraints.",
    "iteration": 2,
    "version": 1,
    "task_id": "B021",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [
        "B099",
        "B033"
      ],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 214,
    "taxonomy": {
      "General Formulation": {
        "Variable Definition": [
          "Explicit Bounds"
        ]
      }
    },
    "condition": "This insight applies when the problem description provides natural physical, economic, or logical limits that can tightly bound decision variables. For example, when the problem statement specified maximum demand and production quotas for each product.",
    "explanation": "When the problem involves decision variables that have clear upper and lower limits based on problem parameters, the best practice is to explicitly set these bounds in the model. A common mistake is to omit these explicit bounds, which happens because the modeler assumes implicit constraints will suffice. More generally, this reflects that setting explicit bounds helps to optimize solver performance and prevent infeasible or suboptimal solutions.",
    "example": "# Wrong: The failed model does not explicitly set bounds on x_i based on maximum demand or production quotas.\n# Correct: The gold-standard program explicitly constrains production quantities to maximum demand and quota-based limits.",
    "iteration": 2,
    "version": 1,
    "task_id": "B021",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 215,
    "taxonomy": {
      "Domain Modeling": {
        "Production Planning": [
          "Inventory Balance Equations"
        ]
      }
    },
    "condition": "This insight applies when the problem description involves materials or products that carry over between periods and must satisfy stock-flow balance. For example, when the problem statement mentioned calculating inventory levels at the end of each month based on purchases and sales.",
    "explanation": "When the problem involves inventory levels evolving over multiple periods, the best practice is to use inventory balance equations that accurately reflect the stock-flow relationship: current inventory equals previous inventory plus purchases minus sales. A common mistake is omitting or misformulating these equations, which happens because of incorrect application or oversight of how inventory carries over between periods. More generally, this reflects that correct inventory balance is crucial for accurately capturing the dynamics of production planning problems.",
    "example": "# Wrong: I_1 = I_0 + x_1 - y_1; I_2 = I_0 + x_2 - y_2; I_3 = I_0 + x_3 - y_3\n# Correct: I_1 = I_0 + x_1 - y_1; I_2 = I_1 + x_2 - y_2; I_3 = I_2 + x_3 - y_3",
    "iteration": 2,
    "version": 1,
    "task_id": "B015",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 216,
    "taxonomy": {
      "General Formulation": {
        "Units Scaling": [
          "Unit Inconsistency"
        ]
      }
    },
    "condition": "This insight applies when input data come from different unit systems or incompatible measurement scales. For example, when the problem statement involves purchasing and selling products with prices given in different units, such as yuan per unit.",
    "explanation": "When the problem involves multiple units of measurement in constraints, the best practice is to ensure all terms are in compatible units to avoid scaling errors. A common mistake is failing to maintain unit consistency, which happens because of oversight in aligning units across different elements of the model. More generally, this reflects that maintaining unit consistency is essential to prevent errors and achieve accurate results in optimization models.",
    "example": "# Wrong: Constraints involve purchase (in units) and sales (in yuan) without conversion.\n# Correct: Ensure all monetary terms are in yuan before integrating them into constraints.",
    "iteration": 2,
    "version": 1,
    "task_id": "B015",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 217,
    "taxonomy": {
      "Domain Modeling": {
        "Production Planning": [
          "Time-Indexed Variables"
        ]
      }
    },
    "condition": "This insight applies when the problem involves scheduling resources over discrete time periods with unique constraints for each period. For example, when the problem statement mentioned covering specific 4-hour periods with different waiter demands or when each waiter works continuously for 8 hours and the required number of waiters varies by 4-hour periods.",
    "explanation": "When the problem involves covering specific time periods with unique constraints, the best practice is to define decision variables that are indexed by these time intervals to accurately capture the temporal dynamics. A common mistake is using a single time index for variables that actually need to cover multiple overlapping periods, which happens because the model does not reflect the actual requirement of covering each specific time period. More generally, this reflects that time-indexed variables are crucial for capturing dynamic requirements in scheduling and resource allocation problems.",
    "example": "# Wrong: Use a single time index for all periods.\nConstraints like: x_1 + x_2 + x_3 + ... + x_24.\n\n# Correct: Use time-indexed variables for each specific period.\nConstraints like: x[5] + x[0] >= demands[0], x[0] + x[1] >= demands[1].",
    "iteration": 2,
    "version": 1,
    "task_id": [
      "B082"
    ],
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 218,
    "taxonomy": {
      "General Formulation": {
        "Variable Definition": [
          "Indexing & Data Structure Alignment"
        ]
      }
    },
    "condition": "This insight applies when variables need to be indexed to align with specific data structures or periods in the problem description. For example, when the problem statement mentioned waiter demands for specific time periods, it indicates alignment of variable indices with these periods.",
    "explanation": "When the problem involves specific time periods, the best practice is to ensure that variable indices align precisely with these periods to correctly capture the demand coverage. A common mistake is misaligning variable indices with the intended periods, which happens because of incorrect or inconsistent indexing that does not match the problem's logical structure. More generally, this reflects that proper indexing is essential for maintaining logical coherence between variables and data structures.",
    "example": "# Wrong: Misaligned indices with periods.\nVariables like: x_1, x_2, ..., x_24 without specific alignment.\n\n# Correct: Aligned indices with periods.\nVariables like: x[0], x[1], ..., x[5] where each index corresponds to a specific period.",
    "iteration": 2,
    "version": 1,
    "task_id": "B082",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 219,
    "taxonomy": {
      "Code Implementation": {
        "Data I/O & Validation": [
          "KeyError & Index Mismatch"
        ]
      }
    },
    "condition": "This insight applies when the mathematical model contains indexed variables or parameters that are accessed with indices not present in the corresponding data structures. For example, when the formulation included capacities for all edges except (8, 6) in the capacities dictionary.",
    "explanation": "When the problem involves managing a dictionary of capacities for network edges. The best practice is to ensure that every potential edge in the network has a defined capacity in the dictionary. A common mistake is omitting an edge, which happens because the dictionary access assumes the existence of all possible keys. More generally, this reflects that validation of data completeness is crucial to prevent runtime errors like KeyErrors.",
    "example": "# Wrong\ncapacities = { (0, 1): 9, ..., (8, 0): 2, (8, 1): 12, (8, 2): 10 }\n# Correct\ncapacities = { (0, 1): 9, ..., (8, 0): 2, (8, 1): 12, (8, 2): 10, (8, 6): 0 }",
    "iteration": 2,
    "version": 1,
    "task_id": "E071",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 220,
    "taxonomy": {
      "Code Implementation": {
        "Data I/O & Validation": [
          "KeyError & Index Mismatch"
        ]
      }
    },
    "condition": "This insight applies when the mathematical model contains indexed variables or parameters that are accessed with indices not present in the corresponding data structures. For example, when the formulation included a cost dictionary without (i, i) pairs but attempted to access cost[i, j] for all pairs (i, j) in N x N.",
    "explanation": "When the problem involves accessing entries in a dictionary that are not guaranteed to exist, such as cost values for all node pairs. The best practice is to ensure that the dictionary includes all necessary keys or to conditionally access them. A common mistake is to assume all keys exist, which happens because the dictionary might not be complete for all indices. More generally, this reflects that model validity requires verifying or safely handling data access.",
    "example": "# Wrong\nmodel.setObjective(gp.quicksum(cost[i, j] * x[i, j] for i in N for j in N), GRB.MINIMIZE)\n\n# Correct\nmodel.setObjective(gp.quicksum(cost[i, j] * x[i, j] for i in N for j in N if i != j), GRB.MINIMIZE)",
    "iteration": 2,
    "version": 1,
    "task_id": "E043",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 221,
    "taxonomy": {
      "Code Implementation": {
        "Data I/O & Validation": [
          "KeyError & Index Mismatch"
        ]
      }
    },
    "condition": "This insight applies when the mathematical model contains indexed variables or parameters that are accessed with indices not present in the corresponding data structures. For example, when the formulation included calculating the objective with all i, j pairs in the cost dictionary, but (i, i) pairs were absent.",
    "explanation": "When the problem involves accessing elements in a dictionary by indices. The best practice is to ensure all required indices are present in the data structure. A common mistake is attempting to access an index that does not exist, which happens because the modeler assumes all index pairs are available. More generally, this reflects that modelers must verify the presence of indices in data structures prior to access.",
    "example": "# Wrong: model.setObjective(gp.quicksum(cost[i, j] * x[i, j] for i in N for j in N), GRB.MINIMIZE)\n# Correct: model.setObjective(gp.quicksum(cost[i, j] * x[i, j] for i in N for j in N if i != j), GRB.MINIMIZE)",
    "iteration": 2,
    "version": 1,
    "task_id": "E041",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  },
  {
    "insight_id": 222,
    "taxonomy": {
      "Code Implementation": {
        "Data I/O & Validation": [
          "KeyError & Index Mismatch"
        ]
      }
    },
    "condition": "This insight applies when the mathematical model contains indexed variables or parameters that are accessed with indices not present in the corresponding data structures. For example, when the formulation included terms for (i, i) which do not exist in the cost dictionary.",
    "explanation": "When the problem involves accessing elements in a dictionary for cost parameters. The best practice is to ensure that all indices used in expressions are valid keys in the dictionary. A common mistake is including terms that reference non-existent keys, which happens because the dictionary does not cover all possible index combinations. More generally, this reflects that the model must be validated to ensure all indices are correctly mapped to data sources.",
    "example": "# Wrong: model.setObjective(gp.quicksum(cost[i, j] * x[i, j] for i in N for j in N), GRB.MINIMIZE)\n# Correct: model.setObjective(gp.quicksum(cost[i, j] * x[i, j] for i in N for j in N if i != j), GRB.MINIMIZE)",
    "iteration": 2,
    "version": 1,
    "task_id": "E042",
    "occurrence": 0,
    "distribution": {
      "positive": [],
      "negative": [],
      "unretrieved": [],
      "irrelevant": [],
      "invalid": []
    }
  }
]