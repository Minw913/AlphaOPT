{
  "Domain Modeling": {
    "Resource Allocation": {
      "Capacity/Resource Balance Equations": {
        "definition": "Conserve each resource at every node: inflow - outflow = demand or supply.",
        "condition": "Applies when the problem domain requires resources to move or transform through nodes and local conservation must hold."
      },
      "Set-Partitioning/Assignment": {
        "definition": "Assign each task to exactly one resource or agent using ∑_j x_ij = 1 constraints.",
        "condition": "Applies when the problem description requires each item or task to be exclusively assigned to exactly one choice among many."
      },
      "Fixed Charge (Big-M Linking)": {
        "definition": "Link an activity or capacity to a binary on/off decision using Big-M (or indicator) constraints",
        "condition": "Applies when the problem description requires a facility, option, or mode to be activated by a binary choice."
      },
      "Chance Constraints": {
        "definition": "Constrain the weighted average probability of an adverse event to stay below a specified threshold.",
        "condition": "Applies when the problem description sets a limit on the average chance of an adverse outcome across options or scenarios(e.g., stake, volume, or weight)."
      },
      "Expected-return Objective": {
        "definition": "Maximize expected return by weighting each option's payoff by its success probability.",
        "condition": "Applies when the problem description calls for maximizing the average/expected payout or return across options given their win/lose probabilities."
      }
    },
    "Network Flow": {
      "Flow Conservation": {
        "definition": "For each node: inflow - outflow = net demand (could be negative for supply).",
        "condition": "Applies when the problem description involves quantities traversing a directed network and nodal balance must be maintained."
      },
      "Max-Flow Objective": {
        "definition": "Maximize total flow sent from source to sink.",
        "condition": "Applies when the problem description requires maximizing throughput between designated source and sink nodes."
      },
      "Source Flow Constraint": {
        "definition": "Enforce flow conservation at a designated source by equating its net outflow to the total flow injected into the network (e.g., supply sent toward sinks).",
        "condition": "Applies when the problem description designates a source node that distributes resources through a network to sinks and requires explicit conservation at the source."
      },
      "Source-Sink Flow Conservation": {
        "definition": "Ensure explicit conservation at designated source and sink so total net outflow from the source equals total net inflow to the sink (with standard node balances elsewhere).",
        "condition": "Applies when the problem description specifies a source and a sink and requires routing/transferring flow between them with explicit balance at those terminal nodes."
      },
      "Arc-Capacity Constraints": {
        "definition": "Limit flow on each arc: 0 ≤ f_ij ≤ cap_ij.",
        "condition": "Applies when the problem domain contains edges with maximum throughput or capacity limits."
      }
    },
    "Production Planning": {
      "Inventory Balance Equations": {
        "definition": "Track stock level over time: I_t = I_{t-1} + production - demand.",
        "condition": "Applies when the problem description involves materials or products that carry over between periods and must satisfy stock-flow balance."
      },
      "Technical Ratio Constraints": {
        "definition": "Impose proportional relationships among production quantities by translating ratio requirements into linear (in)equality constraints.",
        "condition": "Applies when the problem description specifies minimum/maximum production ratios or recipe proportions between products or stages."
      },
      "Time-Indexed Variables": {
        "definition": "Define decision variables for every period (e.g., x_t) to capture dynamics.",
        "condition": "Applies when the problem domain requires discrete time modeling to capture capacities, setups, or carryover decisions."
      },
      "Composition Bounds": {
        "definition": "Bound the aggregate use of shared resources by linking each product's consumption to per-resource capacity with linear inequalities",
        "condition": "Applies when the problem description specifies multiple products sharing limited resources (e.g., machine hours or labor) that require explicit per-resource capacity limits."
      }
    },
    "Balancing": {
      "Load Balancing Constraints": {
        "definition": "Keep workload across agents within a tolerance band.",
        "condition": "Applies when the problem description requires fairness or controls maximum imbalance across parallel resources."
      },
      "Proportion Constraints": {
        "definition": "Constrain the share of one component relative to the total by enforcing upper/lower bounds on proportions.",
        "condition": "Applies when the problem description limits the maximum or minimum proportion of a resource, flow, or activity relative to the total."
      }
    },
    "Packaging": {
      "Knapsack Constraints": {
        "definition": "Capacity ∑ w_i x_i ≤ C with binary x_i selecting items.",
        "condition": "Applies when the problem domain requires selecting items that consume a single scalar capacity such as weight, volume, or budget."
      }
    },
    "Facility Location": {
      "Fixed Charge (Big-M Linking)": {
        "definition": "Open-close binary y_j with customer flow constrained by M·y_j.",
        "condition": "Applies when the problem description specifies that service or flow is allowed only if a facility is opened."
      }
    },
    "Selection": {
      "Binary Selection Constraints": {
        "definition": "Pick subset of items with 0-1 variables and cardinality limit.",
        "condition": "Applies when the problem domain requires choosing a subset under count, budget, or compatibility limits."
      }
    },
    "Routing": {
      "Subtour Elimination Constraints": {
        "definition": "Prevent cycles not containing the depot (e.g., MTZ, SEC).",
        "condition": "Applies when the problem description allows decision variables to form disconnected cycles that must be eliminated."
      }
    }
  },
  "General Formulation": {
    "Variable Definition": {
      "Continuous vs. Discrete Confusion": {
        "definition": "Choose integer/binary for indivisible items; continuous for divisible flows.",
        "condition": "Applies when decision quantities in the problem represent indivisible counts or choices versus divisible amounts such as flows."
      },
      "Explicit Bounds": {
        "definition": "Set realistic lb/ub to speed presolve and prevent negative or excessive values.",
        "condition": "Applies when the problem description provides natural physical, economic, or logical limits that can tightly bound decision variables."
      },
      "Indexing & Data Structure Alignment": {
        "definition": "Ensure variable indices match parameter keys to avoid KeyError.",
        "condition": "Applies when variables are indexed over sets or dictionaries that must align with the keys of the provided data."
      },
      "Redundant Auxiliary Variables": {
        "definition": "Avoid dummy vars when expression can be placed directly in the model.",
        "condition": "Applies when auxiliary variables merely re-express existing linear combinations without adding modeling value."
      }
    },
    "Constraint Formulation": {
      "Incorrect Relational Operators": {
        "definition": "Use ≥, ≤ not strict <,>; match 'at most'/'at least' intent.",
        "condition": "Applies when natural-language statements such as 'at most' or 'at least' must be translated into algebraic inequalities."
      },
      "Linearization of Non-linear Forms": {
        "definition": "Transform nonlinear expressions into linear (e.g., product, ratio).",
        "condition": "Applies when nonlinear relations among variables reduce tractability or solver performance."
      },
      "Big-M & Indicator Variables": {
        "definition": "Using binary variables with large-M constants to activate or deactivate constraints.",
        "condition": "Applies when constraints depend on logical on/off conditions controlled by binary variables."
      }
    },
    "Objective Specification": {
      "Sum vs. Makespan Confusion": {
        "definition": "Distinguish minimizing total completion time vs. maximum finish time.",
        "condition": "Applies when multiple resources or activities can run in parallel and the objective is ambiguous between total completion time and makespan."
      }
    },
    "Units Scaling": {
      "Unit Inconsistency": {
          "definition": "Keep all terms in compatible units",
          "condition": "Applies when input data come from different unit systems or incompatible measurement scales."
      },
      "Big-M Magnitude & Numerical Stability": {
        "definition": "Select the smallest valid Big-M constants from problem-specific upper bounds to keep relaxations tight and maintain numerical stability.",
        "condition": "Applies when the problem description uses Big-M to model on/off or conditional constraints and realistic bounds can be derived to calibrate M."
      }
    }
  },
  "Code Implementation": {
    "Solver & API Syntax": {
      "Quicksum vs. sum Syntax": {
        "definition": "`gp.quicksum()` builds expressions efficiently; Python `sum()` is slow.",
        "condition": "Applies when the mathematical model contains linear expressions aggregated over large index sets that should be constructed using solver-native summation operators."
      },
      "Strict Inequalities": {
        "definition": "Replace x < y with x ≤ y - 1 for integer vars, or add ε-buffer for continuous.",
        "condition": "Applies when the mathematical model contains strict inequality relations between variables that cannot be directly handled by LP/MIP solvers."
      },
      "Nonlinear Constraint Handling": {
        "definition": "Replace unsupported nonlinear terms (e.g., ratios, products, powers, abs/min/max) with solver-compatible linear/linearized forms via algebraic reformulation and auxiliary variables.",
        "condition": "Applies when the problem description introduces nonlinear relationships (e.g., proportions or multiplicative effects) that must be enforced in an LP/MIP model."
      },
      "Binary Constraint Handling": {
        "definition": "Represent on/off or selection decisions with binary variables and avoid redundant bounds/constraints the solver already enforces.",
        "condition": "Applies when the problem description involves yes/no (open/close, select/not-select) decisions that require variables restricted to {0,1}, without adding extra [0,1] constraints."
      },
      "Expression Syntax for Constraints": {
        "definition": "Express constraints with the solver's native algebraic operators (==, <=, >=) and declared variable types, avoiding operator-as-argument calls and redundant constraints.",
        "condition": "Applies when the problem description specifies equality/inequality relations (e.g., balances, conservation, on/off logic) that should be encoded directly as solver expressions."
      },
      "Variable Bounds Specification": {
        "definition": "Variable bounds specification is a constraint that allows the change of a variable from one value to another.",
        "condition": "Applies when the problem description requires the change of a variable from one value to another."
      }
    },
    "Data I/O & Validation": {
      "KeyError & Index Mismatch": {
        "definition": "Attempting to access non-existent dict entry; fix by `.get()` or validation.",
        "condition": "Applies when the mathematical model contains indexed variables or parameters that are accessed with indices not present in the corresponding data structures."
      },
      "Missing Data Defaults": {
        "definition": "Provide default 0 when optional parameter absent to avoid `None`.",
        "condition": "Applies when the mathematical model contains optional parameters whose values may be absent in the dataset and require default assignments to preserve model validity."
      }
    }
  }
}